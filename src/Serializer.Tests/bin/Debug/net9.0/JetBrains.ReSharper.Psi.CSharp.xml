<?xml version="1.0"?>
<doc>
    <assembly>
        <name>JetBrains.ReSharper.Psi.CSharp</name>
    </assembly>
    <members>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.Tree.IArrayCreationExpression.Dimensions">
            <summary>
            returns array of dimensions, e.g.
              for 'new int[]'               returns { 1 }
              for 'new int[10]'             returns { 1 }
              for 'new int[,,,]'            returns { 4 }
              for 'new int[,][,,][]'        returns { 2, 3, 1 }
              for 'new int[5,6][,,][]'      returns { 2, 3, 1 }
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.Tree.IArrayCreationExpression.Sizes">
            <summary>
            returns list of 'size' expressions for first dimension, e.g.
              for 'new int[]'               returns { null }
              for 'new int[x]'              returns { x }
              for 'new int[,,,]'            returns { null, null, null, null }
              for 'new int[,][,,][]'        returns { null, null }
              for 'new int[x + y,z][,,][]'  returns { x + y, z }
                TODO: this is not implemented yet
              for 'new int[5,,6][,,][]'     returns { 5, null, 6 }
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Tree.IAssignmentExpression">
             <summary>
             Assignment is a weird beast now:
            
             `a = b`
             `a += b`
             `a ??= b`
             `a = ref b`
             `var (a, b) = c`
             `(a, b) = c;
             `(var a, var b) = c`
             </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Tree.IClassLikeDeclaration.InsertAtSpecificPosition``1(``0,JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Insert given class member at the first safe place AFTER given token
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.Tree.IConstantOrTypePattern.ConstantValue">
            <summary>
            Expression under constant pattern do implicitly converts to pattern's dispatch type,
            like "governing" type of 'switch' statement of expression operand type of 'is' expression.
            This property returns constant value of expression under pattern with the correct type
            and should generally be used instead of <see cref="P:JetBrains.ReSharper.Psi.CSharp.Tree.IConstantOrTypePattern.Expression"/>'s
            <see cref="P:JetBrains.ReSharper.Psi.IConstantValueOwner.ConstantValue"/> property value.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpArgument.ParameterNameReference">
            <summary>
            If argument is named, then returns reference to corresponding parameter.
            If argument is positional, then returns <c>null</c>
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression.GetContainingExpression">
            <summary>Gets the expression which uses the current expression as an operand.</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression.GetContainingStatement">
            <summary>Gets the statement which uses the current expression as an operand.</summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression.IsClassifiedAsVariable">
            <summary>Check if the expression could be classified as a variable according to C# spec 5.4.</summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression.IsLValue">
            <summary>Check if the expression is L-value.</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression.ReplaceBy``1(``0)">
            <summary>Replace this expression by the copy of the given expression. Insert parentheses if necessary.</summary>
            <returns>The copy of given expression which was actually inserted into tree</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpNamespaceDeclaration.ReplaceBy(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpNamespaceDeclaration)">
            <summary>Replace this namespace declaration by the copy of the given</summary>
            <param name="namespaceDeclaration"></param>
            <returns>The clone of the original namespace which was added into the tree</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpNamespaceDeclaration.GetDeclaredNamespaces">
            <summary>Returns all namespaces declared by this decslaration.</summary>
            <example>
            <code>
            namespace X {
              namespace Y.Z.W {} // (*)
            }
            </code>
            <c>GetDeclaredNamespaces</c>> for (*) returns <c>X.Y.Z.W</c>,  <c>X.Y.Z</c> and  <c>X.Y</c> in that order.
            </example>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpStatement.GetContainingStatement">
            <summary>Gets the statement in which the given statement is located</summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpStatement.CanBeEmbedded">
            <summary>Checks if this statement is valid embedded statement according to C# specs</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpStatement.ReplaceBy``1(``0)">
            <summary>Replace this statement in the tree by the copy of the given statement</summary>
            <param name="statement"></param>
            <returns>The clone of the original statement which was added into the tree </returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeAndNamespaceHolderDeclaration.AddImportAfter(JetBrains.ReSharper.Psi.CSharp.Tree.IUsingDirective,JetBrains.ReSharper.Psi.CSharp.Tree.IUsingDirective)">
            <summary>
            This is low-level method when you need to insert directive in a specific place.
            It also doesn't account for comments and preprocessor directives. Consider using AddImport instead of it
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeAndNamespaceHolderDeclaration.AddImportBefore(JetBrains.ReSharper.Psi.CSharp.Tree.IUsingDirective,JetBrains.ReSharper.Psi.CSharp.Tree.IUsingDirective)">
            <summary>
            This is low-level method when you need to insert directive in a specific place.
            It also doesn't account for comments and preprocessor directives. Consider using AddImport instead of it
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.Tree.IExtendedType.TypeReference">
            <summary>
            This reference is NOT presented in GetReferencedAssemblyNames() list for this element
            It is in GetReferencedAssemblyNames() of corresponding ReferenceName
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Tree.IIsExpression">
            <summary>
            Since, C# 7.0 turned 'is' expression into a terrible mess, you should be ready for the following cases:
            
            'x is int', 'x is T[]', 'x is T{U}' (generic type)
            
              Ordinary type-checking 'is' operator.
              Type operand will be parsed as <see cref="T:JetBrains.ReSharper.Psi.CSharp.Tree.ITypePattern"/> without variable designation.
            
              <see cref="P:JetBrains.ReSharper.Psi.CSharp.Tree.IIsExpression.IsType"/> property returns the type from <see cref="P:JetBrains.ReSharper.Psi.CSharp.Tree.ITypePattern.TypeUsage"/>.
              <see cref="M:JetBrains.ReSharper.Psi.CSharp.Tree.IIsExpression.GetKind(JetBrains.ReSharper.Psi.Resolve.Managed.IResolveContext,System.Boolean)"/> returns <see cref="F:JetBrains.ReSharper.Psi.CSharp.Tree.IsExpressionKind.TypeCheck"/>.
            
            'x is T'
            
              Ordinary type-checking 'is' operator. Type operand will be parsed as a <see cref="T:JetBrains.ReSharper.Psi.CSharp.Tree.IConstantOrTypePattern"/>
              with <see cref="T:JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression"/> as a constant expression, since there is no way to disambiguate
              constant pattern from simple type usage that looks like <see cref="T:JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression"/>.
            
              <see cref="P:JetBrains.ReSharper.Psi.CSharp.Tree.IIsExpression.IsType"/> property returns the type this <see cref="T:JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression"/> is resolved into.
              <see cref="P:JetBrains.ReSharper.Psi.CSharp.Tree.IIsExpression.IsType"/> property returns unresolved (not unknown) type in the case of unresolved <c>T</c>.
              <see cref="M:JetBrains.ReSharper.Psi.CSharp.Tree.IsExpressionExtensions.IsPatternMatching(JetBrains.ReSharper.Psi.CSharp.Tree.IIsExpression,JetBrains.ReSharper.Psi.Resolve.Managed.IResolveContext)"/> would help with disambiguating this kind
              of type check from constant pattern matching, but it requires semantic resolution of <c>T</c>.
              <see cref="M:JetBrains.ReSharper.Psi.CSharp.Tree.IIsExpression.GetKind(JetBrains.ReSharper.Psi.Resolve.Managed.IResolveContext,System.Boolean)"/> returns <see cref="F:JetBrains.ReSharper.Psi.CSharp.Tree.IsExpressionKind.TypeCheck"/>.
            
            'x is T t', 'x is T _'
            
              Pattern-matching 'is' with <see cref="T:JetBrains.ReSharper.Psi.CSharp.Tree.ITypePattern"/> exposed via <see cref="P:JetBrains.ReSharper.Psi.CSharp.Tree.IIsExpression.Pattern"/> property.
            
              <see cref="P:JetBrains.ReSharper.Psi.CSharp.Tree.IIsExpression.IsType"/> property returns type from this <see cref="P:JetBrains.ReSharper.Psi.CSharp.Tree.ITypePattern.TypeUsage"/>.
              <see cref="M:JetBrains.ReSharper.Psi.CSharp.Tree.IsExpressionExtensions.IsPatternMatching(JetBrains.ReSharper.Psi.CSharp.Tree.IIsExpression,JetBrains.ReSharper.Psi.Resolve.Managed.IResolveContext)"/> returns <c>true</c> for such 'is' expression.
              <see cref="M:JetBrains.ReSharper.Psi.CSharp.Tree.IIsExpression.GetKind(JetBrains.ReSharper.Psi.Resolve.Managed.IResolveContext,System.Boolean)"/> returns <see cref="F:JetBrains.ReSharper.Psi.CSharp.Tree.IsExpressionKind.PatternMatching"/>.
            
            'x is var t'
            
              Pattern-matching 'is' with <see cref="T:JetBrains.ReSharper.Psi.CSharp.Tree.IVarPattern"/> exposed via <see cref="P:JetBrains.ReSharper.Psi.CSharp.Tree.IIsExpression.Pattern"/> property.
            
              <see cref="P:JetBrains.ReSharper.Psi.CSharp.Tree.IIsExpression.IsType"/> property returns the type of left <see cref="P:JetBrains.ReSharper.Psi.CSharp.Tree.IIsExpression.Operand"/> expression.
              <see cref="M:JetBrains.ReSharper.Psi.CSharp.Tree.IsExpressionExtensions.IsPatternMatching(JetBrains.ReSharper.Psi.CSharp.Tree.IIsExpression,JetBrains.ReSharper.Psi.Resolve.Managed.IResolveContext)"/> returns <c>true</c> for such 'is' expression.
              <see cref="M:JetBrains.ReSharper.Psi.CSharp.Tree.IIsExpression.GetKind(JetBrains.ReSharper.Psi.Resolve.Managed.IResolveContext,System.Boolean)"/> returns <see cref="F:JetBrains.ReSharper.Psi.CSharp.Tree.IsExpressionKind.PatternMatching"/>.
            
            * 'x is null', 'x is 42'
            
              Pattern-matching 'is' with <see cref="T:JetBrains.ReSharper.Psi.CSharp.Tree.IConstantOrTypePattern"/> exposed via <see cref="P:JetBrains.ReSharper.Psi.CSharp.Tree.IIsExpression.Pattern"/> property.
            
              <see cref="P:JetBrains.ReSharper.Psi.CSharp.Tree.IConstantOrTypePattern.ConstantValue"/> contains the constant value, implicitly converted to the type
              of <see cref="P:JetBrains.ReSharper.Psi.CSharp.Tree.IIsExpression.Operand"/> expression and should be used instead of <see cref="!:ICSharpExpression.ConstantValue"/>
              over <see cref="P:JetBrains.ReSharper.Psi.CSharp.Tree.IConstantOrTypePattern.Expression"/> expression.
            
              <see cref="P:JetBrains.ReSharper.Psi.CSharp.Tree.IIsExpression.IsType"/> returns the type of <see cref="P:JetBrains.ReSharper.Psi.CSharp.Tree.IConstantOrTypePattern.ConstantValue"/>.
              <see cref="M:JetBrains.ReSharper.Psi.CSharp.Tree.IsExpressionExtensions.IsPatternMatching(JetBrains.ReSharper.Psi.CSharp.Tree.IIsExpression,JetBrains.ReSharper.Psi.Resolve.Managed.IResolveContext)"/> returns <c>true</c> for such 'is' expression.
              <see cref="M:JetBrains.ReSharper.Psi.CSharp.Tree.IIsExpression.GetKind(JetBrains.ReSharper.Psi.Resolve.Managed.IResolveContext,System.Boolean)"/> returns <see cref="F:JetBrains.ReSharper.Psi.CSharp.Tree.IsExpressionKind.PatternMatching"/>.
            
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Tree.IPattern.GetPatternType(JetBrains.ReSharper.Psi.Resolve.Managed.IResolveContext)">
            <summary>
            Get the type that is actually used for type check (if any) at runtime time.
            Return 'unknown type' for negated patterns.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression.IsQualified">
            <summary>
            Checks if the reference expression is semantically qualified or not (depends on some other terms to be resolved or resolves via global table).
            Returns 'false' if this reference expression can reference local variable.
            Returns 'true' for member access in subpattern `is { ReferenceExpression: pat }`.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Tree.ISwitchStatement.GetGoverningType">
            <summary>
            Computes the governing type of the switch condition (according to p8.7.2 of C# spec)
            If the condition expression is of the integral type or enum, then this type is returned.
            Otherwise, there must be one and only one implicit conversion operator to integral type
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.Tree.ITupleComponent.NamedTupleComponentReference">
            <summary>
            Gets reference to named tuple component if there is an explicit or inferred name.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.Tree.ITupleTypeComponent.NamedTupleComponentReference">
            <summary>
            Returns reference to <see cref="T:JetBrains.ReSharper.Psi.INamedTupleComponent"/> if tuple type component is named;
            otherwise returns <c>null</c>.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.Tree.ITypeArgumentList.TypeArgumentNodes">
            <summary>
            Get the list of type arguments. Corresponding item in list is <c>null</c> if none is written in the source code, for example:
            <c>typeof(C&lt;&gt;)</c>
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterConstraintsClause.AddTypeParameterConstraint``1(``0)">
            <summary>
            Adds type parameter constraint to appropriate place.
            It's caller's responsibility to remove conflicting constraints.
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Tree.AttributeTarget">
            <remarks>
            C# spec, 17.2 Attribute specification
            </remarks>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Tree.AttributeTarget.None">
            <summary>
             No target is specified
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Tree.AttributeTarget.Unknown">
            <summary>
            Unrecognized target
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Tree.IAwaitReferencesOwner">
            <summary>
            Exposes common members of 'await' constructs for resolve purposes.
            <remarks>
            This interface is NOT intended to be used in PSI features,
            please use pattern matching over C# tree node instead.
            </remarks>
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.Tree.IAwaitReferencesOwner.AwaitRange">
            <summary>
            'await' keyword range
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Tree.CollectionExpressionKind.Array">
             <summary>
             Target type is an array:
            <code>
             int[] a = [1, 2, 3];
             </code>
             </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Tree.CollectionExpressionKind.Span">
            <summary>
            Target type is a Span&lt;T&gt;: <code>
            Span&lt;int&gt; a = [1, 2, 3];
            </code>
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Tree.CollectionExpressionKind.ReadOnlySpan">
            <summary>
            Target type is a ReadOnlySpan&lt;T&gt;: <code>
            ReadOnlySpan&lt;int&gt; b = [1, 2, 3];
            </code>
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Tree.CollectionExpressionKind.CollectionBuilder">
            <summary>
            Target type is a type with a builder method:
            <code>
            [CollectionBuilder(typeof(ImmutableArray), "Create")]
            public struct ImmutableArray&lt;T&gt; { ... }
            ...
            public static class ImmutableArray
            {
             public static ImmutableArray&lt;T&gt; Create&lt;T&gt;(ReadOnlySpan&lt;T&gt; items) { ... }
            }
            ...
            ImmutableArray&lt;int&gt; a = [1, 2, 3];
            </code>
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Tree.CollectionExpressionKind.ImplementsIEnumerable">
            <summary>
            Target type is a type that implements IEnumerable:
            <code>
            public class MyCollection&lt;T&gt; : IEnumerable&lt;T&gt; // inherited from IEnumerable
            {
              public IEnumerator&lt;T&gt; GetEnumerator() { }
              IEnumerator IEnumerable.GetEnumerator() { }
              ...
            }
            ...
            MyCollection&lt;int&gt; a = [1, 2, 3];
            </code>
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Tree.CollectionExpressionKind.ArrayInterface">
            <summary>
            Target type is a generic interface implemented by List&lt;T&gt;:
            <code>
            IReadOnlyList&lt;int&gt; a = [1, 2, 3];
            </code>
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Tree.CollectionExpressionElementKinds">
            <summary>
            Kinds of collection expression elements.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Tree.CollectionExpressionExtensions.CanBeLoweredToRuntimeHelpersCreateSpan(JetBrains.ReSharper.Psi.CSharp.Tree.ICollectionExpression)">
            <summary>
            Checks if a collection expression with a given element type can be lowered into <code>RuntimeHelpers.CreateSpan&lt;T&gt;((RuntimeFieldHandle)...)</code>
            </summary>
            <remarks>
            The following conditions must hold in order to use `RuntimeHelpers.CreateSpan()`:
            * non-empty
            * element type is allowed in blob wrapper (<see cref="M:JetBrains.ReSharper.Psi.Util.TypesUtil.IsTypeAllowedInBlobWrapper(JetBrains.ReSharper.Psi.IType)"/>)
            * all elements have constant values
            </remarks>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.Tree.IConditionalAccessExpression.HasConditionalAccessSign">
            <summary>
            Checks if access expression is really conditional:
            * IReferenceExpression     - if 'a?.B'
            * IInvocationExpression    - always false
            * IElementAccessExpression - if 'a?[b]'
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.Tree.IConditionalAccessExpression.ConditionalQualifier">
            <summary>Reference qualifier, invoked expression or indexer operand.</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Tree.IConditionalAccessExpression.SetConditionalQualifier(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression)">
            <summary>Set conditional qualifier (without inserting parentheses for conditional access expressions).</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Tree.ConditionalAccessExpressionExtensions.IsPartOfConditionalAccess(JetBrains.ReSharper.Psi.CSharp.Tree.IConditionalAccessExpression)">
            <summary>
            Checks if expression has conditional access sign somewhere in the qualifier expressions.
            
              foo.Bar?.Baz().Qux
              |   |    |__|__|___ true
              |___|______________ false
            
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Tree.ConditionalAccessExpressionExtensions.IsTopPartOfConditionalAccess(JetBrains.ReSharper.Psi.CSharp.Tree.IConditionalAccessExpression)">
            <summary>
            Checks if expression is a top part of conditional access (with lifted type).
            
              foo?.Bar().Baz?[42].Qux
              |____|__|__|___|___ | __ false
                                  |___ true
            
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Tree.ConditionalAccessExpressionExtensions.IsIntermediatePartOfConditionalAccess(JetBrains.ReSharper.Psi.CSharp.Tree.IConditionalAccessExpression)">
            <summary>
            Checks if expression is not top part of conditional access (with non-lifted type).
            
              foo?.Barr(a).Baz?[42].Qux
              |    |___|___|___|___ | __ true
              |_____________________|___ false
            
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Tree.ConditionalAccessExpressionExtensions.IsAllowedConditionalAccessQualifierType(JetBrains.ReSharper.Psi.IExpressionType)">
            <summary>
            Checks if you can apply conditional access expression to qualifier expression of some type.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Tree.ConditionalAccessExpressionExtensions.IsAllowedConditionalAccessExpressionType(JetBrains.ReSharper.Psi.IExpressionType)">
            <summary>
            Checks if whole expression type can be lifted after applying conditional access expression.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Tree.ConditionalAccessExpressionExtensions.IsTopConditionalAccess(JetBrains.ReSharper.Psi.CSharp.Tree.IConditionalAccessExpression)">
            <summary>
            Checks if expression is a top part of conditional access expression:
            
              foo?.Bar().Baz?[42].Qux
              |    |  |  |   |    |___ true
              |____|__|__|___|________ false
            
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Tree.ConditionalAccessExpressionExtensions.GetConditionalAccessQualifier(JetBrains.ReSharper.Psi.CSharp.Tree.IConditionalAccessExpression)">
            <summary>
            Gets qualifier expression of current conditional access expression:
            
              foo?.Bar().Baz?[42].Qux
              |    |  |  |   |____|___ foo?.Bar().Baz
              |    |__|__|____________ foo
              |_______________________ null
            
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Tree.ConditionalAccessExpressionExtensions.GetLiftedExpressionType(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression)">
            <summary>
            Gets type of expression like it is standalone from conditional access chain:
            
              foo?.Value.ToString()
                   |     |__________ System.String
                   |________________ System.Int32?
            
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Tree.ConditionalAccessExpressionNavigator.GetByQualifier(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression)">
            <summary>
            Gets conditional access expression by it's qualifier expression:
            
              var t = foo?.Bar().Baz + 1
                      |    |  |  |_______ null
                      |    |  |__________ foo?.Bar().Baz
                      |    |_____________ foo?.Bar()
                      |__________________ foo?.Bar
            
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Tree.ConditionalAccessExpressionNavigator.GetTopByQualifier(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression)">
            <summary>
            Gets top conditional access expression by it's qualifier expression:
            
              var t = foo?.Bar().Baz?.Qux + 1
                      |    |  |  |    |_______ null
                      |    |  |  |____________ foo?.Bar().Baz?.Qux
                      |____|__|_______________ foo?.Bar().Baz
            
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Tree.CSharpDeclarationExtensions.HasCodeBody(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpDeclaration)">
            <summary>
            Checks if declaration has a block or expression body.
            </summary>
            <remarks>
            This method is not equal to '.GetCodeBody() != null', since  it returns <c>true</c>
            if expression-bodied member/local functions has '=>' clause without expression
            </remarks>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Tree.CSharpTreeNodeExtensions.GetContainingFunctionLikeDeclarationOrClosure(JetBrains.ReSharper.Psi.Tree.ITreeNode,System.Boolean)">
            <summary>
            Get the containing method/constructor/operator/expression-bodied property or indexer/top-level code
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Tree.IElementAccessExpressionReference.IsPassThrough(JetBrains.ReSharper.Psi.Resolve.Managed.IResolveContext)">
            <summary>
            Returns 'true' is this reference resolves into C#/COM indexed property
            mentioned in element access operand reference expression, returns
            'false' in all otherwise cases (array indexers, custom indexers, etc)
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Tree.IForeachReferencesOwner">
            <summary>
            Exposes common members of foreachable constructs (e.g. foreach statement, collection expression) for resolve purposes.
            <remarks>
            This interface is NOT intended to be used in PSI features,
            please use pattern matching over C# tree node instead.
            </remarks>
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.Tree.IForeachReferencesOwner.IterationReferencesRange">
            <summary>
            References range, 'foreach' keyword for foreach statement, '[' token for collection expressions.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.Tree.IForeachReferencesOwner.Collection">
            <summary>
            Collection for iteration.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.Tree.IForeachReferencesOwner.GetEnumeratorReference">
            <summary>
            Gets the reference to 'GetEnumerator' method (or 'GetAsyncEnumerator' in an 'await foreach')
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.Tree.IForeachReferencesOwner.MoveNextReference">
            <summary>
            Gets the reference to 'GetEnumerator().MoveNext' method (or 'GetAsyncEnumerator().MoveNextAsync' in an 'await foreach')
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.Tree.IForeachReferencesOwner.CurrentReference">
            <summary>
            Gets the reference to 'GetEnumerator().Current' property (or 'GetAsyncEnumerator().Current' in an 'await foreach')
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Tree.InterpolatedStringKind.String">
            <summary>
            Interpolated string results in a value of 'string' type.
            Translates to 'string.Format(...)' or optimized 'string.Concat' call.
            </summary>
            <remarks>
            If to get the 'string' instance the compiler uses 'DefaultInterpolatedStringHandler' type
            we return <see cref="F:JetBrains.ReSharper.Psi.CSharp.Tree.InterpolatedStringKind.InterpolatedStringHandler"/> instead (to allow spans in holes).
            </remarks>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Tree.InterpolatedStringKind.FormattableString">
            <summary>
            Interpolated string results in a 'FormattableString' or 'IFormattable' value.
            Translates to 'FormattableStringFactory.Create(...)' call.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Tree.InterpolatedStringKind.InterpolatedStringHandler">
            <summary>
            Interpolated string results in a value of the corresponding interpolated string handler type (type marked with [InterpolatedStringHandler] attribute).
            Translates to creation of corresponding interpolated string handler with subsequent 'AppendLiteral' and 'AppendFormatted' calls.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Tree.InterpolatedStringExpressionExtensions.GetFirstLiteralRange(JetBrains.ReSharper.Psi.CSharp.Tree.IInterpolatedStringExpression)">
            <summary>
            Returns refined range of the first literal part in the interpolated string expression.
            </summary>
            <remarks>
            Refined range does not include leading/trailing '$', '@', '{', '}' i.e. represents range of exactly textual part.
            </remarks>
            <example>
            Input: $"Abc {0}"
            Range:   ^^^
            
            Input: $"{0} Abc {1} Def"
            Range:      ^^^^^
            </example>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Tree.InterpolatedStringExpressionExtensions.GetPartsCount(JetBrains.ReSharper.Psi.CSharp.Tree.IInterpolatedStringExpression)">
            <summary>
            Returns count of inserts and literals.
            </summary>
            <example>
            $"a{0}"   -> 2
            $"a{0}b"  -> 3
            $"{0}{1}" -> 2
            </example>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpressionReference.IsPassThrough(JetBrains.ReSharper.Psi.Resolve.Managed.IResolveContext)">
            <summary>
            Returns 'true' is this reference resolves into method or local function directly mentioned in invoked reference expression,
            'false' otherwise (for example, in a case of delegate variable invocation, this reference resolves into delegate type's Invoke() method)
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.Tree.IPartialTypeMemberDeclaration.IsPartial">
            <example>
            <code>
            partial void AfterCommit();     // IsPartial=true,  IsPartialDefinition=true
            partial void AfterCommit() {}   // IsPartial=true,  IsPartialDefinition=false
            extern void AfterCommit();      // IsPartial=false, IsPartialDefinition=false
            public void AfterCommit() {}    // IsPartial=false, IsPartialDefinition=false
            </code>
            </example>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.Tree.IPartialTypeMemberDeclaration.IsPartialDefinition">
            <summary>
            <c>true</c> if this declaration is the definition part,
            <c>false</c> if this declaration is either the implementation part or <see cref="P:JetBrains.ReSharper.Psi.CSharp.Tree.IPartialTypeMemberDeclaration.IsPartial"/> is <c>false</c>.
            </summary>
            <inheritdoc cref="P:JetBrains.ReSharper.Psi.CSharp.Tree.IPartialTypeMemberDeclaration.IsPartial"/>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Tree.PatternExtensions.IsNegatedNullNotNullCheckPattern(JetBrains.ReSharper.Psi.CSharp.Tree.IPattern)">
            <summary>
            Checks pattern to be `not null`
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Tree.IProperTypeDeclaration">
            <summary>
            Declarations of ITypeElements that are not type parameters
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Tree.RangeKind.FromStart">
            <summary>
            'inclusiveStartIndex..'
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Tree.RangeKind.ToEnd">
            <summary>
            '..exclusiveEndIndex'
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Tree.RangeKind.FromStartToEnd">
            <summary>
            'inclusiveStartIndex..exclusiveEndIndex'
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Tree.RangeKind.Full">
            <summary>
            '..'
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Tree.ReferenceExpressionExtensions.IsExtensionMethodInvocation(JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression)">
            <summary>
            Check if extension method is invoked as extension method (but not as static method)
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Tree.ReferenceExpressionExtensions.IsSimpleNameReference(JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression)">
            <summary>Checks reference expression to be in a form of 'someName'</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Tree.ReferenceExpressionExtensions.IsSimpleNameReference(JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression,System.String@)">
            <summary>Checks reference expression to be in a form of 'someName'</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Tree.ReferenceExpressionExtensions.IsSimpleNameReference(JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression,System.String)">
            <summary>Checks reference expression to be in a form of 'expectedText'</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Tree.ReferenceExpressionExtensions.IsSimpleQualifiedNameReference(JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression,System.Boolean)">
            <summary>Checks reference expression to be in a form of 'Some.Simple.Names'</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Tree.ReferenceExpressionExtensions.IsReferenceNameLike(JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression)">
            <summary>Checks reference expression to be in a form of 'global::Some.Simple{T}.Names'</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Tree.ReferenceExpressionExtensions.IsSubpatternMemberAccessPart(JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression)">
            <summary>
            x is { ThisOne.OrThisOne: pat }
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Tree.ReferenceExpressionExtensions.IsSubpatternMostContainingMemberAccess(JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression)">
            <summary>
            x is { Qualifier.ThisOne: pat }
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Tree.ReferenceExpressionExtensions.IsUnfinishedSubpatternMemberAccessPart(JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression)">
            <summary>
            x is { ThisOne.OrThisOne }
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Tree.SubpatternExtensions.TryGetSimpleMemberReference(JetBrains.ReSharper.Psi.CSharp.Tree.ISubpattern)">
            <summary>
            Returns `Foo` reference for `x is { Foo: 42 }` pattern
            Returns `null` reference for `x is { Foo.Bar: 42 }` pattern
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Tree.SubpatternExtensions.TryGetTopLevelMemberAccess(JetBrains.ReSharper.Psi.CSharp.Tree.ISubpattern)">
            <summary>
            Returns `Foo` reference expression for `x is { Foo.Bar: 42 }` pattern
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Tree.SubpatternExtensions.TryGetTopLevelMemberReference(JetBrains.ReSharper.Psi.CSharp.Tree.ISubpattern)">
            <summary>
            Returns `Foo` reference for `x is { Foo.Bar: 42 }` pattern
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Tree.SubpatternExtensions.TryGetMostInnerMemberReference(JetBrains.ReSharper.Psi.CSharp.Tree.ISubpattern)">
            <summary>
            Returns `Bar` reference for `x is { Foo.Bar: 42 }` pattern
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Tree.IFixedPatternMethodReference">
            <summary>
            A reference to 'GetPinnableReference' method.
            See https://github.com/dotnet/csharplang/blob/master/proposals/csharp-7.3/pattern-based-fixed.md
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Tree.IVariableDesignationContainer.GetSourceType(JetBrains.ReSharper.Psi.Resolve.Managed.IResolveContext)">
            <summary>
            <see cref="T:JetBrains.ReSharper.Psi.CSharp.Tree.IDeclarationExpression"/> case:
            * For 'string s' in 'M(out string s)' returns 'string';
            * For 'var (a, b)' in 'var (a, b) = 42;' returns 'int';
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ClassBody.LevelDelta">
            <summary>
            No need to push level here, <see cref="P:JetBrains.ReSharper.Psi.CSharp.Impl.Tree.MemberOwnerDeclarationBase.LevelDelta"/> already moved to +4
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.Tree.DocCRefExpression.GetCommentRange(JetBrains.ReSharper.Psi.TreeTextRange)">
            <summary>
            Translate local tree text range (inside DocCRefExpression) to comment text range (inside containing comment)
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.Tree.DocCRefExpression.GetGlobalRange(JetBrains.ReSharper.Psi.TreeTextRange)">
            <summary>
            Translate local tree text range (inside DocCRefExpression)
            to file tree text range (inside containing comment's file)
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Impl.Tree.InterpolatedStringExpression.MyHandlerConstructorReference.ConstructorArgumentInfo">
            <summary>
            Special argument info implementation for arguments of interpolated string handler constructor.
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Impl.Tree.InterpolatedStringExpression.MyHandlerConstructorReference.OutBoolShouldAppendArgumentInfo">
            <summary>
            Special argument info for passing to trailing 'out bool shouldAppend' parameter of interpolated string handler constructor.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.Tree.LabelReferenceElement.GetCompletionSymbolTable">
            <summary>
            Returns symbol table for code completion
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.Tree.NullCoalescingExpression.CalculateExpressionTypeAux(JetBrains.ReSharper.Psi.Resolve.Managed.IResolveContext)">
            <summary>
            According to C# specs 14.12
            • If A is not a nullable type or a reference type, a compile-time error occurs. 
            • If A is a nullable type and an implicit conversion exists from b to A0, the result type is A0. At run-time, a
              is first evaluated. If a is not null, a is unwrapped to type A0, and this becomes the result. 
              Otherwise, b is evaluated and converted to type A0, and this becomes the result.
            • Otherwise, if an implicit conversion exists from b to A, the result type is A. At run-time, a is first
              evaluated. If a is not null, a becomes the result. Otherwise, b is evaluated and converted to type A, 
              and this becomes the result.
            • Otherwise, if an implicit conversion exists from A0 to B, the result type is B. At run-time, a is first
              evaluated. If a is not null, a is unwrapped to type A0 (unless A and A0 are the same type) and converted
              to type B, and this becomes the result. Otherwise, b is evaluated and becomes the result.
            • Otherwise, a and b are incompatible, and a compile-time error occurs.
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Impl.Tree.AnyArgumentResolveResult">
            <summary>
            For some features (e.g. UsageAnalyzer and Navigation) it is better to have <see cref="P:JetBrains.ReSharper.Psi.Resolve.IResolveResult.DeclaredElement"/> rather than
            multiple <see cref="P:JetBrains.ReSharper.Psi.Resolve.IResolveResult.Candidates"/>, but at the same time, we want to have relevant <see cref="P:JetBrains.ReSharper.Psi.Resolve.IResolveResult.Candidates"/>
            collection for reporting purposes.
            So let's store both and chose <see cref="P:JetBrains.ReSharper.Psi.Resolve.IResolveResult.DeclaredElement"/> as a candidate with the highest accessibility.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.Tree.AnyArgumentResolveResult.#ctor(JetBrains.ReSharper.Psi.IDeclaredElement,JetBrains.ReSharper.Psi.Resolve.ISubstitution,System.Collections.Generic.IList{JetBrains.ReSharper.Psi.IDeclaredElement},System.Collections.Generic.IList{JetBrains.ReSharper.Psi.Resolve.ISubstitution})">
            <summary>
            For some features (e.g. UsageAnalyzer and Navigation) it is better to have <see cref="P:JetBrains.ReSharper.Psi.Resolve.IResolveResult.DeclaredElement"/> rather than
            multiple <see cref="P:JetBrains.ReSharper.Psi.Resolve.IResolveResult.Candidates"/>, but at the same time, we want to have relevant <see cref="P:JetBrains.ReSharper.Psi.Resolve.IResolveResult.Candidates"/>
            collection for reporting purposes.
            So let's store both and chose <see cref="P:JetBrains.ReSharper.Psi.Resolve.IResolveResult.DeclaredElement"/> as a candidate with the highest accessibility.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.Impl.Tree.AwaitReferenceBase`1.IsWellFormedAwaitConstruct">
            <summary>
            Indicates whether an owner node has all syntactic elements required for resolve;
            In case it is 'false' reference is considered ignorable.
            <example>
            'await Task' => true
            'await _missing_' => false
            'await foreach (var x in xs)' => true
            'await foreach (var x' => false
            </example>
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.Tree.DocCommentBlock.ParseCRefExpression(System.String)">
            <param name="str">Unescaped text (no xml entities &amp; etc)</param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.Tree.DocCommentBlock.BuildTypeMemberQualification(JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.IDocCommentReference,JetBrains.ReSharper.Psi.ITypeMember,JetBrains.ReSharper.Psi.Resolve.ISubstitution)">
            <summary>
            Builds the qualified string to access the given target from our reference point
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.GroupBase.GroupKey.SampleNode">
            <summary>
            Used to determine the position of the group relative to other groups.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.DropRegions.None">
            <summary>
            Removes only regions that looks as if they were produced by reordering process (to avoid duplicating them).
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.DropRegions.AllExceptGenerated">
            <summary>
            Removes every region except generated.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.DropRegions.All">
            <summary>
            Removes all regions.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.Formatter.CSharpCodeFormatter.FormatDeletedNodes(JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Format code during WritePSI action
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.ControlFlowHistoryCheckPointInfo">
            <summary>
            Denotes to expression state at specified point
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.ControlFlowWeakVariableInfo.QualifierEqualityComparer.IsEligible(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression)">
            <summary>
            Check if given expression is eligible for comparison
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowContext">
            <summary>
            State of the single node in the control flow graph
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowContext.myVariableIndex">
            <summary>Shared between all instances of context</summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowContext.myStates">
            <summary>State for each variable from <see cref="F:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowContext.myVariableIndex"/></summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowContext.myMemorySnapshotHive">
            <summary>
            The set af possible memory states at this point
            Is <c>null</c> if the number of states greater than threshold,
            and thus the cyclomatic complexity of the code is too large
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowContext.RecursiveAtAllPaths">
            <summary>Indicates that at all paths to this point there was recursive call</summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowContextFactory.MaxNumberOfStatesPerGraph">
            <summary>
            If total number of states on all graph edges exceeded this number, then raise context overflow
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowGraphInspector.LocalFunctionAnalysis.SatisfyPrerequirement(JetBrains.ReSharper.Psi.CSharp.DeclaredElements.ILocalFunction)">
            <summary>
            Removes specified function from all prerequierements and returns the set of functions which prerequirements are now completely safisfied
            Keeps track of transitive conversion to a delayed delegate
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowGraphInspector.PatchContextBySpecialMethodCall(JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression,JetBrains.ReSharper.Psi.ControlFlow.IControlFlowElement,JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowContext)">
            <summary>
            Try to recognize invocation of special methods, and patch context accordingly
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowGraphInspector.IsSubjectToNullnessCheck(JetBrains.ReSharper.Psi.ControlFlow.IControlFlowEdge)">
            <summary>
            Check if possible NRE should be checked if jump by <paramref name="edge"/>
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowVariableValue.UNKNOWN">
            <summary>
            Variable state is completely unknown
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowVariableValue.CONTAINER">
            <summary>
            Value for container-like variables (collections, Lazy{T}, Task{T}), should be composed
            with UNKNOWN/NULL/NOT_NULL flags which means values for elements of the container
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowVariableValue.WEAK_UNKNOWN">
            <summary>
            Special value for unchecked variables indicating that value is unknown and possible NRE shouldn't be reported
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowVariableValue.WEAK_NOT_NULL">
            <summary>
            Special value for unchecked variables indicating that value is though known to be non NULL
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowVariableValue.WEAK_CANBENULL">
            <summary>
            Special value for unchecked variables indicating that value is unknown, but though can be null
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.IEfSerializedType.ToShortString">
            <summary>
            Only use for presentation. Do not for caching or hash table keys.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EfSerializedDeclaredType.ProcessTypeDecorations(JetBrains.ReSharper.Psi.IType)">
            <returns> true if any serializable decorations are found </returns>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkCanonicalFunctionsUtils.ourCanonicalSimpleClrMethodNames">
            <summary>
            There methods are supported in LINQ to Entities
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkCanonicalFunctionsUtils.ourCanonicalQueryableProjectionClrMethodsShortNames">
            <summary>
            Overloads which do not accept positional arguments are supported in LINQ to Entities
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkCanonicalFunctionsUtils.ourCanonicalOrderingClrMethodsShortNames">
            <summary>
            Overloads which do not accept IComparer are supported in LINQ to Entities
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkCanonicalFunctionsUtils.ourCanonicalEqualityComparingClrMethodsShortNames">
            <summary>
            Overloads which do not accept IEqualityComparer are supported in LINQ to Entities
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkCanonicalFunctionsUtils.ourCanonicalAggregateClrMethodShortNames">
            <summary>
            All overloads seem to be supported in LINQ to Entities (contradicts documentation)
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkCanonicalFunctionsUtils.IsServerAndClientSideMethod(JetBrains.ReSharper.Psi.IMethod,JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkMajorVersion)">
            <returns> Whether this method can be run on both client and server side without throwing exceptions </returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkConfigReaderBase.ProcessMethod(System.String,JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression)">
            <returns> Whether current <see cref="T:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkConfigReaderBase"/> should stop at this method </returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkConfigReaderBase.ReadConfigMethodInvocationExpression(JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression,System.Collections.Generic.IEnumerable{JetBrains.ReSharper.Psi.IType})">
            <returns> Whether the invocation expression could be related to the DbContext configuration </returns>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkInheritableConfigReaderWithChildren`4.Type">
            <summary>
            Stays null until types are resolved for the first time
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkInheritableConfigReaderWithChildren`4.TypeElement">
            <summary>
            Stays null until types are resolved for the first time
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkInheritableConfigReaderWithChildren`4.CheckAndUpdateSuperTypes(JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkModelCache,System.Collections.Generic.IList{JetBrains.ReSharper.Psi.IDeclaredType}@)">
            <returns> Whether resolve status of any super types changed </returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkContext.#ctor(JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkQueryInspector.InspectionData)">
            <summary>
            Creates initial context
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkContext.#ctor(System.Collections.Generic.IEnumerable{JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkContext.LocalContext},JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkQueryInspector.InspectionData)">
            <summary>
            Merges local contexts without copying.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkContext.#ctor(JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkContext,System.Boolean)">
            <summary>
            Creates deep or shallow clone
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkContext.AnalyzeReferenceExpression(JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression,JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkContext.Variable,JetBrains.ReSharper.Psi.IType,JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkContext.Variable,System.Func{JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.NavigationQueryData,JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.NavigationQueryResult},JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkQueryInspectorKind,System.Boolean)">
            <returns> Returns true if this expression can potentially have an issue. </returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkContext.FindInclusionInInvocationExpression(JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression,System.Boolean,System.Func{JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.NavigationQueryData,JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.NavigationQueryResult})">
            <returns> Returns true if any relevant inclusions are found </returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkContext.LocalContext.#ctor(JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkQueryInspector.InspectionData)">
            <summary>
            Creates initial context
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkContext.LocalContext.#ctor(JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkContext.LocalContext,System.Boolean)">
            <summary>
            Creates deep or shallow clone
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkContext.LocalContext.StartNewChainFromVariableUsage(JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression,JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkContext.Variable,System.Boolean,System.Nullable{JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.NavigationEntry}@)">
            <returns> Returns true if typeOwner contains information about some chain. </returns>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EfElementValidity">
            <summary>
            Entity Framework element's validity regarding file changes on its parts (isn't affected by resolve status)
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.QueryTrackingBehavior">
            <summary>
            Identical to Microsoft.EntityFrameworkCore.QueryTrackingBehavior
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EfModelUtils.CompareModelSources(JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EfModelSource,JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EfModelSource)">
            <returns> 1 if <see cref="!:firstSource"/> is of higher priority than <see cref="!:secondSource"/>,
            -1 if <see cref="!:secondSource"/> if of higher priority than <see cref="!:firstSource"/>, 0 otherwise. </returns>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkModelCache.myEntitiesCache">
            <summary>
            Key is the substitution-less string representation of the entity's <see cref="T:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.IEfSerializedType"/>
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkModelCache.myDestinationToNavigationsMap">
            <summary>
            Key is the ID of Target entity for each navigation
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkModelCache.myBaseElementsToDescendantsMap">
            <summary>
            Key is the ID of base element
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkModelCache.AnalyzePotentialDbContext(JetBrains.ReSharper.Psi.ITypeElement,JetBrains.ReSharper.Psi.ITypeElement,JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkVersion,JetBrains.ReSharper.Psi.IPsiSourceFile,JetBrains.ReSharper.Psi.Dependencies.DependencyStore,System.Collections.Generic.ISet{JetBrains.ReSharper.Psi.ITypeElement})">
            <param name="typeElement"> TypeElement to check if it can be a DbContext descendant </param>
            <param name="baseDbContextTypeElement"> Base DbContext type to check against </param>
            <param name="entityFrameworkVersion"> Entity Framework version </param>
            <param name="psiSourceFile"> File with DbContext object usage </param>
            <param name="dependencyStore"> Dependency Store for SWA </param>
            <param name="dbContextsCache"> Set of <see cref="T:JetBrains.ReSharper.Psi.ITypeElement"/> which are known to be valid DbContexts </param>
            <returns> DbContext <see cref="T:JetBrains.ReSharper.Psi.ITypeElement"/> if found and analyzed successfully </returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkModelCache.EnsureModelUpToDate(JetBrains.ReSharper.Psi.ITypeElement,JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkVersion,JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkModelId)">
            <summary> Call this method to update a specific Entity Framework model with any changes which occurred after
            the previous update if necessary. </summary>
            <returns> Returns false if model could not be updated </returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkModelCache.TryGetCachedElementsFromFile(JetBrains.ReSharper.Psi.IPsiSourceFile,JetBrains.Util.OneToListMap{System.String,JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.IEntityFrameworkCacheableElement}@)">
            <param name="psiSourceFile"> File containing cached elements </param>
            <param name="cachedDeclarations"> FQN : [list of cached elements] </param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkModelCache.GetMatchingDbSetName(JetBrains.ReSharper.Psi.IType,JetBrains.ReSharper.Psi.IType,JetBrains.ReSharper.Psi.ITypeElement,JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkVersion,System.Boolean)">
            <summary>
            You must ensure that cache is up-to-date for <see cref="!:dbContext"/> if <see cref="!:ensureModelUpToDate"/>
            is set to false.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkModelCache.GetMatchingNavigation(JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.NavigationQueryData,System.Boolean)">
            <summary>
            You must ensure that cache is up-to-date for DbContext if <see cref="!:ensureModelUpToDate"/> is set to false.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkModelCache.GetDbContextsDbFunctions(System.Collections.Generic.IEnumerable{JetBrains.ReSharper.Psi.ITypeElement},JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkVersion,System.Boolean)">
            <summary>
            You must ensure that cache is up-to-date for DbContexts if <see cref="!:ensureModelUpToDate"/> is set to false.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkModelCache.TrackFilesWithCachedElement(System.Collections.Generic.IEnumerable{JetBrains.ReSharper.Psi.IPsiSourceFile},JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkElementId)">
            <summary>
            Must be called under write lock
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkModelCache.BuildAll(JetBrains.ReSharper.Psi.ITypeElement,JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkVersion)">
            <summary>
            Must be called under WriteLock
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkModelCache.BuildConfiguration(JetBrains.ReSharper.Psi.ITypeElement,JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkModelId,JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkVersion,System.Collections.Generic.IList{JetBrains.ReSharper.Psi.ITypeElement})">
            <summary>
            Must be called under WriteLock
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkModelCache.TryInvalidateCachedElement(JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.IEntityFrameworkCacheableElement)">
            <summary> Must be called under write lock </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkModelCache.TryInvalidateCachedElement(JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkElementId)">
            <summary>Must be called under write lock.</summary>
            <param name="id">ID of the invalidated element.</param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkModelCache.InvalidateModel(JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkModelConfigReader)">
            <summary> Must be called under write lock </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkModelCache.InvalidateEntity(JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkEntityConfigReader)">
            <summary> Must be called under write lock </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkModelCache.InvalidateDescendants(JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkElementId)">
            <summary> Must be called under write lock </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkModelCache.TryRemoveCachedElement(JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkElementId,System.Boolean)">
            <summary> Must be called under write lock </summary>
            <param name="id"> ID of the removed element </param>
            <param name="isRecursiveCall"> True if this method is called recursively </param>
            <returns> Whether the element was successfully removed </returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkModelCache.LockSafeExecutable`1.Execute">
            Do not use this directly, instead use <see cref="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkModelCache.ExecuteLockSafeExecutable``1(JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkModelCache.LockSafeExecutable{``0})"/>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkModelConfigReader.DbFunctions">
            <summary>
            Set of DbFunctions declared with FluentAPI only!
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkPropertyConfigReader.UpdateMaxLength(System.Int32,JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EfModelSource,System.Boolean)">
            <param name="maxLength"> Values lower than -1 are not allowed </param>
            <param name="source"></param>
            <param name="isFromDataType"></param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkUtils.GetILazyLoaderClrNameCore">
            <summary>
            Entity Framework Core only
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkUtils.GetProxyCreationEnabledPropertyClrName">
            <summary>
            Entity Framework only
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkUtils.GetIEntityConfigurationClrNameCore">
            <summary>
            Entity Framework Core only
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkUtils.GetEntityTypeConfigurationClrName">
            <summary>
            Entity Framework only
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkUtils.GetComplexTypeConfigurationClrName">
            <summary>
            Entity Framework only
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkUtils.GetConfigurationRegistrarClrName">
            <summary>
            Entity Framework only
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkUtils.GetTypeFromTypeParameterType(JetBrains.ReSharper.Psi.IType,JetBrains.ReSharper.Psi.ITypeElement)">
            <returns>Returns original type if it is not a type parameter type. Returns resolved type if substitution is
            resolved successfully. Returns null otherwise.</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkUtils.FindDbContexts(JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkVersion,JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkModelCache,JetBrains.ReSharper.Psi.Dependencies.DependencyStore)">
            <summary>
            Use this method to get DbContexts from <see cref="!:treeNode"/> descendants and update
            <see cref="!:entityFrameworkModelCache"/> and <see cref="!:dependencyStore"/> if DbContexts are found.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.UsedEntityRelation.CanBeIgnored">
            <summary>
            Specifies whether this relation should be ignored during Entity Framework query analysis.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.UsedEntityRelation.AlreadyExistsInQuery">
            <summary>
            Specifies whether this relation will be replicated in the query and cannot lead to problems like N+1.
            </summary>
            <example>"Accounts" in <code>context.People.SelectMany(p => p.Accounts)</code></example>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.UsedEntityRelation.IsAutoIncludedInFluentApi">
            <summary>
            Specifies whether this relation can be automatically included based on FluentAPI configuration. Whether or not
            this relation will actually be included is dependent on other information as well.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkQueryInspector.InspectionData.HasComplexityOverflow">
            <summary>
            Inspector will switch to optimistic mode for the current block of code after encountering complexity overflow.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.NavigationQueryData.ContainingType">
            <summary>
            Can be an entity type or DbContext type
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.NavigationQueryData.PropertyName">
            <summary>
            Potential navigational property
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.NavigationQueryData.DbContext">
            <summary>
            DbContext which contains the navigation
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.NavigationQueryData.OverridableMember">
            <summary>
            Property type member
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.NavigationQueryResult.CanBeIgnored">
            <summary>
            Specifies whether this relation should be ignored during Entity Framework query analysis.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.PreConventionData.MaxLength">
            <summary>
            Value of -1 signifies maximum allowed or unlimited length.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.RelationsChain.#ctor(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression,JetBrains.ReSharper.Psi.IType,System.String,JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkContext.Variable,JetBrains.ReSharper.Psi.ITypeElement,JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityRelationsLoadedTree)">
            <summary>
            Start new chain from scratch
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.RelationsChain.#ctor(JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.RelationsChain,JetBrains.ReSharper.Psi.IType,JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression,System.Boolean,JetBrains.ReSharper.Psi.PredefinedType)">
            <summary>
            Creates chain from another considering the original variable
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.RelationsChain.#ctor(JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.RelationsChain,System.Boolean)">
            <summary>
            Creates deep or shallow clone
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.RelationsChain.#ctor(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression,System.String,JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkContext.Variable,JetBrains.ReSharper.Psi.IType,JetBrains.ReSharper.Psi.ITypeElement)">
            <summary>
            Start chain with DbContext Configuration
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.InitialContextBuilder">
            <summary>
            Builder of the control flow initial state (i.t. the context of the graph entry point)
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.IntValuesAnalysis.AbstractValue.Builder.ToLongIntervals">
            <returns>Sorted set of disjoint <c>LongInterval</c>s</returns>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.MemorySnapshotHive">
            <summary>
            Set of the possible memory snapshots
            This class is immutable! (i.e. any modification makes new copy of the class)
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.MemorySnapshotHive.SplitByNullCondition(System.Int32,System.Boolean,JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.MemorySnapshotHive@,JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.MemorySnapshotHive@)">
            note: 'optimistic' - do not inject 'null' state if variable is weak
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.NullableAnalysis.CSharpCompilerNullableInspector.VariableSlot(JetBrains.ReSharper.Psi.IDeclaredElement,JetBrains.ReSharper.Psi.Resolve.ISubstitution,System.Int32)">
            <summary>
            Locals are given slots when their declarations are encountered.  We only need give slots
            to local variables, out parameters, and the "this" variable of a struct constructs.
            Other variables are not given slots, and are therefore not tracked by the analysis.  This
            returns -1 for a variable that is not tracked, for fields of structs that have the same
            assigned status as the container, and for structs that (recursively) contain no data members.
            We do not need to track references to
            variables that occur before the variable is declared, as those are reported in an
            earlier phase as "use before declaration". That allows us to avoid giving slots to local
            variables before processing their declarations.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.NullableAnalysis.CSharpCompilerNullableInspector.IsSlotMember(System.Int32,JetBrains.ReSharper.Psi.IDeclaredElement,JetBrains.ReSharper.Psi.Resolve.ISubstitution)">
            will be required if Roslyn team will refuse to fix this: https://github.com/dotnet/roslyn/issues/47892
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.NullableAnalysis.VariableIdentifier.DefaultRValueAnnotation">
            <summary>
            Default RValue state of the current variable e.g. when the variable encountered for the first time without any prior checks or assignments
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.NullableAnalysis.VariableIdentifier.DefaultRValueValueAnnotation">
            <summary>
            The result of GetValueNullableAnnotation() on this variable's type with 'DefaultRValueAnnotation' nullability
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.VariableIndex.This">
            <summary>
            'this' struct variable info for instance struct ctor
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.VariableIndex.CountVariablesForAccessStateAnalysis">
            <summary>
            Get number of variables in index
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.VariableIndex.AddVariable(JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.VariableInfo,System.Boolean,System.Boolean)">
            <summary>Add new variable into index</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.VariableIndex.AddType(JetBrains.ReSharper.Psi.IType)">
            <summary>
            Add type to registered types index
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.VariableIndex.GetTypeIndex(JetBrains.ReSharper.Psi.IType)">
            <summary>
            Get the index of the given type, or -1 if type is not registered
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.VariableIndex.GetTypeByIndex(System.Int32)">
            <summary>
            Get the index of the given type, or -1 if type is not registered
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.VariableIndex.TotalTypes">
            <summary>
            Get the total number of registered types
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.VariableIndex.GetHistoryCheckPoint(JetBrains.ReSharper.Psi.ControlFlow.IControlFlowElement)">
            <summary>
            Check if history check point is associated with given element, and returns it
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.VariableIndex.GetInvalidatedHistoryCheckPoints(JetBrains.ReSharper.Psi.ControlFlow.IControlFlowElement,JetBrains.ReSharper.Psi.ControlFlow.IControlFlowElement)">
            <summary>
            Enumerate history check points which runs out of scope when control flow moves from <paramref name="from"/> to <paramref name="to"/>
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.VariableIndex.FindLocalOrClosureVariable(JetBrains.ReSharper.Psi.IDeclaredElement)">
            <summary>
            Find info by declared element - only for top-level elements
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.VariableIndex.FindVariableFromAnotherContext(JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.VariableInfo)">
            <summary>
            Finds variable by its and its parents' declared elements. Returned info may have different state e.g. AccessStateIndex
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.VariableIndex.HasInQualifier(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression)">
            <summary>
            Search for unchecked infos, where given expr is found in qualifier (cache results)
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.VariableIndex.HasInQualifier(JetBrains.ReSharper.Psi.IDeclaredElement)">
            <summary>
            Search for unchecked infos, where given local variable or parameter is found in qualifier (cache results)
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.VariableIndex.Find(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression,JetBrains.ReSharper.Psi.Resolve.Managed.IResolveContext)">
            <summary>
            Find info by expression - look into unchecked variables, and into fields of managed variable (cache results)
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.CSharpImplUtil.ContainsYieldStatement(JetBrains.ReSharper.Psi.CSharp.Tree.IBlock)">
            <summary>
            According to C# specs 22.1, function body block is iterator if it contains one or more 'yield' statements.
            This method do not expands chameleon nodes if possible.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.CSharpReferenceBindingUtil.GetRequiredExternAlias(JetBrains.ReSharper.Psi.Modules.IPsiModule,JetBrains.ReSharper.Psi.IClrDeclaredElement)">
            <summary>Get the required extern alias</summary>
            <returns><c>null</c> if module is not referenced, <c>String.Empty</c> for no alias (i.e. == global)</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.CSharpReferenceBindingUtil.GetPossibleExternAliases(JetBrains.ReSharper.Psi.Modules.IPsiModule,JetBrains.ReSharper.Psi.IClrDeclaredElement)">
            <summary>Get the possible extern aliases list</summary>
            <returns><c>null</c> if module is not referenced, <c>String.Empty</c> for no alias (i.e. == global)</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.CSharpReferenceBindingUtil.UseExistingAlias(JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.IQualifiableReference,System.Func{JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.IQualifiableReference,System.Boolean})">
            <summary>
            Try to replaced qualified reference by any existing alias
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.CSharpReferenceBindingUtil.ExtractQualifierReference(JetBrains.ReSharper.Psi.Resolve.IReference)">
            <summary>
            Try to extract the qualifier reference of the given reference' element
            i.e. extract reference to B from reference to C in expression A.B.C
            </summary>
            <param name="reference"></param>
            <returns>null if reference could not be extracted</returns>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Impl.CSharpReferenceProviderFactory.ComponentNameReference">
            <summary>Reference to component name in WinForm generated code</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.CSharpReferenceProviderFactory.ComponentNameReference.#ctor(JetBrains.ReSharper.Psi.CSharp.Tree.IAssignmentExpression)">
            <summary>Reference to component name in WinForm generated code</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.CSharpTypeBindingUtil.BindTypeUsageToType(JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage,JetBrains.ReSharper.Psi.IType)">
            <summary>
            Performs binding of type usage node to a specified type.
            Binding result isn't guaranteed to be a type usage
            (e.g. containing object creation expression can be converted into a tuple expression).
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.CSharpTypeBindingUtil.BindSymbolAliasReferenceToType(JetBrains.ReSharper.Psi.Resolve.IReference,JetBrains.ReSharper.Psi.IType)">
            <summary>
            Binds symbol alias reference to the specified aliased type.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.CustomHandlers.ICSharpCustomModificationHandler.HandleAddStatementsRange(JetBrains.ReSharper.Psi.IPsiServices,System.Func{JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.CSharp.ICSharpStatementsRange},JetBrains.ReSharper.Psi.CSharp.Tree.IStatementsOwner,JetBrains.ReSharper.Psi.Tree.ITreeNode,System.Boolean,System.Boolean)">
            <summary>
            Translates changes in generated code-behind file to original file (Razor, ASP, etc).
            If strict, HTML whitespace statements on bounds are not included. Use for single added statement to be returned.
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Impl.DeclaredElement.CSharpByIndexIndexer">
            <summary>
            Scalar indexer by 'System.Index' type, e.g. 'array[^1]'
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Impl.DeclaredElement.CSharpByRangeIndexer">
            <summary>
            Slice indexer by 'System.Range' type, e.g. 'array[0..5]'
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Impl.DeclaredElement.CSharpGlobalUsingAlias">
            <summary>
            Represents a global symbol alias stored in a <see cref="T:JetBrains.ReSharper.Psi.CSharp.Caches.GlobalUsingsCache"/>.
            Does not itself implement <see cref="T:JetBrains.ReSharper.Psi.CSharp.DeclaredElements.ISymbolAlias"/> APIs like <see cref="P:JetBrains.ReSharper.Psi.CSharp.Impl.DeclaredElement.CSharpGlobalUsingAlias.AliasedSymbol"/>.
            Each global <see cref="T:JetBrains.ReSharper.Psi.CSharp.Tree.IUsingAliasDirective"/> has <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/> created via <see cref="M:JetBrains.ReSharper.Psi.CSharp.Impl.DeclaredElement.CSharpGlobalUsingAlias.CreateInstance(JetBrains.ReSharper.Psi.CSharp.Impl.Tree.UsingAliasDirective)"/> method.
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Impl.DeclaredElement.CSharpGlobalUsingAlias.GlobalSymbolAliasInstance">
            <summary>
            Represents an instance of a global using alias.
            Uses a <see cref="T:JetBrains.ReSharper.Psi.CSharp.Tree.IUsingAliasDirective"/> to implement <see cref="P:JetBrains.ReSharper.Psi.CSharp.Impl.DeclaredElement.CSharpGlobalUsingAlias.GlobalSymbolAliasInstance.AliasedSymbol"/> and other <see cref="T:JetBrains.ReSharper.Psi.CSharp.DeclaredElements.ISymbolAlias"/> specific members.
            Uses a <see cref="T:JetBrains.ReSharper.Psi.CSharp.Impl.DeclaredElement.CSharpGlobalUsingAlias"/> to get declarations.
            Uses <see cref="T:JetBrains.ReSharper.Psi.CSharp.Impl.DeclaredElement.CSharpGlobalUsingAlias.SymbolAliasComparer"/> for equality with an underlying <see cref="T:JetBrains.ReSharper.Psi.CSharp.Impl.DeclaredElement.CSharpGlobalUsingAlias"/>.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.DeclaredElement.CSharpPartialOverrideableMember`1.GetSignature(JetBrains.ReSharper.Psi.Resolve.ISubstitution)">
            <inheritdoc cref="M:JetBrains.ReSharper.Psi.IParametersOwner.GetSignature(JetBrains.ReSharper.Psi.Resolve.ISubstitution)"/>
            <remarks>Effectively implements method for <c>IParametersOwner</c></remarks>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.DeclaredElement.CSharpTypeParameterOfMethod.FindInheritedTypeParameter">
            <summary>
            Tries to find the type parameter of the inherited method.
            According to C# specs 25.6.2
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Impl.DefaultConstructorInCollectionExpressionSearcher">
            <summary>
            Performs search of default constructors implicitly used in collection expressions.
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Impl.IImplicitConversionSearcherProvider">
            <summary>
            Provides implicit conversions found inside a tree node
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.IImplicitConversionSearcherProvider.GetImplicitConversions(JetBrains.ReSharper.Psi.Tree.ITreeNode,System.Boolean,System.Boolean)">
            <param name="treeNode">Root node from which searching is started</param>
            <param name="onlyUserDefinedConversions">Indicates whether searching should process only user defined conversions</param>
            <param name="processInnerTreeNodes">Indicates whether inner nodes should be processed recursively</param>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Impl.ImplicitConstructorUsageSearcherBase">
            <summary>
            Provides base implementation for searching of implicitly used constructors.
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Impl.ImplicitConversionSourceInfo">
            <summary>
              Represents information about a conversion and about the place where it has been found.  
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Impl.MembersReferencedInCollectionExpressionSearcher">
            <summary>
            Performs search of members referenced in collection expression and its elements.
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Impl.ModifiersOrderFixer">
            <summary>
            When a modifiers order in settings is incomplete or invalid, we need to
            complete it with missing items and remove the wrong one.
            Doing so every time is expensive. So we need to cache the results.
            This is what this component does.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ModifiersUtil.GetAccessRightsWithValidation(JetBrains.ReSharper.Psi.CSharp.Tree.IModifiersList)">
            <summary>
            Determines explicitly defined access rights in modifiers list.
            Ensures there is no access modifier conflicts and each access modifier is mentioned once.
            </summary>
            <remarks>Use when needs to detect broken/uncompleted code.</remarks>
            <param name="modifiersList">A collection of modifiers.</param>
            <returns>The calculated syntactically defined access rights if specified correctly or undefined at all; otherwise, null.</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.MultipleDeclarationUtil.ExtractDeclaration(JetBrains.ReSharper.Psi.CSharp.Tree.IMultipleDeclarationMember)">
            <summary>
            Extract single declaration from multiple declaration node, if necessary.
            All declarations are not invalidated
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.MultipleDeclarationUtil.SplitDeclarationBefore(JetBrains.ReSharper.Psi.CSharp.Tree.IMultipleDeclarationMember)">
            <summary>
            Split the multiple declaration list so that given member will be the first declaration in the list.
            All declarations are not invalidated
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.MultipleDeclarationUtil.SplitDeclarationAfter(JetBrains.ReSharper.Psi.CSharp.Tree.IMultipleDeclarationMember)">
            <summary>
            Split the multiple declaration list so that given member will be the last declaration in the list.
            All declarations are not invalidated
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.MultipleDeclarationUtil.RemoveDeclaration(JetBrains.ReSharper.Psi.CSharp.Tree.IMultipleDeclarationMember)">
            <summary>
            Delete the given member declaration from the multiple declaration
            If the member is the single in the multiple node, then delete whole multiple node
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.ParenthesesUtil.CanUseAssociativityToRemoveParentheses(JetBrains.ReSharper.Psi.CSharp.Tree.IParenthesizedExpression)">
            <summary>
            Check if we can omit parentheses in situations like '1 + (2 + 3)' or '"aa" + ("bb" + "cc")'
            when we can proof binary operator is associative.
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Impl.ReSharperSettingsCSharpLanguageLevel">
            <summary>
            ReSharper's own language level. Is used to override auto-detected project language level.
            </summary>
            <remarks>
            This enum differs from <see cref="T:JetBrains.ReSharper.Psi.CSharp.CSharpLanguageLevel"/>:
            * has <see cref="F:JetBrains.ReSharper.Psi.CSharp.Impl.ReSharperSettingsCSharpLanguageLevel.Default"/> member meaning language level is not overridden in ReSharper settings
            </remarks>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.CSharpOperatorResolver.GetApplicableOperatorsInType(System.String,System.Collections.Generic.HashSet{JetBrains.ReSharper.Psi.IDeclaredType},System.Collections.Generic.HashSet{JetBrains.ReSharper.Psi.IDeclaredType},System.Collections.Generic.HashSet{JetBrains.ReSharper.Psi.IClass},JetBrains.ReSharper.Psi.IType,System.Boolean,System.Collections.Generic.IList{JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.CandidateWithResolveContext}@)">
            Parameter 'visited' is needed for optimization in case of getting tables for not unary operator arguments
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.CSharpResolveUtil.CSharpAliasDirectiveSymbolTable.GetAliasSymbolInfos(JetBrains.ReSharper.Psi.CSharp.Tree.IUsingAliasDirective)">
            <summary>
            Gets symbols for the specified using alias directive.
            </summary>
            <remarks>
            If alias reference to a namespace or a regular declared type <see cref="P:JetBrains.ReSharper.Psi.CSharp.DeclaredElements.ISymbolAlias.IsNamespaceOrRegularDeclaredTypeAlias"/>
            then symbol table should include not only symbol for a symbol alias itself but also a symbol for the aliased type or namespace,
            because such aliases are transparent and their usages are resolved directly to the aliased namespace or type.
            </remarks>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.CSharpResolveUtil.ShouldApplyEmbeddedComInteropTypeRule(JetBrains.ReSharper.Psi.ITypeMember,System.Func{JetBrains.ReSharper.Psi.Modules.IPsiModule})">
            <summary>
            When using COM interop type members with "Embed Interop Types" property, return values of methods, properties and indexers are 'dynamic' instead of 'object'
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.CSharpResolveUtil.ShouldApplyEmbeddedComInteropTypeRule(JetBrains.ReSharper.Psi.Resolve.IResolveResult,System.Func{JetBrains.ReSharper.Psi.Modules.IPsiModule})">
            <summary>
            When using COM interop type members with "Embed Interop Types" property, return values of methods, properties and indexers are 'dynamic' instead of 'object'
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.EnumInitializerFilter">
            <summary>
            Prefers enum member in enum initializer
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.EnumInitializerFilter.#ctor(JetBrains.ReSharper.Psi.IEnum)">
            <summary>
            Prefers enum member in enum initializer
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.EventOrBackingFieldFilter">
            <summary>
            Special filter for DotPeek.
            Disambiguate between event and it's private backing field
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.EventOrBackingFieldFilter.#ctor(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression)">
            <summary>
            Special filter for DotPeek.
            Disambiguate between event and it's private backing field
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.MethodAmbiguityFilter">
            <summary>
            If there are methods and non-method symbols, it leaves only methods.
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.UseLocalVariableBeforeDeclarationFilter">
            <summary>
            Filter local variable declarations by their position in the tree
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.UseLocalVariableBeforeDeclarationFilter.#ctor(JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Filter local variable declarations by their position in the tree
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Invocation.CheckForArrayLength(System.String,JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.ResolveResultWithInfo@)">
            <summary>
            Workaround for compiler bug existed in C# 3.0.
            See https://connect.microsoft.com/VisualStudio/feedback/details/328765/cannot-invoke-extension-method-named-length-on-an-array
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Impl.TypeAliasBindingService">
            <summary>
            Modification service performing binding of unresolved type usages refering to a type alias.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.CSharpTypeConversionRule.ImplicitReferenceConversionExist(JetBrains.ReSharper.Psi.IType,JetBrains.ReSharper.Psi.IType)">
            <summary>
            C# 2.0 spec 13.1.4
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.CSharpTypeConversionRule.GetCustomImplicitOperator(JetBrains.ReSharper.Psi.IExpressionType,JetBrains.ReSharper.Psi.IType,JetBrains.ReSharper.Psi.IType)">
            <summary>
            Find custom implicit operator according to paragraph 6.4.3
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Impl.DeclaredTypeFromReferenceName">
            <summary>
            NOTE: Do not hold IReferenceName
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.UsingUtil.GetUsingOf(JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.IQualifiableReference)">
            <summary>
            Get the corresponding using directive (if any) which is used to import references' target
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Impl.UsingUtil.GetImportConflicts``1(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeAndNamespaceHolderDeclaration,JetBrains.ReSharper.Psi.DeclaredElementInstance,System.String,JetBrains.Util.Key{JetBrains.ReSharper.Psi.DeclaredElementInstance},``0,System.Action{``0})">
            <summary>
            Builds the list of conflicts which will occur if the given namespace will be imported into given scope.
            References with existing value in UserData by the given key will not be included
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons">
             <summary>
            	<para>
            		<para>Autogenerated identifier classes and identifier objects to Themed Icons registered with <see cref="T:JetBrains.Application.Icons.IThemedIconManager"></see>.</para>
            		<para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"></see> value is expected, use the identifier object in the <c>Id</c> field of the identifier class.</para>
            	</para>
            </summary>
            <remarks>
            	<para>This code was compile-time generated to support Themed Icons in the JetBrains application.</para>
            	<para>It has two primary goals: load the icons of this assembly to be registered with <see cref="T:JetBrains.Application.Icons.IThemedIconManager"></see> so that they were WPF-accessible and theme-sensitive; and emit early-bound accessors for referencing icons in codebehind in a compile-time-validated manner.</para>
            	<h1>XAML</h1>
            	<para>For performance reasons, the icons are not individually exposed with application resources. There is a custom markup extension to bind an image source in markup.</para>
            	<para>To use an icon from XAML, set an <see cref="T:System.Windows.Media.ImageSource"></see> property to the <see cref="T:System.CodeDom.CodeTypeReference"></see> markup extension, which takes an icon identifier class (nested in <see cref="T:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons"></see> class) as a parameter.</para>
            	<para>Example:</para>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:PsiCSharpThemedIcons+Trinity}" /&gt;</code>
            	<h1>Attributes</h1>
            	<para>Sometimes you have to reference an icon from a type attriute when you're defining objects in code. Typical examples are Options pages and Tool Windows.</para>
            	<para>To avoid the use of string IDs which are not validated very well, we've emitted identifier classes to be used with <c>typeof()</c> expression, one per each icon. Use the attribute overload which takes a <see cref="T:System.Type"></see> for an image, and choose your icon class from nested classes in the <see cref="T:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons"></see> class.</para>
            	<para>Example:</para>
            	<code>[Item(Name="Sample", Icon=typeof(PsiCSharpThemedIcons.Trinity))]</code>
            	<h1>CodeBehind</h1>
            	<para>In codebehind, we have two distinct tasks: (a) specify some icon in the APIs and (b) render icon images onscreen.</para>
            	<para>On the APIs stage you should only manipulate icon identifier objects (of type <see cref="T:JetBrains.UI.Icons.IconId"></see>, statically defined in <see cref="T:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons"></see> in <c>Id</c> fields). Icon identifier classes (nested in <see cref="T:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons"></see>) should be turned into icon identifier objects as early as possible. Rendering is about getting an <see cref="T:System.Windows.Media.ImageSource"></see> to assign to WPF, or <see cref="T:System.Drawing.Bitmap"></see> to use with GDI+ / Windows Forms.</para>
            	<para>You should turn an identifier object into a rendered image as late as possible. The identifier is static and lightweight and does not depend on the current theme, while the image is themed and has to be loaded or generated/rasterized. You need an <see cref="T:JetBrains.Application.Icons.IThemedIconManager"></see> instance to get the image out of an icon identifier object. Once you got the image, you should take care to change it with theme changes — either by using a live image property, or by listening to the theme change event. See <see cref="T:JetBrains.Application.Icons.IThemedIconManager"></see> and its extensions for the related facilities.</para>
            	<para>Example:</para>
            	<code>// Getting IconId identifier object to use with APIs
            IconId iconid = PsiCSharpThemedIcons.Trinity.Id;</code>
            	<code>// Getting IconId out of an Icon Identifier Class type
            IconId iconid = new JetBrains.Application.Icons.CompiledIconsCs.CompiledIconCsId(typeof(PsiCSharpThemedIcons.Trinity));</code>
            	<code>// Getting image for screen rendering by IconId
            themediconmanager.Icons[icnoid]</code>
            	<code>// Getting image for screen rendering by Icon Identifier Class
            themediconmanager.GetIcon&lt;PsiCSharpThemedIcons.Trinity&gt;()</code>
            	<h1>Icons Origin</h1>
            	<para>This code was generated by a pre-compile build task from a set of input files which are XAML files adhering to a certain convention, as convenient for exporting them from the Illustrator workspace, plus separate PNG files with raster icons. In the projects, these files are designated with <c>ThemedIconsXamlV3</c> and <c>ThemedIconPng</c> build actions and do not themselves get into the output assembly. All of such files are processed, vector images for different themes of the same icon are split and combined into the single list of icons in this assembly. This list is then written into the genearted XAML file (compiled into BAML within assembly), and serves as the source for this generated code.</para>
            </remarks>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp">
             <summary>
            	<para>
            		<para>Csharp Themed Icon generated identifiers:</para>
            		<para>— <see cref="T:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp"></see> identifier class, for use in attributes, XAML, and generic parameters;</para>
            		<para>— <see cref="F:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp.Id"></see> identifier object, as a field in the identifier class, for use where an <see cref="T:JetBrains.UI.Icons.IconId"></see> value is expected.</para>
            		<para>
            			<code>
                                             
                 33333333333333I/`           
                 uu''''''''''''^su/`         
                 oo--------------~Jo*`       
                 55----        ----~l2+`     
                 aa----        ------~ta+    
                 SS----            ----SS    
                 kk----            ----kk    
                 kk----            ----kk    
              `!xOmmmmmmmmmmmmmmm  ----PP    
             -Ek!_```bbbb``bb``bbbb----UU    
             }6,`^26666``````````66----66    
             EE``1EEEEEEE``EE``EEEE----99    
             Jy_.=eyyyy..........yy----ww    
             _Il~_---oooo--oo--oooobbbbbb    
              `;7x111111111111111            
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:PsiCSharpThemedIcons+Csharp}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(PsiCSharpThemedIcons.Csharp))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = PsiCSharpThemedIcons.Csharp.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;PsiCSharpThemedIcons.Csharp&gt;()        // Icon image for rendering</code>
            </example>
             <summary>
            	<para>
            		<para>Csharp Themed Icon generated identifiers:</para>
            		<para>— <see cref = "T:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp"></see> identifier class, for use in attributes, XAML, and generic parameters;</para>
            		<para>— <see cref = "F:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp.Id"></see> identifier object, as a field in the identifier class, for use where an <see cref = "T:JetBrains.UI.Icons.IconId"></see> value is expected.</para>
            		<para>
            			<code>
                                             
                 33333333333333I/`           
                 uu''''''''''''^su/`         
                 oo--------------~Jo*`       
                 55----        ----~l2+`     
                 aa----        ------~ta+    
                 SS----            ----SS    
                 kk----            ----kk    
                 kk----            ----kk    
              `!xOmmmmmmmmmmmmmmm  ----PP    
             -Ek!_```bbbb``bb``bbbb----UU    
             }6,`^26666``````````66----66    
             EE``1EEEEEEE``EE``EEEE----99    
             Jy_.=eyyyy..........yy----ww    
             _Il~_---oooo--oo--oooobbbbbb    
              `;7x111111111111111            
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:PsiCSharpThemedIcons+Csharp}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(PsiCSharpThemedIcons.Csharp))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = PsiCSharpThemedIcons.Csharp.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;PsiCSharpThemedIcons.Csharp&gt;()        // Icon image for rendering</code>
            </example>
             <summary>
            	<para>
            		<para>Csharp Themed Icon generated identifiers:</para>
            		<para>— <see cref = "T:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp"></see> identifier class, for use in attributes, XAML, and generic parameters;</para>
            		<para>— <see cref = "F:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp.Id"></see> identifier object, as a field in the identifier class, for use where an <see cref = "T:JetBrains.UI.Icons.IconId"></see> value is expected.</para>
            		<para>
            			<code>
                                             
                 33333333333333I/`           
                 uu''''''''''''^su/`         
                 oo--------------~Jo*`       
                 55----        ----~l2+`     
                 aa----        ------~ta+    
                 SS----            ----SS    
                 kk----            ----kk    
                 kk----            ----kk    
              `!xOmmmmmmmmmmmmmmm  ----PP    
             -Ek!_```bbbb``bb``bbbb----UU    
             }6,`^26666``````````66----66    
             EE``1EEEEEEE``EE``EEEE----99    
             Jy_.=eyyyy..........yy----ww    
             _Il~_---oooo--oo--oooobbbbbb    
              `;7x111111111111111            
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:PsiCSharpThemedIcons+Csharp}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(PsiCSharpThemedIcons.Csharp))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = PsiCSharpThemedIcons.Csharp.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;PsiCSharpThemedIcons.Csharp&gt;()        // Icon image for rendering</code>
            </example>
             <summary>
            	<para>
            		<para>Csharp Themed Icon generated identifiers:</para>
            		<para>— <see cref = "T:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp"></see> identifier class, for use in attributes, XAML, and generic parameters;</para>
            		<para>— <see cref = "F:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp.Id"></see> identifier object, as a field in the identifier class, for use where an <see cref = "T:JetBrains.UI.Icons.IconId"></see> value is expected.</para>
            		<para>
            			<code>
                                             
                 33333333333333I/`           
                 uu''''''''''''^su/`         
                 oo--------------~Jo*`       
                 55----        ----~l2+`     
                 aa----        ------~ta+    
                 SS----            ----SS    
                 kk----            ----kk    
                 kk----            ----kk    
              `!xOmmmmmmmmmmmmmmm  ----PP    
             -Ek!_```bbbb``bb``bbbb----UU    
             }6,`^26666``````````66----66    
             EE``1EEEEEEE``EE``EEEE----99    
             Jy_.=eyyyy..........yy----ww    
             _Il~_---oooo--oo--oooobbbbbb    
              `;7x111111111111111            
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:PsiCSharpThemedIcons+Csharp}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(PsiCSharpThemedIcons.Csharp))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = PsiCSharpThemedIcons.Csharp.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;PsiCSharpThemedIcons.Csharp&gt;()        // Icon image for rendering</code>
            </example>
             <summary>
            	<para>
            		<para>Csharp Themed Icon generated identifiers:</para>
            		<para>— <see cref = "T:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp"></see> identifier class, for use in attributes, XAML, and generic parameters;</para>
            		<para>— <see cref = "F:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp.Id"></see> identifier object, as a field in the identifier class, for use where an <see cref = "T:JetBrains.UI.Icons.IconId"></see> value is expected.</para>
            		<para>
            			<code>
                                             
                 33333333333333I/`           
                 uu''''''''''''^su/`         
                 oo--------------~Jo*`       
                 55----        ----~l2+`     
                 aa----        ------~ta+    
                 SS----            ----SS    
                 kk----            ----kk    
                 kk----            ----kk    
              `!xOmmmmmmmmmmmmmmm  ----PP    
             -Ek!_```bbbb``bb``bbbb----UU    
             }6,`^26666``````````66----66    
             EE``1EEEEEEE``EE``EEEE----99    
             Jy_.=eyyyy..........yy----ww    
             _Il~_---oooo--oo--oooobbbbbb    
              `;7x111111111111111            
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:PsiCSharpThemedIcons+Csharp}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(PsiCSharpThemedIcons.Csharp))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = PsiCSharpThemedIcons.Csharp.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;PsiCSharpThemedIcons.Csharp&gt;()        // Icon image for rendering</code>
            </example>
             <summary>
            	<para>
            		<para>Csharp Themed Icon generated identifiers:</para>
            		<para>— <see cref = "T:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp"></see> identifier class, for use in attributes, XAML, and generic parameters;</para>
            		<para>— <see cref = "F:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp.Id"></see> identifier object, as a field in the identifier class, for use where an <see cref = "T:JetBrains.UI.Icons.IconId"></see> value is expected.</para>
            		<para>
            			<code>
                                             
                 33333333333333I/`           
                 uu''''''''''''^su/`         
                 oo--------------~Jo*`       
                 55----        ----~l2+`     
                 aa----        ------~ta+    
                 SS----            ----SS    
                 kk----            ----kk    
                 kk----            ----kk    
              `!xOmmmmmmmmmmmmmmm  ----PP    
             -Ek!_```bbbb``bb``bbbb----UU    
             }6,`^26666``````````66----66    
             EE``1EEEEEEE``EE``EEEE----99    
             Jy_.=eyyyy..........yy----ww    
             _Il~_---oooo--oo--oooobbbbbb    
              `;7x111111111111111            
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:PsiCSharpThemedIcons+Csharp}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(PsiCSharpThemedIcons.Csharp))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = PsiCSharpThemedIcons.Csharp.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;PsiCSharpThemedIcons.Csharp&gt;()        // Icon image for rendering</code>
            </example>
             <summary>
            	<para>
            		<para>Csharp Themed Icon generated identifiers:</para>
            		<para>— <see cref = "T:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp"></see> identifier class, for use in attributes, XAML, and generic parameters;</para>
            		<para>— <see cref = "F:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp.Id"></see> identifier object, as a field in the identifier class, for use where an <see cref = "T:JetBrains.UI.Icons.IconId"></see> value is expected.</para>
            		<para>
            			<code>
                                             
                 33333333333333I/`           
                 uu''''''''''''^su/`         
                 oo--------------~Jo*`       
                 55----        ----~l2+`     
                 aa----        ------~ta+    
                 SS----            ----SS    
                 kk----            ----kk    
                 kk----            ----kk    
              `!xOmmmmmmmmmmmmmmm  ----PP    
             -Ek!_```bbbb``bb``bbbb----UU    
             }6,`^26666``````````66----66    
             EE``1EEEEEEE``EE``EEEE----99    
             Jy_.=eyyyy..........yy----ww    
             _Il~_---oooo--oo--oooobbbbbb    
              `;7x111111111111111            
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:PsiCSharpThemedIcons+Csharp}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(PsiCSharpThemedIcons.Csharp))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = PsiCSharpThemedIcons.Csharp.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;PsiCSharpThemedIcons.Csharp&gt;()        // Icon image for rendering</code>
            </example>
             <summary>
            	<para>
            		<para>Csharp Themed Icon generated identifiers:</para>
            		<para>— <see cref = "T:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp"></see> identifier class, for use in attributes, XAML, and generic parameters;</para>
            		<para>— <see cref = "F:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp.Id"></see> identifier object, as a field in the identifier class, for use where an <see cref = "T:JetBrains.UI.Icons.IconId"></see> value is expected.</para>
            		<para>
            			<code>
                                             
                 33333333333333I/`           
                 uu''''''''''''^su/`         
                 oo--------------~Jo*`       
                 55----        ----~l2+`     
                 aa----        ------~ta+    
                 SS----            ----SS    
                 kk----            ----kk    
                 kk----            ----kk    
              `!xOmmmmmmmmmmmmmmm  ----PP    
             -Ek!_```bbbb``bb``bbbb----UU    
             }6,`^26666``````````66----66    
             EE``1EEEEEEE``EE``EEEE----99    
             Jy_.=eyyyy..........yy----ww    
             _Il~_---oooo--oo--oooobbbbbb    
              `;7x111111111111111            
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:PsiCSharpThemedIcons+Csharp}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(PsiCSharpThemedIcons.Csharp))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = PsiCSharpThemedIcons.Csharp.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;PsiCSharpThemedIcons.Csharp&gt;()        // Icon image for rendering</code>
            </example>
             <summary>
            	<para>
            		<para>Csharp Themed Icon generated identifiers:</para>
            		<para>— <see cref = "T:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp"></see> identifier class, for use in attributes, XAML, and generic parameters;</para>
            		<para>— <see cref = "F:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp.Id"></see> identifier object, as a field in the identifier class, for use where an <see cref = "T:JetBrains.UI.Icons.IconId"></see> value is expected.</para>
            		<para>
            			<code>
                                             
                 33333333333333I/`           
                 uu''''''''''''^su/`         
                 oo--------------~Jo*`       
                 55----        ----~l2+`     
                 aa----        ------~ta+    
                 SS----            ----SS    
                 kk----            ----kk    
                 kk----            ----kk    
              `!xOmmmmmmmmmmmmmmm  ----PP    
             -Ek!_```bbbb``bb``bbbb----UU    
             }6,`^26666``````````66----66    
             EE``1EEEEEEE``EE``EEEE----99    
             Jy_.=eyyyy..........yy----ww    
             _Il~_---oooo--oo--oooobbbbbb    
              `;7x111111111111111            
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:PsiCSharpThemedIcons+Csharp}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(PsiCSharpThemedIcons.Csharp))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = PsiCSharpThemedIcons.Csharp.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;PsiCSharpThemedIcons.Csharp&gt;()        // Icon image for rendering</code>
            </example>
             <summary>
            	<para>
            		<para>Csharp Themed Icon generated identifiers:</para>
            		<para>— <see cref = "T:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp"></see> identifier class, for use in attributes, XAML, and generic parameters;</para>
            		<para>— <see cref = "F:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp.Id"></see> identifier object, as a field in the identifier class, for use where an <see cref = "T:JetBrains.UI.Icons.IconId"></see> value is expected.</para>
            		<para>
            			<code>
                                             
                 33333333333333I/`           
                 uu''''''''''''^su/`         
                 oo--------------~Jo*`       
                 55----        ----~l2+`     
                 aa----        ------~ta+    
                 SS----            ----SS    
                 kk----            ----kk    
                 kk----            ----kk    
              `!xOmmmmmmmmmmmmmmm  ----PP    
             -Ek!_```bbbb``bb``bbbb----UU    
             }6,`^26666``````````66----66    
             EE``1EEEEEEE``EE``EEEE----99    
             Jy_.=eyyyy..........yy----ww    
             _Il~_---oooo--oo--oooobbbbbb    
              `;7x111111111111111            
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:PsiCSharpThemedIcons+Csharp}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(PsiCSharpThemedIcons.Csharp))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = PsiCSharpThemedIcons.Csharp.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;PsiCSharpThemedIcons.Csharp&gt;()        // Icon image for rendering</code>
            </example>
             <summary>
            	<para>
            		<para>Csharp Themed Icon generated identifiers:</para>
            		<para>— <see cref = "T:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp"></see> identifier class, for use in attributes, XAML, and generic parameters;</para>
            		<para>— <see cref = "F:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp.Id"></see> identifier object, as a field in the identifier class, for use where an <see cref = "T:JetBrains.UI.Icons.IconId"></see> value is expected.</para>
            		<para>
            			<code>
                                             
                 33333333333333I/`           
                 uu''''''''''''^su/`         
                 oo--------------~Jo*`       
                 55----        ----~l2+`     
                 aa----        ------~ta+    
                 SS----            ----SS    
                 kk----            ----kk    
                 kk----            ----kk    
              `!xOmmmmmmmmmmmmmmm  ----PP    
             -Ek!_```bbbb``bb``bbbb----UU    
             }6,`^26666``````````66----66    
             EE``1EEEEEEE``EE``EEEE----99    
             Jy_.=eyyyy..........yy----ww    
             _Il~_---oooo--oo--oooobbbbbb    
              `;7x111111111111111            
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:PsiCSharpThemedIcons+Csharp}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(PsiCSharpThemedIcons.Csharp))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = PsiCSharpThemedIcons.Csharp.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;PsiCSharpThemedIcons.Csharp&gt;()        // Icon image for rendering</code>
            </example>
             <summary>
            	<para>
            		<para>Csharp Themed Icon generated identifiers:</para>
            		<para>— <see cref = "T:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp"></see> identifier class, for use in attributes, XAML, and generic parameters;</para>
            		<para>— <see cref = "F:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp.Id"></see> identifier object, as a field in the identifier class, for use where an <see cref = "T:JetBrains.UI.Icons.IconId"></see> value is expected.</para>
            		<para>
            			<code>
                                             
                 33333333333333I/`           
                 uu''''''''''''^su/`         
                 oo--------------~Jo*`       
                 55----        ----~l2+`     
                 aa----        ------~ta+    
                 SS----            ----SS    
                 kk----            ----kk    
                 kk----            ----kk    
              `!xOmmmmmmmmmmmmmmm  ----PP    
             -Ek!_```bbbb``bb``bbbb----UU    
             }6,`^26666``````````66----66    
             EE``1EEEEEEE``EE``EEEE----99    
             Jy_.=eyyyy..........yy----ww    
             _Il~_---oooo--oo--oooobbbbbb    
              `;7x111111111111111            
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:PsiCSharpThemedIcons+Csharp}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(PsiCSharpThemedIcons.Csharp))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = PsiCSharpThemedIcons.Csharp.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;PsiCSharpThemedIcons.Csharp&gt;()        // Icon image for rendering</code>
            </example>
             <summary>
            	<para>
            		<para>Csharp Themed Icon generated identifiers:</para>
            		<para>— <see cref = "T:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp"></see> identifier class, for use in attributes, XAML, and generic parameters;</para>
            		<para>— <see cref = "F:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp.Id"></see> identifier object, as a field in the identifier class, for use where an <see cref = "T:JetBrains.UI.Icons.IconId"></see> value is expected.</para>
            		<para>
            			<code>
                                             
                 33333333333333I/`           
                 uu''''''''''''^su/`         
                 oo--------------~Jo*`       
                 55----        ----~l2+`     
                 aa----        ------~ta+    
                 SS----            ----SS    
                 kk----            ----kk    
                 kk----            ----kk    
              `!xOmmmmmmmmmmmmmmm  ----PP    
             -Ek!_```bbbb``bb``bbbb----UU    
             }6,`^26666``````````66----66    
             EE``1EEEEEEE``EE``EEEE----99    
             Jy_.=eyyyy..........yy----ww    
             _Il~_---oooo--oo--oooobbbbbb    
              `;7x111111111111111            
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:PsiCSharpThemedIcons+Csharp}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(PsiCSharpThemedIcons.Csharp))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = PsiCSharpThemedIcons.Csharp.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;PsiCSharpThemedIcons.Csharp&gt;()        // Icon image for rendering</code>
            </example>
             <summary>
            	<para>
            		<para>Csharp Themed Icon generated identifiers:</para>
            		<para>— <see cref = "T:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp"></see> identifier class, for use in attributes, XAML, and generic parameters;</para>
            		<para>— <see cref = "F:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp.Id"></see> identifier object, as a field in the identifier class, for use where an <see cref = "T:JetBrains.UI.Icons.IconId"></see> value is expected.</para>
            		<para>
            			<code>
                                             
                 33333333333333I/`           
                 uu''''''''''''^su/`         
                 oo--------------~Jo*`       
                 55----        ----~l2+`     
                 aa----        ------~ta+    
                 SS----            ----SS    
                 kk----            ----kk    
                 kk----            ----kk    
              `!xOmmmmmmmmmmmmmmm  ----PP    
             -Ek!_```bbbb``bb``bbbb----UU    
             }6,`^26666``````````66----66    
             EE``1EEEEEEE``EE``EEEE----99    
             Jy_.=eyyyy..........yy----ww    
             _Il~_---oooo--oo--oooobbbbbb    
              `;7x111111111111111            
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:PsiCSharpThemedIcons+Csharp}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(PsiCSharpThemedIcons.Csharp))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = PsiCSharpThemedIcons.Csharp.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;PsiCSharpThemedIcons.Csharp&gt;()        // Icon image for rendering</code>
            </example>
             <summary>
            	<para>
            		<para>Csharp Themed Icon generated identifiers:</para>
            		<para>— <see cref = "T:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp"></see> identifier class, for use in attributes, XAML, and generic parameters;</para>
            		<para>— <see cref = "F:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp.Id"></see> identifier object, as a field in the identifier class, for use where an <see cref = "T:JetBrains.UI.Icons.IconId"></see> value is expected.</para>
            		<para>
            			<code>
                                             
                 33333333333333I/`           
                 uu''''''''''''^su/`         
                 oo--------------~Jo*`       
                 55----        ----~l2+`     
                 aa----        ------~ta+    
                 SS----            ----SS    
                 kk----            ----kk    
                 kk----            ----kk    
              `!xOmmmmmmmmmmmmmmm  ----PP    
             -Ek!_```bbbb``bb``bbbb----UU    
             }6,`^26666``````````66----66    
             EE``1EEEEEEE``EE``EEEE----99    
             Jy_.=eyyyy..........yy----ww    
             _Il~_---oooo--oo--oooobbbbbb    
              `;7x111111111111111            
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:PsiCSharpThemedIcons+Csharp}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(PsiCSharpThemedIcons.Csharp))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = PsiCSharpThemedIcons.Csharp.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;PsiCSharpThemedIcons.Csharp&gt;()        // Icon image for rendering</code>
            </example>
             <summary>
            	<para>
            		<para>Csharp Themed Icon generated identifiers:</para>
            		<para>— <see cref = "T:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp"></see> identifier class, for use in attributes, XAML, and generic parameters;</para>
            		<para>— <see cref = "F:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp.Id"></see> identifier object, as a field in the identifier class, for use where an <see cref = "T:JetBrains.UI.Icons.IconId"></see> value is expected.</para>
            		<para>
            			<code>
                                             
                 33333333333333I/`           
                 uu''''''''''''^su/`         
                 oo--------------~Jo*`       
                 55----        ----~l2+`     
                 aa----        ------~ta+    
                 SS----            ----SS    
                 kk----            ----kk    
                 kk----            ----kk    
              `!xOmmmmmmmmmmmmmmm  ----PP    
             -Ek!_```bbbb``bb``bbbb----UU    
             }6,`^26666``````````66----66    
             EE``1EEEEEEE``EE``EEEE----99    
             Jy_.=eyyyy..........yy----ww    
             _Il~_---oooo--oo--oooobbbbbb    
              `;7x111111111111111            
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:PsiCSharpThemedIcons+Csharp}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(PsiCSharpThemedIcons.Csharp))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = PsiCSharpThemedIcons.Csharp.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;PsiCSharpThemedIcons.Csharp&gt;()        // Icon image for rendering</code>
            </example>
             <summary>
            	<para>
            		<para>Csharp Themed Icon generated identifiers:</para>
            		<para>— <see cref = "T:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp"></see> identifier class, for use in attributes, XAML, and generic parameters;</para>
            		<para>— <see cref = "F:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp.Id"></see> identifier object, as a field in the identifier class, for use where an <see cref = "T:JetBrains.UI.Icons.IconId"></see> value is expected.</para>
            		<para>
            			<code>
                                             
                 33333333333333I/`           
                 uu''''''''''''^su/`         
                 oo--------------~Jo*`       
                 55----        ----~l2+`     
                 aa----        ------~ta+    
                 SS----            ----SS    
                 kk----            ----kk    
                 kk----            ----kk    
              `!xOmmmmmmmmmmmmmmm  ----PP    
             -Ek!_```bbbb``bb``bbbb----UU    
             }6,`^26666``````````66----66    
             EE``1EEEEEEE``EE``EEEE----99    
             Jy_.=eyyyy..........yy----ww    
             _Il~_---oooo--oo--oooobbbbbb    
              `;7x111111111111111            
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:PsiCSharpThemedIcons+Csharp}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(PsiCSharpThemedIcons.Csharp))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = PsiCSharpThemedIcons.Csharp.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;PsiCSharpThemedIcons.Csharp&gt;()        // Icon image for rendering</code>
            </example>
             <summary>
            	<para>
            		<para>Csharp Themed Icon generated identifiers:</para>
            		<para>— <see cref = "T:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp"></see> identifier class, for use in attributes, XAML, and generic parameters;</para>
            		<para>— <see cref = "F:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp.Id"></see> identifier object, as a field in the identifier class, for use where an <see cref = "T:JetBrains.UI.Icons.IconId"></see> value is expected.</para>
            		<para>
            			<code>
                                             
                 33333333333333I/`           
                 uu''''''''''''^su/`         
                 oo--------------~Jo*`       
                 55----        ----~l2+`     
                 aa----        ------~ta+    
                 SS----            ----SS    
                 kk----            ----kk    
                 kk----            ----kk    
              `!xOmmmmmmmmmmmmmmm  ----PP    
             -Ek!_```bbbb``bb``bbbb----UU    
             }6,`^26666``````````66----66    
             EE``1EEEEEEE``EE``EEEE----99    
             Jy_.=eyyyy..........yy----ww    
             _Il~_---oooo--oo--oooobbbbbb    
              `;7x111111111111111            
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:PsiCSharpThemedIcons+Csharp}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(PsiCSharpThemedIcons.Csharp))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = PsiCSharpThemedIcons.Csharp.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;PsiCSharpThemedIcons.Csharp&gt;()        // Icon image for rendering</code>
            </example>
             <summary>
            	<para>
            		<para>Csharp Themed Icon generated identifiers:</para>
            		<para>— <see cref = "T:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp"></see> identifier class, for use in attributes, XAML, and generic parameters;</para>
            		<para>— <see cref = "F:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp.Id"></see> identifier object, as a field in the identifier class, for use where an <see cref = "T:JetBrains.UI.Icons.IconId"></see> value is expected.</para>
            		<para>
            			<code>
                                             
                 33333333333333I/`           
                 uu''''''''''''^su/`         
                 oo--------------~Jo*`       
                 55----        ----~l2+`     
                 aa----        ------~ta+    
                 SS----            ----SS    
                 kk----            ----kk    
                 kk----            ----kk    
              `!xOmmmmmmmmmmmmmmm  ----PP    
             -Ek!_```bbbb``bb``bbbb----UU    
             }6,`^26666``````````66----66    
             EE``1EEEEEEE``EE``EEEE----99    
             Jy_.=eyyyy..........yy----ww    
             _Il~_---oooo--oo--oooobbbbbb    
              `;7x111111111111111            
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:PsiCSharpThemedIcons+Csharp}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(PsiCSharpThemedIcons.Csharp))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = PsiCSharpThemedIcons.Csharp.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;PsiCSharpThemedIcons.Csharp&gt;()        // Icon image for rendering</code>
            </example>
             <summary>
            	<para>
            		<para>Csharp Themed Icon generated identifiers:</para>
            		<para>— <see cref = "T:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp"></see> identifier class, for use in attributes, XAML, and generic parameters;</para>
            		<para>— <see cref = "F:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp.Id"></see> identifier object, as a field in the identifier class, for use where an <see cref = "T:JetBrains.UI.Icons.IconId"></see> value is expected.</para>
            		<para>
            			<code>
                                             
                 33333333333333I/`           
                 uu''''''''''''^su/`         
                 oo--------------~Jo*`       
                 55----        ----~l2+`     
                 aa----        ------~ta+    
                 SS----            ----SS    
                 kk----            ----kk    
                 kk----            ----kk    
              `!xOmmmmmmmmmmmmmmm  ----PP    
             -Ek!_```bbbb``bb``bbbb----UU    
             }6,`^26666``````````66----66    
             EE``1EEEEEEE``EE``EEEE----99    
             Jy_.=eyyyy..........yy----ww    
             _Il~_---oooo--oo--oooobbbbbb    
              `;7x111111111111111            
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:PsiCSharpThemedIcons+Csharp}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(PsiCSharpThemedIcons.Csharp))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = PsiCSharpThemedIcons.Csharp.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;PsiCSharpThemedIcons.Csharp&gt;()        // Icon image for rendering</code>
            </example>
             <summary>
            	<para>
            		<para>Csharp Themed Icon generated identifiers:</para>
            		<para>— <see cref = "T:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp"></see> identifier class, for use in attributes, XAML, and generic parameters;</para>
            		<para>— <see cref = "F:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp.Id"></see> identifier object, as a field in the identifier class, for use where an <see cref = "T:JetBrains.UI.Icons.IconId"></see> value is expected.</para>
            		<para>
            			<code>
                                             
                 33333333333333I/`           
                 uu''''''''''''^su/`         
                 oo--------------~Jo*`       
                 55----        ----~l2+`     
                 aa----        ------~ta+    
                 SS----            ----SS    
                 kk----            ----kk    
                 kk----            ----kk    
              `!xOmmmmmmmmmmmmmmm  ----PP    
             -Ek!_```bbbb``bb``bbbb----UU    
             }6,`^26666``````````66----66    
             EE``1EEEEEEE``EE``EEEE----99    
             Jy_.=eyyyy..........yy----ww    
             _Il~_---oooo--oo--oooobbbbbb    
              `;7x111111111111111            
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:PsiCSharpThemedIcons+Csharp}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(PsiCSharpThemedIcons.Csharp))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = PsiCSharpThemedIcons.Csharp.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;PsiCSharpThemedIcons.Csharp&gt;()        // Icon image for rendering</code>
            </example>
             <summary>
            	<para>
            		<para>Csharp Themed Icon generated identifiers:</para>
            		<para>— <see cref = "T:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp"></see> identifier class, for use in attributes, XAML, and generic parameters;</para>
            		<para>— <see cref = "F:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp.Id"></see> identifier object, as a field in the identifier class, for use where an <see cref = "T:JetBrains.UI.Icons.IconId"></see> value is expected.</para>
            		<para>
            			<code>
                                             
                 33333333333333I/`           
                 uu''''''''''''^su/`         
                 oo--------------~Jo*`       
                 55----        ----~l2+`     
                 aa----        ------~ta+    
                 SS----            ----SS    
                 kk----            ----kk    
                 kk----            ----kk    
              `!xOmmmmmmmmmmmmmmm  ----PP    
             -Ek!_```bbbb``bb``bbbb----UU    
             }6,`^26666``````````66----66    
             EE``1EEEEEEE``EE``EEEE----99    
             Jy_.=eyyyy..........yy----ww    
             _Il~_---oooo--oo--oooobbbbbb    
              `;7x111111111111111            
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:PsiCSharpThemedIcons+Csharp}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(PsiCSharpThemedIcons.Csharp))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = PsiCSharpThemedIcons.Csharp.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;PsiCSharpThemedIcons.Csharp&gt;()        // Icon image for rendering</code>
            </example>
             <summary>
            	<para>
            		<para>Csharp Themed Icon generated identifiers:</para>
            		<para>— <see cref = "T:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp"></see> identifier class, for use in attributes, XAML, and generic parameters;</para>
            		<para>— <see cref = "F:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp.Id"></see> identifier object, as a field in the identifier class, for use where an <see cref = "T:JetBrains.UI.Icons.IconId"></see> value is expected.</para>
            		<para>
            			<code>
                                             
                 33333333333333I/`           
                 uu''''''''''''^su/`         
                 oo--------------~Jo*`       
                 55----        ----~l2+`     
                 aa----        ------~ta+    
                 SS----            ----SS    
                 kk----            ----kk    
                 kk----            ----kk    
              `!xOmmmmmmmmmmmmmmm  ----PP    
             -Ek!_```bbbb``bb``bbbb----UU    
             }6,`^26666``````````66----66    
             EE``1EEEEEEE``EE``EEEE----99    
             Jy_.=eyyyy..........yy----ww    
             _Il~_---oooo--oo--oooobbbbbb    
              `;7x111111111111111            
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:PsiCSharpThemedIcons+Csharp}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(PsiCSharpThemedIcons.Csharp))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = PsiCSharpThemedIcons.Csharp.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;PsiCSharpThemedIcons.Csharp&gt;()        // Icon image for rendering</code>
            </example>
             <summary>
            	<para>
            		<para>Csharp Themed Icon generated identifiers:</para>
            		<para>— <see cref = "T:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp"></see> identifier class, for use in attributes, XAML, and generic parameters;</para>
            		<para>— <see cref = "F:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp.Id"></see> identifier object, as a field in the identifier class, for use where an <see cref = "T:JetBrains.UI.Icons.IconId"></see> value is expected.</para>
            		<para>
            			<code>
                                             
                 33333333333333I/`           
                 uu''''''''''''^su/`         
                 oo--------------~Jo*`       
                 55----        ----~l2+`     
                 aa----        ------~ta+    
                 SS----            ----SS    
                 kk----            ----kk    
                 kk----            ----kk    
              `!xOmmmmmmmmmmmmmmm  ----PP    
             -Ek!_```bbbb``bb``bbbb----UU    
             }6,`^26666``````````66----66    
             EE``1EEEEEEE``EE``EEEE----99    
             Jy_.=eyyyy..........yy----ww    
             _Il~_---oooo--oo--oooobbbbbb    
              `;7x111111111111111            
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:PsiCSharpThemedIcons+Csharp}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(PsiCSharpThemedIcons.Csharp))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = PsiCSharpThemedIcons.Csharp.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;PsiCSharpThemedIcons.Csharp&gt;()        // Icon image for rendering</code>
            </example>
             <summary>
            	<para>
            		<para>Csharp Themed Icon generated identifiers:</para>
            		<para>— <see cref = "T:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp"></see> identifier class, for use in attributes, XAML, and generic parameters;</para>
            		<para>— <see cref = "F:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp.Id"></see> identifier object, as a field in the identifier class, for use where an <see cref = "T:JetBrains.UI.Icons.IconId"></see> value is expected.</para>
            		<para>
            			<code>
                                             
                 33333333333333I/`           
                 uu''''''''''''^su/`         
                 oo--------------~Jo*`       
                 55----        ----~l2+`     
                 aa----        ------~ta+    
                 SS----            ----SS    
                 kk----            ----kk    
                 kk----            ----kk    
              `!xOmmmmmmmmmmmmmmm  ----PP    
             -Ek!_```bbbb``bb``bbbb----UU    
             }6,`^26666``````````66----66    
             EE``1EEEEEEE``EE``EEEE----99    
             Jy_.=eyyyy..........yy----ww    
             _Il~_---oooo--oo--oooobbbbbb    
              `;7x111111111111111            
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:PsiCSharpThemedIcons+Csharp}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(PsiCSharpThemedIcons.Csharp))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = PsiCSharpThemedIcons.Csharp.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;PsiCSharpThemedIcons.Csharp&gt;()        // Icon image for rendering</code>
            </example>
             <summary>
            	<para>
            		<para>Csharp Themed Icon generated identifiers:</para>
            		<para>— <see cref = "T:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp"></see> identifier class, for use in attributes, XAML, and generic parameters;</para>
            		<para>— <see cref = "F:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp.Id"></see> identifier object, as a field in the identifier class, for use where an <see cref = "T:JetBrains.UI.Icons.IconId"></see> value is expected.</para>
            		<para>
            			<code>
                                             
                 33333333333333I/`           
                 uu''''''''''''^su/`         
                 oo--------------~Jo*`       
                 55----        ----~l2+`     
                 aa----        ------~ta+    
                 SS----            ----SS    
                 kk----            ----kk    
                 kk----            ----kk    
              `!xOmmmmmmmmmmmmmmm  ----PP    
             -Ek!_```bbbb``bb``bbbb----UU    
             }6,`^26666``````````66----66    
             EE``1EEEEEEE``EE``EEEE----99    
             Jy_.=eyyyy..........yy----ww    
             _Il~_---oooo--oo--oooobbbbbb    
              `;7x111111111111111            
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:PsiCSharpThemedIcons+Csharp}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(PsiCSharpThemedIcons.Csharp))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = PsiCSharpThemedIcons.Csharp.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;PsiCSharpThemedIcons.Csharp&gt;()        // Icon image for rendering</code>
            </example>
             <summary>
            	<para>
            		<para>Csharp Themed Icon generated identifiers:</para>
            		<para>— <see cref = "T:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp"></see> identifier class, for use in attributes, XAML, and generic parameters;</para>
            		<para>— <see cref = "F:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp.Id"></see> identifier object, as a field in the identifier class, for use where an <see cref = "T:JetBrains.UI.Icons.IconId"></see> value is expected.</para>
            		<para>
            			<code>
                                             
                 33333333333333I/`           
                 uu''''''''''''^su/`         
                 oo--------------~Jo*`       
                 55----        ----~l2+`     
                 aa----        ------~ta+    
                 SS----            ----SS    
                 kk----            ----kk    
                 kk----            ----kk    
              `!xOmmmmmmmmmmmmmmm  ----PP    
             -Ek!_```bbbb``bb``bbbb----UU    
             }6,`^26666``````````66----66    
             EE``1EEEEEEE``EE``EEEE----99    
             Jy_.=eyyyy..........yy----ww    
             _Il~_---oooo--oo--oooobbbbbb    
              `;7x111111111111111            
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:PsiCSharpThemedIcons+Csharp}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(PsiCSharpThemedIcons.Csharp))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = PsiCSharpThemedIcons.Csharp.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;PsiCSharpThemedIcons.Csharp&gt;()        // Icon image for rendering</code>
            </example>
             <summary>
            	<para>
            		<para>Csharp Themed Icon generated identifiers:</para>
            		<para>— <see cref = "T:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp"></see> identifier class, for use in attributes, XAML, and generic parameters;</para>
            		<para>— <see cref = "F:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp.Id"></see> identifier object, as a field in the identifier class, for use where an <see cref = "T:JetBrains.UI.Icons.IconId"></see> value is expected.</para>
            		<para>
            			<code>
                                             
                 33333333333333I/`           
                 uu''''''''''''^su/`         
                 oo--------------~Jo*`       
                 55----        ----~l2+`     
                 aa----        ------~ta+    
                 SS----            ----SS    
                 kk----            ----kk    
                 kk----            ----kk    
              `!xOmmmmmmmmmmmmmmm  ----PP    
             -Ek!_```bbbb``bb``bbbb----UU    
             }6,`^26666``````````66----66    
             EE``1EEEEEEE``EE``EEEE----99    
             Jy_.=eyyyy..........yy----ww    
             _Il~_---oooo--oo--oooobbbbbb    
              `;7x111111111111111            
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:PsiCSharpThemedIcons+Csharp}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(PsiCSharpThemedIcons.Csharp))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = PsiCSharpThemedIcons.Csharp.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;PsiCSharpThemedIcons.Csharp&gt;()        // Icon image for rendering</code>
            </example>
             <summary>
            	<para>
            		<para>Csharp Themed Icon generated identifiers:</para>
            		<para>— <see cref = "T:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp"></see> identifier class, for use in attributes, XAML, and generic parameters;</para>
            		<para>— <see cref = "F:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp.Id"></see> identifier object, as a field in the identifier class, for use where an <see cref = "T:JetBrains.UI.Icons.IconId"></see> value is expected.</para>
            		<para>
            			<code>
                                             
                 33333333333333I/`           
                 uu''''''''''''^su/`         
                 oo--------------~Jo*`       
                 55----        ----~l2+`     
                 aa----        ------~ta+    
                 SS----            ----SS    
                 kk----            ----kk    
                 kk----            ----kk    
              `!xOmmmmmmmmmmmmmmm  ----PP    
             -Ek!_```bbbb``bb``bbbb----UU    
             }6,`^26666``````````66----66    
             EE``1EEEEEEE``EE``EEEE----99    
             Jy_.=eyyyy..........yy----ww    
             _Il~_---oooo--oo--oooobbbbbb    
              `;7x111111111111111            
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:PsiCSharpThemedIcons+Csharp}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(PsiCSharpThemedIcons.Csharp))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = PsiCSharpThemedIcons.Csharp.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;PsiCSharpThemedIcons.Csharp&gt;()        // Icon image for rendering</code>
            </example>
             <summary>
            	<para>
            		<para>Csharp Themed Icon generated identifiers:</para>
            		<para>— <see cref = "T:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp"></see> identifier class, for use in attributes, XAML, and generic parameters;</para>
            		<para>— <see cref = "F:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp.Id"></see> identifier object, as a field in the identifier class, for use where an <see cref = "T:JetBrains.UI.Icons.IconId"></see> value is expected.</para>
            		<para>
            			<code>
                                             
                 33333333333333I/`           
                 uu''''''''''''^su/`         
                 oo--------------~Jo*`       
                 55----        ----~l2+`     
                 aa----        ------~ta+    
                 SS----            ----SS    
                 kk----            ----kk    
                 kk----            ----kk    
              `!xOmmmmmmmmmmmmmmm  ----PP    
             -Ek!_```bbbb``bb``bbbb----UU    
             }6,`^26666``````````66----66    
             EE``1EEEEEEE``EE``EEEE----99    
             Jy_.=eyyyy..........yy----ww    
             _Il~_---oooo--oo--oooobbbbbb    
              `;7x111111111111111            
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:PsiCSharpThemedIcons+Csharp}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(PsiCSharpThemedIcons.Csharp))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = PsiCSharpThemedIcons.Csharp.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;PsiCSharpThemedIcons.Csharp&gt;()        // Icon image for rendering</code>
            </example>
             <summary>
            	<para>
            		<para>Csharp Themed Icon generated identifiers:</para>
            		<para>— <see cref = "T:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp"></see> identifier class, for use in attributes, XAML, and generic parameters;</para>
            		<para>— <see cref = "F:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp.Id"></see> identifier object, as a field in the identifier class, for use where an <see cref = "T:JetBrains.UI.Icons.IconId"></see> value is expected.</para>
            		<para>
            			<code>
                                             
                 33333333333333I/`           
                 uu''''''''''''^su/`         
                 oo--------------~Jo*`       
                 55----        ----~l2+`     
                 aa----        ------~ta+    
                 SS----            ----SS    
                 kk----            ----kk    
                 kk----            ----kk    
              `!xOmmmmmmmmmmmmmmm  ----PP    
             -Ek!_```bbbb``bb``bbbb----UU    
             }6,`^26666``````````66----66    
             EE``1EEEEEEE``EE``EEEE----99    
             Jy_.=eyyyy..........yy----ww    
             _Il~_---oooo--oo--oooobbbbbb    
              `;7x111111111111111            
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:PsiCSharpThemedIcons+Csharp}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(PsiCSharpThemedIcons.Csharp))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = PsiCSharpThemedIcons.Csharp.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;PsiCSharpThemedIcons.Csharp&gt;()        // Icon image for rendering</code>
            </example>
             <summary>
            	<para>
            		<para>Csharp Themed Icon generated identifiers:</para>
            		<para>— <see cref = "T:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp"></see> identifier class, for use in attributes, XAML, and generic parameters;</para>
            		<para>— <see cref = "F:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.Csharp.Id"></see> identifier object, as a field in the identifier class, for use where an <see cref = "T:JetBrains.UI.Icons.IconId"></see> value is expected.</para>
            		<para>
            			<code>
                                             
                 33333333333333I/`           
                 uu''''''''''''^su/`         
                 oo--------------~Jo*`       
                 55----        ----~l2+`     
                 aa----        ------~ta+    
                 SS----            ----SS    
                 kk----            ----kk    
                 kk----            ----kk    
              `!xOmmmmmmmmmmmmmmm  ----PP    
             -Ek!_```bbbb``bb``bbbb----UU    
             }6,`^26666``````````66----66    
             EE``1EEEEEEE``EE``EEEE----99    
             Jy_.=eyyyy..........yy----ww    
             _Il~_---oooo--oo--oooobbbbbb    
              `;7x111111111111111            
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:PsiCSharpThemedIcons+Csharp}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(PsiCSharpThemedIcons.Csharp))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = PsiCSharpThemedIcons.Csharp.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;PsiCSharpThemedIcons.Csharp&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.CSharpDestructor">
             <summary>
            	<para>
            		<para>CSharpDestructor Themed Icon generated identifiers:</para>
            		<para>— <see cref="T:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.CSharpDestructor"></see> identifier class, for use in attributes, XAML, and generic parameters;</para>
            		<para>— <see cref="F:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.CSharpDestructor.Id"></see> identifier object, as a field in the identifier class, for use where an <see cref="T:JetBrains.UI.Icons.IconId"></see> value is expected.</para>
            		<para>
            			<code>
                                             
                        -;+LTl^ :?Chhh!      
                        ~IekEhhh|". !h!      
                        ^t!-!t^     !h!      
                        ^t!-!t^     !h!      
                    `_=cTtttttTc=_`          
                  `_/tt{^ ~1=`=o31*_`        
                  ,cTl^ "t^ ~I=`!kfc,        
                `_/t~`~l" ^{~`!E+'=t/_`      
                '^+tt}~`~C~`=5/.cDKt+^'      
                '^+t=.;3=`!y/.rGc-!t+^'      
                `_/t3y/'+P+-LG)_78Ut/_`      
                  ,c=-Lbc:|O7^}%C~/c,        
                  `_*Ir"sDt~{8C=cu+_`        
                    `_=cTtttttTc=_`          
                                             
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:PsiCSharpThemedIcons+CSharpDestructor}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(PsiCSharpThemedIcons.CSharpDestructor))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = PsiCSharpThemedIcons.CSharpDestructor.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;PsiCSharpThemedIcons.CSharpDestructor&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.CSharpDestructor.Id">
            <inheritdoc cref="T:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.CSharpDestructor">identifier class</inheritdoc>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.CSharpDestructor.Load_SymbolsIdea">
            <summary>Loads the image for Themed Icon CSharpDestructor theme aspect SymbolsIdea.</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.CSharpDestructor.Load_SymbolsVs08">
            <summary>Loads the image for Themed Icon CSharpDestructor theme aspect SymbolsVs08.</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.CSharpDestructor.Load_SymbolsVs11Color">
            <summary>Loads the image for Themed Icon CSharpDestructor theme aspect SymbolsVs11Color.</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.CSharpDestructor.Load_SymbolsVs11Gray">
            <summary>Loads the image for Themed Icon CSharpDestructor theme aspect SymbolsVs11Gray.</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.CSharpDestructor.Load_SymbolsVs11GrayDark">
            <summary>Loads the image for Themed Icon CSharpDestructor theme aspect SymbolsVs11GrayDark.</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.CSharpDestructor.GetThemeImages">
            <summary>Returns the set of theme images for Themed Icon CSharpDestructor.</summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.CSharpIndexer">
             <summary>
            	<para>
            		<para>CSharpIndexer Themed Icon generated identifiers:</para>
            		<para>— <see cref="T:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.CSharpIndexer"></see> identifier class, for use in attributes, XAML, and generic parameters;</para>
            		<para>— <see cref="F:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.CSharpIndexer.Id"></see> identifier object, as a field in the identifier class, for use where an <see cref="T:JetBrains.UI.Icons.IconId"></see> value is expected.</para>
            		<para>
            			<code>
                                             
                        `-=LLL=-`            
                      `-=c~...~|=-`          
                    `-=c~.`   `.=7!-`        
                  `-=L^.`       `.=t!-`      
                `-=?^.`   ~II3~  ``';C/-`    
              `-=?^.`     ~333~ ````.-!]/-`  
              :r^.`      ``---.``....`.-!]~  
              ,c~.`    ```=oo2=``''-..'-!]~  
              `-;T='` ````;255;`.-'.'-!]/-`  
                `-!7=-````!aaS!``.--!]/-`    
                  `-!l=-.`~JT)^`.-!]/-`      
                    `-!};-'`..'-!]/-`        
                      `-/C!---!]/-`          
                        `-/]]]/-`            
                                             
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:PsiCSharpThemedIcons+CSharpIndexer}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(PsiCSharpThemedIcons.CSharpIndexer))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = PsiCSharpThemedIcons.CSharpIndexer.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;PsiCSharpThemedIcons.CSharpIndexer&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.CSharpIndexer.Id">
            <inheritdoc cref="T:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.CSharpIndexer">identifier class</inheritdoc>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.CSharpIndexer.Load_SymbolsIdea">
            <summary>Loads the image for Themed Icon CSharpIndexer theme aspect SymbolsIdea.</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.CSharpIndexer.Load_SymbolsVs08">
            <summary>Loads the image for Themed Icon CSharpIndexer theme aspect SymbolsVs08.</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.CSharpIndexer.Load_SymbolsVs11Color">
            <summary>Loads the image for Themed Icon CSharpIndexer theme aspect SymbolsVs11Color.</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.CSharpIndexer.Load_SymbolsVs11Gray">
            <summary>Loads the image for Themed Icon CSharpIndexer theme aspect SymbolsVs11Gray.</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.CSharpIndexer.Load_SymbolsVs11GrayDark">
            <summary>Loads the image for Themed Icon CSharpIndexer theme aspect SymbolsVs11GrayDark.</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.CSharpIndexer.GetThemeImages">
            <summary>Returns the set of theme images for Themed Icon CSharpIndexer.</summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.LocalFunction">
             <summary>
            	<para>
            		<para>LocalFunction Themed Icon generated identifiers:</para>
            		<para>— <see cref="T:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.LocalFunction"></see> identifier class, for use in attributes, XAML, and generic parameters;</para>
            		<para>— <see cref="F:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.LocalFunction.Id"></see> identifier object, as a field in the identifier class, for use where an <see cref="T:JetBrains.UI.Icons.IconId"></see> value is expected.</para>
            		<para>
            			<code>
                                             
                         `~7wbs;`            
                      :ryRZ[Lr{Emkc,         
                  .![Abu);;;;;;;;LCwmf\-     
                 6D[T!""""""""""""""!T}Db    
               `:juvTrLr;::::::::~;: -"DD    
              ^}(^.``._LF;_~::~_``";^_:DD    
             ~C! -L3u): ~C):  :;=;;~^_:88    
             vu-`{SSSS2``u3_,+*=!;;~^_:88    
             ;5!`:Ll}c"`~57_,+*=!;;~^_:88    
              TS~......,j2~_,+*=!;;~~*{W8    
              `xk"----:eS;"_,+*=!+}X8HJ^`    
               .eE_--:eXDDS)~r}kD82=.        
                :Uk_:54: :cZ%B6|,            
                 :bV2p^                      
                  ~OO\                       
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:PsiCSharpThemedIcons+LocalFunction}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(PsiCSharpThemedIcons.LocalFunction))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = PsiCSharpThemedIcons.LocalFunction.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;PsiCSharpThemedIcons.LocalFunction&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.LocalFunction.Id">
            <inheritdoc cref="T:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.LocalFunction">identifier class</inheritdoc>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.LocalFunction.Load_SymbolsVs11Color">
            <summary>Loads the image for Themed Icon LocalFunction theme aspect Color.</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.LocalFunction.Load_SymbolsVs11Gray">
            <summary>Loads the image for Themed Icon LocalFunction theme aspect Gray.</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.LocalFunction.Load_SymbolsVs11GrayDark">
            <summary>Loads the image for Themed Icon LocalFunction theme aspect GrayDark.</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.LocalFunction.GetThemeImages">
            <summary>Returns the set of theme images for Themed Icon LocalFunction.</summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.AllParameters">
             <summary>
            	<para>
            		<para>AllParameters Themed Icon generated identifiers:</para>
            		<para>— <see cref="T:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.AllParameters"></see> identifier class, for use in attributes, XAML, and generic parameters;</para>
            		<para>— <see cref="F:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.AllParameters.Id"></see> identifier object, as a field in the identifier class, for use where an <see cref="T:JetBrains.UI.Icons.IconId"></see> value is expected.</para>
            		<para>
            			<code>
                                             
                `Tjjjj;   `_royc"` _jjjjv.   
               :21.;y* -!zUl;"^;}Xz!*y\`Jo^  
              :y} -y[)Vkc^^LXD8O~`^ww7a: Ta^ 
             `e3` tV'pp  '!IVc_    pp`22` }V'
             /E~ _EL RR_`       :/3RX =E; :E)
             xh.`rh^ XDqR{;.`~vbqv=DD :hv``hy
             2X'`3X. 88`-+j88Zc,```88  XZ``XX
             36-`T6_ WW~```'-```_LkWA -6x``6P
             L9;`;9L dBD8o=--!tDDtrBB !9*`"9i
             -be--XK`$$.:cX$$dv~...$$ y9:.tb_
              !HI-;HtQQ!-..:,...~7bQb7H*'JH? 
               \bo:TqF}8QXL,:re$$e!`;q[:tqc  
                :UGGGG; -|AggDJ_   ,dGGGX^   
                                             
                                             
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:DekalunThemedIconsThemedIcons+AllParameters}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(DekalunThemedIconsThemedIcons.AllParameters))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = DekalunThemedIconsThemedIcons.AllParameters.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;DekalunThemedIconsThemedIcons.AllParameters&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.AllParameters.Id">
            <inheritdoc cref="T:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.AllParameters">identifier class</inheritdoc>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.AllParameters.Load_Color">
            <summary>Loads the image for Themed Icon AllParameters theme aspect Color.</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.AllParameters.Load_Gray">
            <summary>Loads the image for Themed Icon AllParameters theme aspect Gray.</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.AllParameters.Load_GrayDark">
            <summary>Loads the image for Themed Icon AllParameters theme aspect GrayDark.</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons.AllParameters.GetThemeImages">
            <summary>Returns the set of theme images for Themed Icon AllParameters.</summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Caches.CollectionExpressionCache">
            <summary>
            Stores information whether the file possibly contains collection expressions.
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Caches.IAliasDirectiveCache">
            <summary>
            Exposes queries to a cache of alias directives.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Caches.IAliasDirectiveCache.GetFilesPossiblyDeclaringAlias(System.String,System.Func{JetBrains.ReSharper.Psi.IPsiSourceFile,System.Boolean})">
            <summary>
            Returns files possibly declaring alias with the specified name.
            </summary>
            <param name="aliasName">Alias name.</param>
            <param name="sourceFilePredicate">Optional predicate of source files.</param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Caches.IAliasDirectiveCache.GetFilesPossiblyDeclaringAliasesTo(JetBrains.ReSharper.Psi.CSharp.DeclaredElements.AliasedSymbol,System.Func{JetBrains.ReSharper.Psi.IPsiSourceFile,System.Boolean})">
            <summary>
            Returns files possibly declaring alias to the specified symbol.
            </summary>
            <param name="aliasedSymbol">Aliased symbol.</param>
            <param name="sourceFilePredicate">Optional predicate of source files.</param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Caches.IAliasDirectiveCache.CreateAliasDirectiveSearcher(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpFile,System.Boolean)">
            <summary>
            Creates a searcher to find using alias directives in a specified file.
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Caches.IAliasDirectiveSearcher">
            <summary>
            Allows to find using alias directives for the specified type usages, types, or namespaces.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Caches.IAliasDirectiveSearcher.FindSingleAvailableAliasFor(JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage)">
            <summary>
            Finds a single available alias for the specified type usage.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Caches.IAliasDirectiveSearcher.FindSingleAvailableAliasFor(JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceName)">
            <summary>
            Finds a single available alias for the specified reference name.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Caches.IAliasDirectiveSearcher.FindSingleAvailableAliasFor(JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression)">
            <summary>
            Finds a single available alias for the specified reference expression.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Caches.IAliasDirectiveSearcher.FindSingleAvailableAliasFor(JetBrains.ReSharper.Psi.CSharp.Tree.IPredefinedTypeExpression)">
            <summary>
            Finds a single available alias for the specified predefined type expression.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Caches.IAliasDirectiveSearcher.FindAllAliasesFor(JetBrains.ReSharper.Psi.IType)">
            <summary>
            Finds a all aliases for the specified type.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Caches.IAliasDirectiveSearcher.FindAllAliasesFor(JetBrains.ReSharper.Psi.INamespace)">
            <summary>
            Finds a all aliases for the specified namespace.
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Caches.TargetTypedObjectCreationCache">
            <summary>
            Stores information whether the file possibly contains target-typed new expressions.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.CodeStyle.CSharpUsingSettingsAccessor.AddImportsToDeepestScope">
            <remarks>
            Do not use directly in features. Use <see cref="M:JetBrains.ReSharper.Psi.CSharp.Util.CSharpModificationUtil.IsToAddImportsToDeepestScope(JetBrains.ReSharper.Psi.Tree.ITreeNode)" />
            </remarks>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.CodeStyle.VariableTypeKind.Other">
            <summary>
            types with type arguments, arrays, pointer type, etc.
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.CodeStyle.FileLayoutPatternResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.CodeStyle.FileLayoutPatternResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.CodeStyle.FileLayoutPatternResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.CodeStyle.FileLayoutPatternResources.DefaultMemberReorderingPatterns">
            <summary>
              Looks up a localized string similar to &lt;Patterns xmlns=&quot;clr-namespace:JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering;assembly=JetBrains.ReSharper.Psi.CSharp&quot;&gt;
             &lt;TypePattern DisplayName=&quot;COM interfaces and structs&quot;&gt;
               &lt;TypePattern.Match&gt;
                 &lt;Or&gt;
                   &lt;And&gt;
                     &lt;Kind Is=&quot;Interface&quot; /&gt;
                     &lt;Or&gt;
                       &lt;HasAttribute Name=&quot;System.Runtime.InteropServices.InterfaceTypeAttribute&quot; /&gt;
                       &lt;HasAttribute Name=&quot;System.Runtime.InteropServices.ComImport&quot; /&gt;
                     &lt;/Or&gt;
                   &lt;/And&gt;
                   &lt;Has [rest of string was truncated]&quot;;.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.CodeStyle.FileLayoutPatternResources.DefaultMemberReorderingPatternsWithoutRegions">
            <summary>
              Looks up a localized string similar to &lt;Patterns xmlns=&quot;clr-namespace:JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering;assembly=JetBrains.ReSharper.Psi.CSharp&quot;&gt;
             &lt;TypePattern DisplayName=&quot;COM interfaces or structs&quot;&gt;
               &lt;TypePattern.Match&gt;
                 &lt;Or&gt;
                   &lt;And&gt;
                     &lt;Kind Is=&quot;Interface&quot; /&gt;
                     &lt;Or&gt;
                       &lt;HasAttribute Name=&quot;System.Runtime.InteropServices.InterfaceTypeAttribute&quot; /&gt;
                       &lt;HasAttribute Name=&quot;System.Runtime.InteropServices.ComImport&quot; /&gt;
                     &lt;/Or&gt;
                   &lt;/And&gt;
                   &lt;HasA [rest of string was truncated]&quot;;.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.CodeStyle.FileLayoutPatternResources.MemberReorderingMigrationTransform">
             <summary>
               Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
            &lt;xsl:stylesheet
              version=&quot;1.0&quot;
              xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;
              xmlns:msxsl=&quot;urn:schemas-microsoft-com:xslt&quot;
              xmlns=&quot;urn:shemas-jetbrains-com:member-reordering-patterns&quot;
              xmlns:x=&quot;urn:shemas-jetbrains-com:member-reordering-patterns&quot;
              exclude-result-prefixes=&quot;msxsl x&quot;&gt;
            
              &lt;xsl:output method=&quot;xml&quot; indent=&quot;yes&quot; /&gt;
            
              &lt;xsl:template match=&quot;x:Patterns&quot;&gt;
                &lt;Patterns&gt;
                  &lt;xsl:apply-templates /&gt;
                &lt;/Patterns&gt;
              &lt;/xsl:template&gt;
            
               [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.CodeStyle.ICustomIndentHandler">
            <summary>
            Provide custom indentation for the node to format correctly in ASP/Razor
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.CodeStyle.ICustomIndentHandler.Indent(JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.CodeStyle.CustomIndentType,JetBrains.ReSharper.Psi.Impl.CodeStyle.FmtSettingsClassic{JetBrains.ReSharper.Psi.CSharp.CodeStyle.FormatSettings.CSharpFormatSettingsKey})">
            <param name="node">node to get the indent for</param>
            <param name="indentType">type of requested custom indent</param>
            <param name="settings"></param>
            <returns><c>null</c> if default indentation should be used, or string which will be used as an indent</returns>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.CodeStyle.SettingsUpgrade.CSharpCodeStyleSettings">
            <summary>
            Used for storing and managing of code style settings
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.CodeStyle.Suggestions.BracesForIfElseStatementCodeStyleSuggestion.SuggestionForThen">
            <summary>Gets braces code style suggestions for 'then' part of 'if'-statement.</summary>
            <returns>true if braces should be added, false if braces should be removed, null - do nothing.</returns>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.CodeStyle.Suggestions.BracesForIfElseStatementCodeStyleSuggestion.SuggestionForElse">
            <summary>Gets braces code style suggestions for 'else' part of 'if'-statement.</summary>
            <returns>true if braces should be added, false if braces should be removed, null - do nothing.</returns>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.CodeStyle.Suggestions.BracesForIfElseStatementCodeStyleSuggestion.TopSuggestion">
            <summary>
            Gets the top code style suggestion in 'If'-statement chain.
            Returns current suggestion if it is a top or there is no 'If'-statement chain.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.ConstantValues.CSharpConstantCalculatorImpl.ourTypePresentationStyle">
            <summary>
            Note: doesn't present nullable annotations
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.ControlFlow.CSharpPassThroughFinallyEdgeInfo">
            <summary>Attached to edge which exits from 'finally' block</summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.ControlFlow.CSharpPassThroughFinallyEdgeInfo.TryStatement">
            <summary>'try' statement itself</summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.ControlFlow.CSharpPassThroughFinallyEdgeInfo.ExitFromFinallyEdge">
            <summary>That edge which exits from 'try' block</summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.ControlFlow.CSharpExitFromFinallyEdgeInfo">
            <summary>Attached to edge which exits from 'finally' block</summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.ControlFlow.CSharpExitFromFinallyEdgeInfo.PassThroughFinally">
            <summary>That edge which exits from 'try' block</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Conversions.Conversion.GetTopLevelNestedConversions">
            <summary>
            This method doesn't unwrap nested conversions recursively.
            Callers must either unwrap them themselves or call <see cref="M:JetBrains.ReSharper.Psi.CSharp.Conversions.Conversion.GetNestedConversions"/> instead.
            It might be useful in case you expect some nested conversions that match converted expressions
            e.g. when converting switch expressions you'll get a conversion per switch expression arm without their nested conversions.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Conversions.ICSharpTypeConversionRule.ClassifyImplicitConversion(JetBrains.ReSharper.Psi.IType,JetBrains.ReSharper.Psi.IType)">
            <summary>
            Classifies conversion from <paramref name="from"/> to <paramref name="to"/>.
            Considers built-in and user-defined implicit conversions.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Conversions.ICSharpTypeConversionRule.ClassifyConversionFromType(JetBrains.ReSharper.Psi.IType,JetBrains.ReSharper.Psi.IType,System.Boolean)">
            <summary>
            Classifies conversion from <paramref name="from"/> to <paramref name="to"/>.
            Considers all kind of conversions including explicit and user-defined
            </summary>
            <remarks>
            It is rare but possible for a source type to be convertible to a destination type
            by both an implicit user-defined conversion and a built-in explicit conversion.
            In that circumstance, this method classifies the conversion as the invalid explicit conversion
            </remarks>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Conversions.ICSharpTypeConversionRule.ClassifyBuiltInConversion(JetBrains.ReSharper.Psi.IType,JetBrains.ReSharper.Psi.IType)">
            <summary>
            Following implicit and explicit conversions are considered builtin:
            Identity, Reference, Numeric, Boxing, Unboxing, Pointer, Dynamic, Tuple, Nullable
            </summary>
            <remarks>
            Valid implicit builtin conversions are strict subset of standard implicit conversions.
            In case of tuple conversions the method might check for multiple user-defined operators
            </remarks>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Conversions.ICSharpTypeConversionRule.ClassifyImplicitConversionFromExpression(JetBrains.ReSharper.Psi.IExpressionType,JetBrains.ReSharper.Psi.IType)">
            <summary>
            Classifies conversion from <paramref name="from"/> to <paramref name="to"/>.
            Considers built-in and user-defined implicit conversions.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Conversions.ICSharpTypeConversionRule.ClassifyConversionFromExpression(JetBrains.ReSharper.Psi.IExpressionType,JetBrains.ReSharper.Psi.IType,System.Boolean)">
             <summary>
             Classifies conversion from <paramref name="fromExpressionType"/> to <paramref name="to"/>.
             Considers all kind of conversions including explicit and user-defined
             </summary>
             <remarks>
             For constant expression types it may return explicit conversion which will be compiler error in checked contexts.
            
             It is rare but possible for a source type to be convertible to a destination type
             by both an implicit user-defined conversion and a built-in explicit conversion.
             In that circumstance, this method classifies the conversion as the invalid explicit conversion
             </remarks>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Conversions.ICSharpTypeConversionRule.ClassifyImplicitExtensionMethodThisArgumentConversion(JetBrains.ReSharper.Psi.IExpressionType,JetBrains.ReSharper.Psi.IType)">
            <summary>
            This method exists for performance reasons only as it doesn't check for user-defined conversions
            This method only checks following conversion kinds: Identity, ImplicitReference, Boxing, ImplicitTuple, ImplicitTupleLiteral
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Conversions.UserDefinedConversionAnalysis.FromType">
            <summary>
            The actual source type used which was converted to the operator's source type via the conversion stored in the SourceConversion field
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Conversions.UserDefinedConversionAnalysis.ToType">
            <summary>
            The actual target to which the operator's result type was converted via the conversion stored in the TargetConversion field
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.CSharpElementFactory">
            <summary>
            Factory for C# tree nodes creation.
            Format string is specified with $0, $1, ... as placeholders for arguments
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.CSharpExtensionMethods.IsGeneratedFileForCompiler(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpFile)">
            <summary>
            See 'GeneratedCodeUtilities.cs' in Roslyn.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.CSharpLanguageLevel.CSharp120">
            <summary>
            collection expressions
            primary constructors
            ref readonly parameters
            lambda default parameters
            using aliases for any type
            inline arrays
            nameof accessing instance members
            Experimental attribute
            interceptors (experimental feature)
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.CSharpLanguageLevel.CSharp130">
            <summary>
            params-collections
            escape character
            Lock object
            method group natural type improvements
            implicit indexer access in object initializers
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.CSharpLanguageLevel.CSharp140">
            <summary>
            field keyword in properties
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.CSharpLanguageLevel.Experimental">
            <summary>
            NOTE: Use only for features that are not merged into the 'main' branch of Roslyn i.e. their fate is not clear yet
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.DeclaredElements.AliasedSymbol">
            <summary>
            Represents the aliased namespace or type.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.DeclaredElements.AliasedSymbol.TypeEqualityComparer">
            <summary>
            The equality comparer using all the language strictness but ignoring top-level nullability.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.DeclaredElements.AliasedSymbol.Unknown">
            <summary>
            An unknown aliased symbol.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.DeclaredElements.AliasedSymbol.#ctor(JetBrains.ReSharper.Psi.INamespace)">
            <summary>
            Constructs the aliased symbol from namespace.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.DeclaredElements.AliasedSymbol.#ctor(JetBrains.ReSharper.Psi.IType)">
            <summary>
            Constructs the aliased symbol from type.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.DeclaredElements.AliasedSymbol.Namespace">
            <summary>
            Gets the aliased namespace or value null if this is not a namespace alias instance.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.DeclaredElements.AliasedSymbol.Type">
            <summary>
            Gets the aliased type or value null if this is not a type alias instance.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.DeclaredElements.AliasedSymbol.IsUnknown">
            <summary>
            Value indicating whether the aliased symbol is unknown.
            </summary>
            <remarks>
            Returns value true if aliased type is unknown.
            </remarks>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.DeclaredElements.AliasedSymbol.IsResolved">
            <summary>
            Value indicating whether the aliased symbol is resolved.
            </summary>
            <remarks>
            In case of type alias acts like <see cref="!:IType.IsResolved"/>
            i.e. checks if substitution if any is also resolved.
            </remarks>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.DeclaredElements.AliasedSymbol.IsNamespaceOrRegularDeclaredType">
            <summary>
            Checks whether the alias refers to a namespace or a regular declared type.
            </summary>
            <remarks>
            See documentation of the <see cref="M:JetBrains.ReSharper.Psi.CSharp.DeclaredElements.AliasedSymbol.IsRegularDeclaredType(JetBrains.ReSharper.Psi.IDeclaredType@)"/> for a regularity definition.
            </remarks>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.DeclaredElements.AliasedSymbol.IsRegularDeclaredType(JetBrains.ReSharper.Psi.IDeclaredType@)">
            <summary>
            Checks whether the alias refers to a regular declared type.
            </summary>
            <param name="declaredType"></param>
            <remarks>
            A declared type is considered regular <b>unless</b> it's one of the following cases:
            <list type="bullet">
            <item>dynamic type</item>
            <item>native numeric type without runtime support</item>
            <item>tuple type with named components on top-level</item>
            </list>
            </remarks>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.DeclaredElements.AliasedSymbol.TryResolveNamespaceOrRegularDeclaredType(JetBrains.ReSharper.Psi.IClrDeclaredElement@,JetBrains.ReSharper.Psi.Resolve.ISubstitution@)">
            <summary>
            Checks if the aliased symbol is successfully resolved to a namespace or a regular declared type
            and returns the corresponding declared element and substitution.
            </summary>
            <remarks>
            See documentation of the <see cref="M:JetBrains.ReSharper.Psi.CSharp.DeclaredElements.AliasedSymbol.IsRegularDeclaredType(JetBrains.ReSharper.Psi.IDeclaredType@)"/> for a regularity definition.
            </remarks>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.DeclaredElements.AliasedSymbol.TryResolveRegularDeclaredType(JetBrains.ReSharper.Psi.ITypeElement@,JetBrains.ReSharper.Psi.Resolve.ISubstitution@)">
            <summary>
            Checks if the aliased symbol is successfully resolved to a regular declared type
            and returns the corresponding type element and substitution.
            </summary>
            <remarks>
            See documentation of the <see cref="M:JetBrains.ReSharper.Psi.CSharp.DeclaredElements.AliasedSymbol.IsRegularDeclaredType(JetBrains.ReSharper.Psi.IDeclaredType@)"/> for a regularity definition.
            </remarks>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.DeclaredElements.AliasedSymbol.ToNamespaceOrRegularDeclaredTypeElementInstance">
            <summary>
            Creates a declared element instance if the aliased symbol refers to
            a namespace or a regular declared type.
            </summary>
            <remarks>
            See documentation of the <see cref="M:JetBrains.ReSharper.Psi.CSharp.DeclaredElements.AliasedSymbol.IsRegularDeclaredType(JetBrains.ReSharper.Psi.IDeclaredType@)"/> for a regularity definition.
            </remarks>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.DeclaredElements.AliasedSymbol.IsEquivalentTo(JetBrains.ReSharper.Psi.IDeclaredElement)">
            <summary>
            Checks if the aliased symbol refers to the same declared element as specified parameter.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.DeclaredElements.AliasedSymbol.IsEquivalentTo(JetBrains.ReSharper.Psi.DeclaredElementInstance)">
            <summary>
            Checks if the aliased symbol refers to the same declared element instance as specified parameter.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.DeclaredElements.AliasedSymbol.IsEquivalentTo(JetBrains.ReSharper.Psi.IType)">
            <summary>
            Checks if the aliased symbol refers to the same type as specified parameter.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.DeclaredElements.AliasedSymbol.IsEquivalentTo(JetBrains.ReSharper.Psi.CSharp.DeclaredElements.AliasedSymbol)">
            <summary>
            Checks if the aliased symbol refers to the same namespace or type as other aliased symbol.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.DeclaredElements.ICSharpProperty.HasBackingFieldReference">
            <summary>
            Checks if the property accessors contain the reference to 'field' keyword.
            Only works for declared elements from source code.
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.DeclaredElements.ISymbolAlias">
            <summary>
            Represents the declared element of a 'using' alias.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.DeclaredElements.ISymbolAlias.AliasedSymbol">
            <summary>
            The aliased namespace or type.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.DeclaredElements.ISymbolAlias.IsGlobal">
            <summary>
            Value indicating whether the alias is declared in global using directive.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.DeclaredElements.ISymbolAlias.IsNamespaceOrRegularDeclaredTypeAlias">
            <summary>
            Value indicating whether the aliased symbol is a namespace or a regular declared type.
            </summary>
            <remarks>
            A symbol alias can refer either to a namespace, or to a type.
            
            Before C# 12 alias could refer only to a "regular" declared type
            fully constructed and defined by its <see cref="T:JetBrains.ReSharper.Psi.ITypeElement"/> and <see cref="T:JetBrains.ReSharper.Psi.Resolve.ISubstitution"/>.
            
            C# 12 allowed to alias any type including array types, pointer types, function pointer types,
            tuple types, dynamic types, nint/nuint (with and without runtime support).
            
            Usages of aliases to namespaces and "regular" declared types are transparent and resolved directly an aliased symbol.
            Getting the <see cref="T:JetBrains.ReSharper.Psi.CSharp.DeclaredElements.ISymbolAlias"/> used for resolving a usage of symbol alias
            is possible from a <see cref="T:JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.IResolveInfo"/> through the <see cref="M:JetBrains.ReSharper.Psi.CSharp.Resolve.ResolveInfoWithUsingsExtension.TryGetSymbolAlias(JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.IResolveInfo)"/> extension method.
            
            Usages of aliases to complex types are resolved to a <see cref="T:JetBrains.ReSharper.Psi.CSharp.DeclaredElements.ISymbolAlias"/>.
            </remarks>
            <seealso cref="M:JetBrains.ReSharper.Psi.CSharp.DeclaredElements.AliasedSymbol.IsNamespaceOrRegularDeclaredType"/>
            <seealso cref="M:JetBrains.ReSharper.Psi.CSharp.DeclaredElements.AliasedSymbol.IsRegularDeclaredType(JetBrains.ReSharper.Psi.IDeclaredType@)"/>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.DeclaredElements.ISymbolAlias.ExternAliasName">
            <summary>
            Extern alias used for the aliased symbol.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.DeclaredElements.ISymbolAlias.GetDeclarations">
            <summary>
            Gets declarations of the symbol alias.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.CSharpTypeFactory.CreateDeclaredTypeByTypeKeyword(JetBrains.ReSharper.Psi.Modules.IPsiModule,System.String,JetBrains.Metadata.Reader.API.NullableAnnotation)">
            <summary>typeKeyword should be type of token of one of predefined types.</summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.IRecord">
            <summary>
            Marker interface to detect if some declared element is declared as a C# 9.0 record.
            Only source code declared records do implement IRecord, so use this interface only in source code scenarios.
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.MemberSignatureComparer">
            <summary>
            <para>
            C# 4.0 §10.6: The name, the type parameter list and the formal parameter list of a method define
            the signature (§3.6) of the method. Specifically, the signature of a method consists of its
            name, the number of type parameters and the number, modifiers, and types of its formal
            parameters. For these purposes, any type parameter of the method that occurs in the type of
            a formal parameter is identified not by its name, but by its ordinal position in the type
            argument list of the method. The return type is not part of a method's signature, nor are
            the names of the type parameters or the formal parameters.
            </para>
            <para>
            C# 4.0 §3.6: For the purposes of signatures, the types object and dynamic are considered the
            same. 
            </para>
            <para>
            C# 4.0 §3.6: We implement the rules for ref/out by mapping both to ref. The caller (i.e.
            checking for proper overrides or partial methods, etc) should check that ref/out are
            consistent.
            </para>
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.MemberSignatureComparer.ExplicitImplementationComparer">
            <summary>
            This instance is used when trying to determine if one member explicitly implements another,
            according the C# definition.
            The member signatures are compared without regard to name (including the interface part, if any)
            and the return types must match.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.MemberSignatureComparer.CSharpImplicitImplementationComparer">
            <summary>
            This instance is used when trying to determine if one member implicitly implements another,
            according to the C# definition.
            The member names, parameters, and (return) types must match. Custom modifiers are ignored.
            </summary>
            <remarks>
            One would expect this comparer to have requireSourceMethod = true, but it doesn't because (for source types)
            we allow inexact matching of custom modifiers when computing implicit member implementations. Consider the
            following scenario: interface I has a method M with custom modifiers C1, source type ST includes I in its
            interface list but has no method M, and metadata type MT has a method M with custom modifiers C2.
            In this scenario, we want to compare I.M to MT.M without regard to custom modifiers, because if C1 != C2,
            we can just synthesize an explicit implementation of I.M in ST that calls MT.M.
            </remarks>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.MemberSignatureComparer.CSharpCloseImplicitImplementationComparer">
            <summary>
            This instance is used as a fallback when it is determined that one member does not implicitly implement
            another. It applies a looser check to determine whether the proposed implementation should be reported
            as "close".
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.MemberSignatureComparer.DuplicateSourceComparer">
            <summary>
            This instance is used to determine if two C# member declarations in source conflict with each other.
            Names, arities, and parameter types are considered.
            Return types, type parameter constraints, custom modifiers, and parameter ref kinds, etc are ignored.
            </summary>
            <remarks>
            This does the same comparison that MethodSignature used to do.
            </remarks>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.MemberSignatureComparer.RecordAPISignatureComparer">
            <summary>
            This instance is used to determine if some API specific to records is explicitly declared.
            It is the same as <see cref="F:JetBrains.ReSharper.Psi.CSharp.MemberSignatureComparer.DuplicateSourceComparer"/> except it considers ref kinds as well.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.MemberSignatureComparer.PartialMethodsComparer">
            <summary>
            This instance is used to determine if a partial method implementation matches the definition.
            It is the same as <see cref="F:JetBrains.ReSharper.Psi.CSharp.MemberSignatureComparer.DuplicateSourceComparer"/> except it considers ref kinds as well.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.MemberSignatureComparer.PartialMethodsStrictComparer">
            <summary>
            This instance is used to determine if a partial method implementation matches the definition,
            including differences ignored by the runtime.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.MemberSignatureComparer.InterceptorsComparer">
            <summary>
            Determines if an interceptor has a compatible signature with an interceptable method.
            NB: when a classic extension method is intercepting an instance method call, a normalization to 'ReducedExtensionMethodSymbol' must be performed first.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.MemberSignatureComparer.InterceptorsStrictComparer">
            <summary>
            Determines if an interceptor has a compatible signature with an interceptable method.
            If methods are considered equal by <see cref="F:JetBrains.ReSharper.Psi.CSharp.MemberSignatureComparer.InterceptorsComparer"/>, but not equal by this comparer, a warning is reported.
            NB: when a classic extension method is intercepting an instance method call, a normalization to 'ReducedExtensionMethodSymbol' must be performed first.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.MemberSignatureComparer.CSharpOverrideComparer">
            <summary>
            This instance is used to check whether one member overrides another, according to the C# definition.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.MemberSignatureComparer.CSharpWithTupleNamesComparer">
            <summary>
            This instance checks whether two signatures match including tuples names, in both return type and parameters.
            It is used to detect tuple-name-only differences.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.MemberSignatureComparer.CSharpWithoutTupleNamesComparer">
            <summary>
            This instance checks whether two signatures match excluding tuples names, in both return type and parameters.
            It is used to detect tuple-name-only differences.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.MemberSignatureComparer.CSharpAccessorOverrideComparer">
            <summary>
            This instance is used to check whether one property or event overrides another, according to the C# definition.
            <para>NOTE: C# ignores accessor member names.</para>
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.MemberSignatureComparer.CSharpCustomModifierOverrideComparer">
            <summary>
            Same as <see cref="F:JetBrains.ReSharper.Psi.CSharp.MemberSignatureComparer.CSharpOverrideComparer"/> except that it pays attention to custom modifiers and return type.  
            Normally, the return type isn't considered during overriding, but this comparer is actually used to find
            exact matches (i.e. before tie-breaking takes place amongst close matches).
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.MemberSignatureComparer.RuntimeSignatureComparer">
            <summary>
            This instance is intended to reflect the definition of signature equality used by the runtime 
            (<a href="http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-335.pdf">ECMA-335</a>, Partition I, §8.6.1.6 Signature Matching).
            It considers return type, name, parameters, calling convention, and custom modifiers, but ignores
            the difference between <see cref="!:RefKind.Out"/> and <see cref="!:RefKind.Ref"/>.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.MemberSignatureComparer.RuntimeExplicitImplementationSignatureComparer">
            <summary>
            Same as <see cref="F:JetBrains.ReSharper.Psi.CSharp.MemberSignatureComparer.RuntimeSignatureComparer"/>, but in addition ignores name.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.MemberSignatureComparer.RuntimePlusRefOutSignatureComparer">
            <summary>
            Same as <see cref="F:JetBrains.ReSharper.Psi.CSharp.MemberSignatureComparer.RuntimeSignatureComparer"/>, but distinguishes between <c>ref</c> and <c>out</c>. During override resolution,
            if we find two methods that match except for <c>ref</c>/<c>out</c>, we want to prefer the one that matches, even
            if the runtime doesn't.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.MemberSignatureComparer.RuntimeImplicitImplementationComparer">
            <summary>
            This instance is the same as RuntimeSignatureComparer.
            CONSIDER: just use RuntimeSignatureComparer?
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.MemberSignatureComparer.RetargetedExplicitImplementationComparer">
            <summary>
            This instance is used to search for members that have identical signatures in every regard.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.MemberSignatureComparer.CrefComparer">
            <summary>
            This instance is used for performing approximate overload resolution of documentation
            comment <c>cref</c> attributes. It ignores the name, because the candidates were all found by lookup.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.MemberSignatureComparer.CSharp10MethodGroupSignatureComparer">
            <summary>
            Compare signatures of methods from a method group (only used in logic for older language version).
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.MemberSignatureComparer.MethodGroupSignatureComparer">
            <summary>
            Compare signatures of methods from a method group.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.RefKindCompareMode.DoNotConsiderDifferences">
            <summary>
            Ref parameter modifiers are ignored.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.RefKindCompareMode.ConsiderDifferences">
            <summary>
            Parameters with different ref modifiers are considered different.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.RefKindCompareMode.AllowRefReadonlyVsInMismatch">
            <summary>
            'in'/'ref readonly' modifiers are considered equivalent.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.NullableContext.Default">
            <summary>
            Default in file.
            </summary>
            <remarks>
            Generated files has disabled nullable context by default,
            all other files by default have nullable context specified in project configuration.
            </remarks>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.NullableContext.Enabled">
            <summary>
            Enabled.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.NullableContext.Disabled">
            <summary>
            Disabled.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.NullableContext.Restored">
            <summary>
            Restored to project defaults.
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Parsing.CSharpLexerTypeEvidenceState">
            <summary>
            Allows to check if lexer is currently in a context with evident type e.g. `T x = {here}`.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Parsing.CSharpLexerTypeEvidenceState.State.ID">
            <summary>Type</summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Parsing.CSharpLexerTypeEvidenceState.State.ID_ID">
            <summary>Type x</summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Parsing.CSharpLexerTypeEvidenceState.State.RIGHT_ANGLE">
            <summary>GenericType</summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Parsing.CSharpLexerTypeEvidenceState.State.RIGHT_ANGLE_ID">
            <summary>GenericType x</summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Parsing.CSharpLexerTypeEvidenceState.State.TYPE_KEYWORD">
            <summary>object</summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Parsing.CSharpLexerTypeEvidenceState.State.TYPE_KEYWORD_ID">
            <summary>object x</summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Parsing.CSharpLexerTypeEvidenceState.State.TYPE_FN_LPAR">
            <summary>T Foo(</summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Parsing.CSharpLexerTypeEvidenceState.State.FN_SIGNATURE_END">
            <summary>T Foo()</summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Parsing.CSharpLexerTypeEvidenceState.State.FN_ARG_TYPE">
            <summary>T Foo(U</summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Parsing.CSharpLexerTypeEvidenceState.State.FN_ARG_ATTR_START">
            <summary>T Foo([</summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Parsing.CSharpLexerTypeEvidenceState.State.FN_ARG_ATTR_NAME">
            <summary>T Foo([NotNull</summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Parsing.CSharpLexerTypeEvidenceState.State.FN_ARG_ATTR_END">
            <summary>T Foo([NotNull]</summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Parsing.CSharpLexerTypeEvidenceState.State.FN_ARG_NAME">
            <summary>T Foo(U arg</summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Parsing.CSharpLexerTypeEvidenceState.State.FN_ARG_NAME_COMMA">
            <summary>T Foo(U arg,</summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Parsing.CSharpLexerTypeEvidenceState.State.ACCESSOR">
            <summary>get</summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Parsing.CSharpLexerTypeEvidenceState.State.ACCESSOR_SEMICOLON">
            <summary>get;</summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Parsing.CSharpLexerTypeEvidenceState.State.ACCESSOR_SEMICOLON_RBRACE">
            <summary>get; }</summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Parsing.CSharpLexerTypeEvidenceState.State.EVIDENT_PREFIX">
            <summary>'Type x = ' or 'GenericType x =>' or 'object x ='</summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Parsing.CSharpMissingTokensInserter.PreProcessorParser">
            <summary>
            Try to parse the preprocessor directive from given lexer up to given limit.
            Returns parsed tree node, or <c>null</c> if none
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Parsing.CSharpParser.IsPossibleTypedIdentifierStart(System.Boolean)">
            <returns>
            true if the current token can be the first token of a typed identifier (a type name followed by an identifier),
            false if it definitely can't be,
            null if we need to scan further to find out.
            </returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Parsing.CSharpParser.ParseInitializerAux(JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.CompositeNodeType,JetBrains.ReSharper.Psi.CSharp.Parsing.CSharpParser.InitializerElementParseFunction,JetBrains.ReSharper.Psi.CSharp.Parsing.CSharpParser.ErrorHandle,System.Boolean)">
            <summary>Special variant of parsing routine allowing parsing optional comma</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Parsing.CSharpParser.ParseAttributeList">
            <summary>Special variant of parsing routine allowing parsing optional comma</summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Parsing.CSharpParser.ScanTypeFlags.NotType">
            <summary>Definitely not a type name.</summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Parsing.CSharpParser.ScanTypeFlags.MustBeType">
            <summary>Definitely a type name: either a predefined type (int, string, etc.) or an array type name (ending with a bracket).</summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Parsing.CSharpParser.ScanTypeFlags.GenericTypeOrMethod">
            <summary>Might be a generic (qualified) type name or a method name.</summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Parsing.CSharpParser.ScanTypeFlags.GenericTypeOrExpression">
            <summary>Might be a generic (qualified) type name or an expression or a method name.</summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Parsing.CSharpParser.ScanTypeFlags.NonGenericTypeOrExpression">
            <summary>Might be a non-generic (qualified) type name or an expression.</summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Parsing.CSharpParser.ScanTypeFlags.AliasQualifiedName">
            <summary>A type name with alias prefix (Alias::Name)</summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Parsing.CSharpParser.ScanTypeFlags.NullableType">
            <summary>Nullable type (ending with ?).</summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Parsing.CSharpParser.ScanTypeFlags.PointerOrMultiplication">
            <summary>Might be a pointer type or a multiplication.</summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Parsing.CSharpParser.ScanTypeFlags.TupleType">
            <summary>Might be a tuple type.</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Parsing.CSharpParser.ExpectAsyncModifierKeyword">
            <summary>
            Similar to <see cref="M:JetBrains.ReSharper.Psi.CSharp.Parsing.CSharpParser.ExpectAsyncKeyword"/> but with additional declaration context check:
            if token is 'async' then it also looks ahead for 'async Task()' constructions where 'async' is NOT a keyword
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Parsing.CSharpParser.TryParseLambdaExpression">
            <summary>
            Parse expected lambda expression but assume `x ? () => y :` is a conditional
            expression rather than a lambda expression with an explicit return type and
            return null in that case only.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Parsing.CSharpParser.ParseCRefExpression">
            <remarks>
            Source text must be UNescaped (no xml entities)
            </remarks>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Parsing.CSharpTokenType.EOF">
            <summary>
            Special token for some implementation details.
            It should never be returned from C# lexer
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.PositionalParameterImplementation.GeneratedProperty">
            <summary>
            Implicit `Foo` property generated from `record R(int Foo);`
            `null` if there is a member that matches primary parameter by name and it used insetead of generating the implicit property.
            Implicit generated property may override abstract property from base record type.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.PositionalParameterImplementation.ExplicitDeclarationMember">
            <summary>
            Explicit `Foo` property in `record R(int Foo) { public int Foo { get; } }`
            Explicit `Foo` field in `record R(int Foo) { public int Foo; }`
            Explicit property/field may not actually be initialized by `Foo` primary parameter.
            May be explicit property/field in a base record type.
            `null` if there is no member that matches primary parameter by name and implicit property is generated.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.PositionalParameterImplementation.OverridenBaseProperty">
            <summary>
            Implicit generated property may override abstract property from base record type:
            `abstract record B { public abstract int Foo { get; init; } } + record D(int Foo) : B;`
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.PositionalParameterImplementation.Substitution">
            <summary>
            Substition for use with `ExplicitDeclarationMember`/`OverridenBaseProperty`,
            since those members can be from base (possibly generic) record type.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.Resolve.ICSharpDocCommentReference.LocalOffset">
            <summary>
            Offset of the reference start from the comment
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Resolve.ICSharpDocCommentReference.GetSignatureRange">
            <summary>
            Obtains the range of the signature (i.e (...))
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Resolve.IResolvePatcher.PatchResolve(JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceName,JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.IResolveInfo@)">
            <summary>
            Overrides default resolve algorithm for given IReferenceName
            </summary>
            <param name="referenceName">reference to resolve</param>
            <param name="errorType"></param>
            <returns>result of resolution, or <c>null</c> to resolve reference by default algorithm</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.BetterFunctionMemberSelector.IsBetterFunctionMember(JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.ApplicableCandidate,JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.ApplicableCandidate,JetBrains.ReSharper.Psi.Modules.IPsiModule,JetBrains.ReSharper.Psi.Resolve.Managed.IResolveContext,JetBrains.ReSharper.Psi.CSharp.CSharpLanguageLevel,JetBrains.ReSharper.Psi.CSharp.CSharpLanguageLevel)">
            <summary>
            "better function member" is defined in "C# Language Specification", 14.4.2.2
            NOTE: Both methods should be applicable!
            </summary>
            <returns>
            returns +1 if method1 is better function member for arguments
            returns -1 if candidate2 is better function member for arguments
            returns 0 otherwise
            </returns>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Resolve.TypeInference.CSharpTypeInferenceUtil.EqualsIgnoringDynamicTupleNamesAndNullabilityComparer">
            <summary>
            This is a comparer that ignores differences in dynamic-ness and tuple names.
            But it has a special case for top-level object vs. dynamic for purpose of method type inference.
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Types.IAnyExpressionType">
            <summary>
            The type of 'var x' declaration expression in 'M(out var x)'
            The type of '_' reference expression in 'M(out _)' and '(_, _) = tuple'
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Types.IInterpolatedStringConcatenationType">
            <summary>
            Type of interpolated string concatenations e.g. ($"string1" + $"string2") + $"string3"
            </summary>
            <remarks>
            Natural type is 'string'.
            Implicitly convertible to interpolated string handler types.
            No conversion to 'IFormattable'/'FormattableString'.
            </remarks>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Util.ArgumentsUtil.IsValidParams(JetBrains.ReSharper.Psi.IParameter,JetBrains.ReSharper.Psi.Modules.IPsiModule)">
            <summary>
            We're ignoring 'params' modifier on a parameters, which are called from a different module of a C#12 or lower language version
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Util.BooleanCheckUtil.TryGetStatementExecutedAfterLastExpressionInCondition(JetBrains.ReSharper.Psi.CSharp.Tree.IIfStatement,System.Boolean,JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression@,JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression@,JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpStatement@,System.Boolean@)">
            <summary>
            Checks for patterns like
            <code>if (b1 &amp;&amp; ... &amp;&amp; lastExpression) { ... } else { ... }</code>
            or
            <code>if (b1 &amp;&amp; ... &amp;&amp; !lastExpression) { ... } else { ... }</code>
            or
            <code>if (b1 || ... || lastExpression is false) { ... } else { ... }</code> etc.
            and finds the statement or expression (`Then` or `Else` or effective `Else`) that is executed right after `lastExpression` check with
            <paramref name="targetValueOfLastExpression"/> target value with a guarantee that check over `lastExpression` is actually performed.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Util.BooleanCheckUtil.TryGetExpressionExecutedAfterLastExpressionInCondition(JetBrains.ReSharper.Psi.CSharp.Tree.IConditionalTernaryExpression,System.Boolean,JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression@,JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression@,JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression@,System.Boolean@)">
            <inheritdoc cref="M:JetBrains.ReSharper.Psi.CSharp.Util.BooleanCheckUtil.TryGetStatementExecutedAfterLastExpressionInCondition(JetBrains.ReSharper.Psi.CSharp.Tree.IIfStatement,System.Boolean,JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression@,JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression@,JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpStatement@,System.Boolean@)"/>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Util.BooleanCheckUtil.TryGetTargetBranch(JetBrains.ReSharper.Psi.Parsing.TokenNodeType,JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression,System.Boolean,JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression@,JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression@)">
            <returns>
            `true`, if target branch is `Then`
            `false`, if target branch is `Else`
            `null`, if can't find target branch
            </returns>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Util.CancellationTypeUtil.ourLifetimeTypeName">
            <summary>
            'JetBrains.Lifetimes.Lifetime' is implicitly convertible to 'CancellationToken' type.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Util.CharacterLiteralUtil.TryUnescapeChar(System.Char,JetBrains.ReSharper.Psi.CSharp.CSharpLanguageLevel,System.String@)">
            <param name="escapeKeyChar">
              A character after the backslash to interpret. E.g. 'n' from '\n'.
              Unicode escapes like '\u' and other will result in returning of <c>false</c>.
            </param>
            <param name="languageLevel">C# language level; omit for 'latest' and parsing forward-compatible.</param>
            <param name="unescapedChar">Resulting one-char string (in order to make is intern-able).</param>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Util.CollectionExpressionPresenceChecker">
            <summary>
            Allows to check whether the file or a closed chameleon node contains possibly contains a collection expression.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Util.ConfigureAwaitType.CaptureContext">
            <summary>
            Means that synchronization context will be captured (if exists) and the continuation will be marshaled back to it. 
            Corresponds to `.ConfigureAwait(true)` and `.ConfigureAwait(ConfigureAwaitOptions.ContinueOnCapturedContext)`
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Util.ConfigureAwaitType.DoNotCaptureContext">
            <summary>
            Means that synchronization context will not be captured.
            Corresponds to `.ConfigureAwait(false)` and `.ConfigureAwait(ConfigureAwaitOptions.None)`
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Util.ConfigureAwaitType.OnlyContextCapturingConfiguration">
            <summary>
            Means that `ConfigureAwait` invocation can only configure context capturing behavior.
            Corresponds to `.ConfigureAwait(bool)` with any boolean value and to the `.ConfigureAwait(ConfigureAwaitOptions)` when it only
            contains `ConfigureAwaitOptions.None` or `ConfigureAwaitOptions.ContinueOnCapturedContext`
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Util.ConfigureAwaitType.Any">
            <summary>
            Corresponds to any `ConfigureAwait` invocation, such as `.ConfigureAwait(ConfigureAwaitOptions.SuppressThrowing)`,
            `ConfigureAwait(ConfigureAwaitOptions.ForceYielding | ConfigureAwaitOptions.ContinueOnCapturedContext)`, etc.
            Note, that it can significantly change semantics. For example, `ConfigureAwaitOptions.SuppressThrowing` will suspend exception propagation
            and the exception will be only accessible using the original `Task` object.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Util.ConfigureAwaitUtil.GetConfigureAwaitMethod(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTreeNode,JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression)">
            <summary>
            Returns .ConfigureAwait(bool) method if it exists for specified <paramref name="taskExpression"/>
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Util.ContextualKeywordUtil.InsideAccessor(JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Determines whether element is inside setter/adder/remover
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Util.CSharpAttributeUtil.BuildAttributeSectionGroup(System.Collections.Generic.IEnumerable{JetBrains.ReSharper.Psi.CSharp.Tree.IAttributeSection})">
            <summary>
            Divide attribute sections into groups with the same target
            </summary>
            <param name="sections">Plain array of sections</param>
            <returns>Groups of attribute sections with the same target</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Util.CSharpCollectionTypeUtil.ElementTypeByCollectionType(JetBrains.ReSharper.Psi.IType,JetBrains.ReSharper.Psi.Resolve.IAccessContext,JetBrains.ReSharper.Psi.Tree.ITreeNode,System.Boolean)">
            <summary>
            Returns element type if collection type is a collection type (described in specification, 15.8.4)
            otherwise, returns null
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Util.CSharpDeclaredElementUtil.IsCSharpTypeMember(JetBrains.ReSharper.Psi.ITypeMember)">
            <summary>
            Check if the member is visible as C# type member
            I.e. it skips accessors except to properties with parameters
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Util.CSharpDeclaredElementUtil.IsClosureVariable(JetBrains.ReSharper.Psi.IDeclaredElement,JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression)">
            <summary>
            Check if given declared element is part of closure in respect to given access expression
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Util.CSharpExpressionUtil">
            <summary>
            Utility class for working with expressions
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Util.CSharpExpressionUtil.IsCondition(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression,JetBrains.ReSharper.Psi.IOperator@,JetBrains.ReSharper.Psi.IConversionOperator@)">
            <summary>
            Check if the expression could be used as boolean condition,
            i.e. implicitly convertible to <c>bool</c>, or contains <c>true</c>/<c>false</c> operators.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Util.CSharpExpressionUtil.GetOperandThroughParenthesis(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression)">
            <summary>
            Unwraps expression from parenthesis and parentheses-like expressions namely checked(), unchecked() and ! (nullable warning suppression)
            If semantics such as overflow checks or nullability warnings/errors should be preserved use <see cref="M:JetBrains.ReSharper.Psi.CSharp.Util.CSharpExpressionUtil.GetOperandThroughParenthesisStrict(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression)"/>
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Util.CSharpExpressionUtil.GetOperandThroughParenthesisStrict(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression)">
            <summary>
            Unwraps expression from parenthesis.
            If you need to also unwrap it from other parentheses-like expressions that might change semantics
            such as checked(), unchecked() and ! (nullable warning suppression) use <see cref="M:JetBrains.ReSharper.Psi.CSharp.Util.CSharpExpressionUtil.GetOperandThroughParenthesis(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression)"/>
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Util.CSharpExpressionUtil.NeedToParenthesize(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression,JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression)">
            <summary>
            Check if this expression should be enclosed in parentheses if it will be replaced by 'newExpression'
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Util.CSharpExpressionUtil.IsCheckOfCodeInvariant(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression)">
            <summary>
            Check if this expression is precondition, i.e. something like
            <code>
            Logger.Assert(nonNullableEntity != null, "The condition (nonNullableEntity != null) is false.");
            -or-
            if (nonNullableEntity == null)
                throw Exception();
            -or-
            if (nonNullableEntity == null)
            Logger.LogError();
            </code>
            At the beginning of the method
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Util.CSharpExpressionUtil.IsCheckOfCodeInvariant(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpStatement)">
            <summary>
            Check if this expression is precondition, i.e. something like
            <code>
            Logger.Assert(nonNullableEntity != null, "The condition (nonNullableEntity != null) is false.");
            -or-
            if (nonNullableEntity == null)
                throw Exception();
            -or-
            if (nonNullableEntity == null)
            Logger.LogError();
            </code>
            At the beginning of the method
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Util.CSharpExpressionUtil.GetRuntimeExpressionType(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression)">
            <summary>
            Tries to guess expression type which will be at runtime.
            Usually returns expression.GetExpressionType, but recognize few special cases
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Util.CSharpExpressionUtil.IsInContextWhereTargetTypeIsInSteadyState(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression)">
            <summary>
            For cases like `UnresolvedInvocation([no, target, type, yet])`.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Util.CSharpExpressionUtil.GetReferenceKind(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression)">
            <summary>
            Port of Roslyn's BoundExpressionExtensions.GetRefKind.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Util.CSharpExpressionUtil.GetReferenceKind(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression,JetBrains.ReSharper.Psi.Resolve.Managed.IResolveContext)">
            <summary>
            Port of Roslyn's BoundExpressionExtensions.GetRefKind.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Util.CSharpOperatorUtil.CheckCustomConversionValidity(JetBrains.ReSharper.Psi.IType,JetBrains.ReSharper.Psi.IType)">
            <summary>
            Check that any custom conversion operator could exist from <paramref name="source"/> to <paramref name="target"/>
            According to C# specs 17.9.3. Both <paramref name="source"/> and <paramref name="target"/> should be unlifted
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Util.CSharpStringLiteralParser.CharSequence.#ctor(System.String)">
            <summary>
            Creates a new instance of CharEscape
            </summary>
            <param name="hex"></param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Util.CSharpTypeUtil.RequiresUnsafeContext(JetBrains.ReSharper.Psi.IType,JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Checks if the specified type requires unsafe context.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Util.CSharpTypeUtil.RequiresUnsafeContext(JetBrains.ReSharper.Psi.IType,JetBrains.ReSharper.Psi.CSharp.CSharpLanguageLevel)">
             <summary>
             Checks if the specified type requires unsafe context.
             </summary>
             <remarks>
             Before C# 12 compiler checked only for pointer/function pointer types and arrays of pointers
             and didn't check deeper (e.g. pointers inside type arguments 'List&lt;int*[]&gt;').
            
             C# 12 compiler fixes this behavior and performs the deep check for pointer types.
             However Roslyn does it disregarding the language version flag except in inside of type argument list.
             The backward compatibility is inconsistent but Roslyn is not going to fix it (https://github.com/dotnet/roslyn/issues/69422).
             </remarks>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Util.CSharpTypeUtil.IsUnmanagedType(JetBrains.ReSharper.Psi.IType,JetBrains.ReSharper.Psi.CSharp.CSharpLanguageLevel)">
            <summary>
            Check if this type is unmanaged type:
            * sbyte, byte, short, ushort, int, uint, long, ulong, char, float, double, decimal, or bool.
            * Any pointer-type.
            * Any enum-type.
            * Any user-defined struct-type that contains fields of unmanaged-types only
            * A type parameter with 'unmanaged' constraint
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Util.CSharpTypeUtil.CanUseExplicitly(JetBrains.ReSharper.Psi.IType,JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Check that type can be declared explicitly in code
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Util.CSharpTypeUtil.IsVariantSafe(JetBrains.ReSharper.Psi.IType,JetBrains.ReSharper.Psi.TypeParameterVariance,System.Func{JetBrains.ReSharper.Psi.ITypeParameter,JetBrains.ReSharper.Psi.TypeParameterVariance})">
            <summary>
            C# specs 23.5: Check type for variance safety
            </summary>
            <returns>
            <list type="bullet">
            <item><description>Empty enumerable if type passes variance check</description></item>
            <item><description>Pairs of type parameter and necessary variance if type failed check</description></item>
            </list>
            </returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Util.CSharpTypeUtil.CanDeclareVolatileFieldWith(JetBrains.ReSharper.Psi.IType)">
            <summary>
            C# specs "10.5.3 Volatile fields"
            • A reference-type.
            • The type byte, sbyte, short, ushort, int, uint, char, float, bool, System.IntPtr, or System.UIntPtr.
            • An enum-type having an enum base type of byte, sbyte, short, ushort, int, or uint.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.DecisionDagBuilder.CheckInputRelation(JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.DagState,JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.Nodes.DagTest,JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.Nodes.DagTest,JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.Tests@,JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.Tests@)">
            <summary>Returns true if the tests are related i.e. they have the same input, otherwise false.</summary>
            <param name="relationCondition">The pre-condition under which these tests are related.</param>
            <param name="relationEffect">A possible assignment node which will correspond two non-identical but related test inputs.</param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.StateForCase.IsFullyMatched(JetBrains.ReSharper.Psi.Resolve.Managed.IResolveContext)">
            <summary>
            Is the pattern in a state in which it is fully matched and there is no when clause?
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.StateForCase.PatternIsSatisfied">
            <summary>
            Is the pattern fully matched and ready for the when clause to be evaluated (if any)?
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.StateForCase.IsImpossible">
            <summary>
            Is the clause impossible?  We do not consider a when clause with a constant false value to cause the branch to be impossible.
            Note that we do not include the possibility that a when clause is the constant false.  That is treated like any other expression.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.StateForCase.RewriteNestedLengthTests">
            <inheritdoc cref="M:JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.Tests.RewriteNestedLengthTests"/>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.Tests.RewriteNestedLengthTests">
            <summary>
            Rewrite nested length tests in slice subpatterns to check the top-level length property instead.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.IValueSet.GetSample(JetBrains.ReSharper.Psi.Modules.IPsiModule)">
            Produce a sample value contained in the set. 'ArgumentException' if the set is empty. If the set
            contains values but we cannot produce a particular value (e.g. for the set 'nint > int.MaxValue'), returns null.
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Util.GeneratedAndCanBeIgnoredMethodsDetector">
            <summary>
            Detects generated C# code in Razor codebehind tree
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Util.InvocationExpressionUtil.IsSkippedByCompiler(JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.ResolveResultWithInfo,JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression)">
            <summary>
            Returns <c>true</c> if this invocation is skipped by compiler,
            because of partial method without implementation, or conditional method
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Util.Literals.CSharpLiteralWrapper">
            <summary>
            Provides validation and conversion of string literals.
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Util.Literals.ICSharpLiteralWrapper">
            <summary>
            Provides validation and conversion of string literals.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Util.Literals.Impl.RawStringLexerBase.State.StartDelimiter">
            <summary>
            """
            ^
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Util.Literals.Impl.RawStringLexerBase.State.IgnoreUntilLineBreak">
            <summary>
            """...
               ^
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Util.Literals.Impl.RawStringLexerBase.State.Indent">
            <summary>
            """
               text
            ^
               """
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Util.Literals.Impl.RawStringLexerBase.State.Content">
            <summary>
            """
               text
               ^
               """
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Util.Literals.Impl.RawStringLexerBase.State.InterpolationStart">
            <summary>
            {{
            ^
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Util.Literals.Impl.RawStringLexerBase.State.InterpolationEnd">
            <summary>
            }}
             ^
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Util.Literals.Impl.RawStringLexerBase.State.LineBreakAfterContent">
            <summary>
            """
               text
               more text
                        ^
               """
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Util.Literals.Impl.RawStringLexerBase.State.EndDelimiter">
            <summary>
            """
               text
               """
               ^
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Util.Literals.Impl.RawStringLexerBase.State.Stop">
            <summary>
            """
               text
               """
                  ^
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CSharp.Util.Literals.Impl.RawStringLexerBase.State.Invalid">
            <summary>
            Invalid token from a current position
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Util.LocalFunctionAnalysis`3">
            <summary>
            Provides API to traverse local functions' calls and caches results when it's possible.
            
            Handles unfinished, recursive and mutually recursive local functions.
            Regular recursion and non-recursive interprocedure calls do not affect the complexity.
            
            Common case without mutual recursion is O(N). 
            Worst case where each pair of local functions is mutually recursive is O(N^2)
            
            Local1();            - push to call stack and analyze
                Local2();        - push to call stack and analyze 
                    Local3();    - push to call stack and analyze
                       Local2(); - use 'recursive' info and mark Local3 as not finished, cache it temporarily
                    Local3();    - use temporarily cached 'Local3'
                    Local3();    - use temporarily cached 'Local3'
                                 - drop temporariy cache
                Local1();        - use 'recursive' info
                Local2();        - use cached info for Local2 (already processed in its previous call)
                Local3();        - push to call stach and analyze (temporary cache has been dropped)
                    Local2();    - use cached info
            Local1();            - use cached info
            Local2();            - use cached info
            Local3();            - use cached info
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CSharp.Util.NullChecks.NullCheckData.IsPredefined">
            <summary>
            True for reference equality and a few known ways of null checking
              e.g. equality operators with known behavior, Nullable.HasValue.
            
            False if null check may have side effects or return unexpected result
              e.g. is user defined or dynamic.
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Util.ObjectCreationToTupleExpressionConverter">
            <summary>
            Converter from an object creation expression creating a 'ValueTuple' instance into a tuple expression.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Util.StatementUtil.EnsureHasExplicitAccessorDeclarations(JetBrains.ReSharper.Psi.CSharp.Tree.IAccessorOwnerDeclaration)">
            <summary>
            Turns properties/indexers without accessor declarations (like 'string Text => _text;') into ordinary
            property/indexer with accessor holder ('string Text { get => _text; }'), so it would be safe to
            iterate over <see cref="P:JetBrains.ReSharper.Psi.CSharp.Tree.IAccessorOwnerDeclaration.AccessorDeclarations"/> collections.
            </summary>
            <remarks>
            This method do not adds accessors if there were no accessors previously,
            however unfinished expression body (like 'string Text =>') would produce getter declaration.
            </remarks>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Util.StatementUtil.EnsureStatementInBlock(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpStatement)">
            <summary>
            Ensures there is a block around passed statement. Preserves statement node identity and validity
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Util.StatementUtil.EnsureStatementInStatementsOwner(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpStatement)">
            <summary>
            Ensures there is a statement owner (block or 'switch' section) around passed statement.
            Preserves statement node identity and validity
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Util.StatementUtil.EnsureExpressionInStatement(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression)">
            <summary>
            Ensures there is a state containing passed expression, possibly converting containing expression-bodied
            lambda-expression or type member in statement-bodied form. Preserves expression node identity and validity
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Util.TargetTypedExpressionPresenceChecker">
            <summary>
            Provides base functionality to check if file or a closed chameleon node contains a specific kind of expression.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Util.TargetTypedExpressionPresenceChecker.IsRequiredExpression(JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression@)">
            <summary>
            Checks whether the given node is the required one.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Util.TargetTypedExpressionPresenceChecker.CheckClosedChameleonNode(JetBrains.ReSharper.Psi.Parsing.ILexer,System.Boolean@)">
            <summary>
            Checks if a closed chameleon node possibly contains the required expression.
            </summary>
            <param name="lexer">Lexer of a closed chameleon node.</param>
            <param name="evidentOnly">true if required expression is found only in type-evident contexts; otherwise false.</param>
            <returns>Value indicating whether the closed chameleon node possibly contains a required expression.</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Util.TargetTypedExpressionPresenceChecker.PossiblyContains(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpFile,System.Boolean@)">
            <summary>
            Checks whether the file possibly contains the required expression.
            </summary>
            <param name="file">A file to search in.</param>
            <param name="evidentOnly">true if required expression is found only in type-evident contexts; otherwise false.</param>
            <returns>Value indicating whether the file possibly contains a required expression.</returns>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Util.TargetTypedNewPresenceChecker">
            <summary>
            Allows to check whether the file or a closed chameleon node contains possibly contains a target-typed new expression.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Util.TypeCheckStaticAnalysisUtil.CompileTimeResultImpl(JetBrains.ReSharper.Psi.IExpressionType,JetBrains.ReSharper.Psi.IType,JetBrains.ReSharper.Psi.CSharp.Conversions.ICSharpTypeConversionRule,JetBrains.ReSharper.Psi.CSharp.Util.TypeCheckStaticAnalysisKind,JetBrains.ReSharper.Psi.CSharp.CSharpLanguageLevel)">
            <summary>According to C# specs 7.10.10 + improvisation for pattern-matching</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Util.UnsafeCodeUtil.IsExpressionClassifiedAsMoveable(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression,JetBrains.Util.IUserDataHolder)">
            <summary>
            Checks to see whether an expression is a "moveable" variable according to the spec. Moveable
            variables have underlying memory which may be moved by the runtime. The spec defines anything
            not fixed as moveable and specifies the expressions which are fixed.
            </summary>
            <param name="expression">Expression classified as mutable or read-only variable.</param>
            <param name="cache">Cache to share closure variables</param>
            <remarks>
            * C# specification 18.3 "Fixed and movable variables"
            * handling of C# 7.x features like 'in'-parameters, 'ref'/'ref readonly' variables
            * C# 7.3 introduced new rule for moveability of pointer element access (see https://github.com/dotnet/roslyn/pull/28527/)
            </remarks>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Util.UsingAliasUtil.IsAccessableFrom(JetBrains.ReSharper.Psi.CSharp.DeclaredElements.ISymbolAlias,JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Checks whether the symbol alias is accessible in a given context.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Util.UsingAliasUtil.FindTypeAliasUsageOpportunities(JetBrains.ReSharper.Psi.CSharp.DeclaredElements.ISymbolAlias,JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Finds nodes which can be replaced with the alias.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Util.UsingAliasUtil.GetAliasedSymbolPresencePredicate(JetBrains.ReSharper.Psi.CSharp.DeclaredElements.ISymbolAlias)">
            <summary>
            Gets the predicate to check if a source file can contain the aliased symbol.
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.Util.UsingAliasUtil.SymbolEquivalenceChecker">
            <summary>
            Checks if a node refers to the original aliased symbol.
            </summary>
            <remarks>
            Nodes refering to some symbol alias aren't considered equivalent
            to the original aliased symbol because we don't want to replace
            one symbol alias with another.
            </remarks>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Util.UsingAliasUtil.CollectAliasesInFile(JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpFile)">
            <summary>
            Collects names and aliased symbol names of using aliases in file.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CSharp.Util.XmlDocTemplateUtil.GetDocTemplate(JetBrains.ReSharper.Psi.Tree.IDocCommentBlockOwner,System.Int32@)">
            <summary>
            Get the empty XML doc template for the given element.
            </summary>
            <returns>
            XML text without any comments (i.e. "///") and initial cursor position.
            </returns>
        </member>
    </members>
</doc>
