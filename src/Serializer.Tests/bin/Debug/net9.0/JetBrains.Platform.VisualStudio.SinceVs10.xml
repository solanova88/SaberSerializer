<?xml version="1.0"?>
<doc>
    <assembly>
        <name>JetBrains.Platform.VisualStudio.SinceVs10</name>
    </assembly>
    <members>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.BuildScript.PreCompile.VsManagedProjectsDevKit10.MefAssemblySimpleName">
            <summary>
            Name of the main MEF assembly, might be used for detecting of MEF-awareness of a project.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.BuildScript.PreCompile.VsManagedProjectsDevKit10.InvalidateMefWhenRebuilding(JetBrains.Application.BuildScript.Solution.AllAssembliesOnEverything,JetBrains.Application.BuildScript.Solution.AllAssembliesOnSources,JetBrains.VsIntegration.BuildScript.InstalledVsVersionsArtifact,JetBrains.Application.BuildScript.ProfileNameArtifact)">
            <summary>
            When a MEF-exposed project gets recompiled, we should mark it as dirty for VS MEF to recalculate its components on startup, otherwise we'd see exceptions and empty editors on the first run.
            This tries to filter MEF-exposed projects (by DLL references) and VS instances which have something in the root suffix named after the current profile.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.BuildScript.PreCompile.VsManagedProjectsDevKit10.EnumMefAwareProjects(System.Collections.Generic.IEnumerable{JetBrains.Application.BuildScript.Solution.SubplatformProjectWrapper})">
            <summary>
            Filters out projects which have refs to MEF assembly. Supposing MEF is only interested in these (at least that's how we filter out assemblies for registering them in VSIX manifest).
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Shell.PerformanceGuide.PerformanceGuideSettingsPageView">
            <summary>
            PerformanceGuideSettingsPageView
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.PerformanceGuide.PerformanceGuideSettingsPageView.InitializeComponent">
            <summary>
            InitializeComponent
            </summary>
        </member>
        <member name="P:JetBrains.Platform.VisualStudio.SinceVs10.Shell.PerformanceGuide.AntivirusCpuImpact.RecordEnabled">
            <summary>
            By default the cpu usage will not be recorded. If you want to record call <see cref="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.PerformanceGuide.AntivirusCpuImpact.Record(JetBrains.Lifetimes.Lifetime)"/> with a appropriate lifetime
            </summary>
        </member>
        <member name="P:JetBrains.Platform.VisualStudio.SinceVs10.Shell.PerformanceGuide.AntivirusCpuImpact.LastBuild">
            <summary>
            Stores the antivirus CPU usage during the last build
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.PerformanceGuide.AntivirusCpuImpact.Record(JetBrains.Lifetimes.Lifetime)">
            <summary>
            Enables the recorder
            </summary>
            <param name="lifetime"></param>
        </member>
        <member name="P:JetBrains.Platform.VisualStudio.SinceVs10.Shell.PerformanceGuide.AntivirusCpuImpact.AvImpactRecord.Product">
            <summary>
            Presentable product name
            </summary>
        </member>
        <member name="P:JetBrains.Platform.VisualStudio.SinceVs10.Shell.PerformanceGuide.AntivirusCpuImpact.AvImpactRecord.Process">
            <summary>
            Process name with .exe specifier
            </summary>
        </member>
        <member name="P:JetBrains.Platform.VisualStudio.SinceVs10.Shell.PerformanceGuide.AntivirusCpuImpact.AvImpactRecord.P25CpuPercent">
            <summary>
            First quartile of AV process CPU usage percentage
            </summary>
        </member>
        <member name="P:JetBrains.Platform.VisualStudio.SinceVs10.Shell.PerformanceGuide.AntivirusCpuImpact.AvImpactRecord.MedianCpuPercent">
            <summary>
            Second quartile of AV process CPU usage percentage
            </summary>
        </member>
        <member name="P:JetBrains.Platform.VisualStudio.SinceVs10.Shell.PerformanceGuide.AntivirusCpuImpact.AvImpactRecord.P75CpuPercent">
            <summary>
            Third quartile of AV process CPU usage percentage
            </summary>
        </member>
        <member name="P:JetBrains.Platform.VisualStudio.SinceVs10.Shell.PerformanceGuide.AntivirusCpuImpact.AvImpactRecord.AverageCpuPercent">
            <summary>
            Average of AV process CPU usage percentage
            </summary>
        </member>
        <member name="P:JetBrains.Platform.VisualStudio.SinceVs10.Shell.PerformanceGuide.AntivirusCpuImpact.AvImpactRecord.MeasuresCount">
            <summary>
            Total amount of samples
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Shell.PerformanceGuide.AntivirusDetector">
            <summary>
            Provides wrapper around WMI security center interface to query information about antiviruses
            </summary>
            <remarks>
             WMI subsystem can throw <exception cref="T:System.AccessViolationException" /> if access policy forbid access to it, you
             have process them in clients yourself.
            </remarks>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.PerformanceGuide.AntivirusDetector.QueryAntiviruses">
             <summary>
             Query WMI interface for antiviruses
            
             NOTE: Windows 7 doesn't not consider Defender as an antivirus. Only custom installed products will be listed here.
             </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.PerformanceGuide.AntivirusDetector.QueryDefenderPreferences">
            <summary>
            Query Windows Defender settings
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.PerformanceGuide.AntivirusDetector.TryGetPrimaryAntivirus">
            <summary>
            Get single enabled antivirus 
            </summary>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Shell.PerformanceGuide.AntivirusDetector.AVState">
            <summary>
            Describes state of installed antivirus
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.Shell.PerformanceGuide.DefenderCpuBuildImpactDetector.CollectSamplesInternalMs">
            <summary>
            Defines how often to sample CPU usage by Windows Defender
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.Shell.PerformanceGuide.DefenderCpuBuildImpactDetector.CollectSamplesDelayMs">
            <summary>
            Performance counters collection is rather expensive to setup, but cheap to collect. It does not make much sense
            to measure the defender's impart on a small solutions when build can finish in less than seconds. 
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.Shell.PerformanceGuide.DefenderCpuBuildImpactDetector.myDisable">
            <summary>
            Performance counters may be disabled by group politics or not available for unknown reason.
            To avoid further calling them when they are not available set this value to true.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.PerformanceGuide.DefenderCpuBuildImpactDetector.CollectSamples(JetBrains.Lifetimes.Lifetime)">
            <summary>
            Start collecting CPU usages samples for a specified lifetime
            </summary>
            <param name="lifetime"></param>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Shell.AssertionModeInitializerRef">
            <summary>
            A module-initializer method in class which inherits module initializer from Core project will force loading Core
            module and invoking module initializer from there.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Diagnostics.AddVsErrorsToLog">
            <summary>
            Receives information on VS exceptions and write it to our log.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.ExclusionFlags.ExcludeOwnVersion">
            <summary>
            <para>Don't return the extension of the current version of the current product (only return other versions).</para>
            <para>Note that there might be multiple registrations for this version in different locations, but we cannot know which one is better (or currently running), so either all or non can be included.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.ExclusionFlags.ExcludePerMachineLocation">
            <summary>
            Don't return per-machine extensions (they're all-users-all-hives).
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.ExclusionFlags.ExcludePerUserPerHiveLocations">
            <summary>
            Don't return per-user-per-hive locations in various appdata folders.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.MsiExtensionManifestInstaller">
            <summary>
            For MSI-based installs of METH-aware products, emits the Extension Manifest to the Bin folder and creates a shortcut to it from the VS InstallDir.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.PackageDefWriter">
            <summary>
            Writes the VS PkgDef file from the product <see cref="T:JetBrains.Application.Install.InstallationData.InstallationData"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.PackageDefWriter.IsPackageDefFile">
            <summary>
            <see cref="F:JetBrains.Application.Install.InstallationData.InstalledFile.Metadata"/> entry key for files that should be referenced in VSIX Manifest as PackageDef files.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.PackageDefWriter.Install(JetBrains.Application.Install.InstallationData.InstallationData,JetBrains.Util.DevEnv.IVsEnvironmentInformation,System.IO.TextWriter,System.Collections.Generic.Dictionary{JetBrains.Application.Install.InstallationData.InstallationMacroName,System.String})">
            <summary>
            Writes the product VS-specific Registry keys that go under the VS Registry hive into the PkgDef file.
            </summary>
            <param name="data">Installation Data.</param>
            <param name="vsenv"></param>
            <param name="writer">The output stream.</param>
            <param name="macrosOverride">Optional override for select <see cref="T:JetBrains.Application.Install.InstallationData.InstallationMacroName"/> macro values.</param>
            <returns>Returns what Registry data could not be put into PkgDef.</returns>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.PackageDefWriter.CollectEntries(JetBrains.Application.Install.InstallationData.InstallationData,JetBrains.Util.DevEnv.IVsEnvironmentInformation,System.Collections.Generic.IDictionary{JetBrains.Util.BackSlashSeparatedRelativePath,System.Collections.Generic.Dictionary{System.String,System.Object}})">
            <summary>
            Collect all non-duplicate Registry entries for writing into pkgdef.
            Returns what Registry data could not be put into PkgDef.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.PackageDefWriter.CreatePkgDefMacros(System.Collections.Generic.Dictionary{JetBrains.Application.Install.InstallationData.InstallationMacroName,System.String})">
            <summary>
            In addition to the externally defined macros, adds PkgDef-specific substitutions to be resolved when reading the PkgDef in Visual Studio.
            </summary>
            <param name="macrosOverride"> </param>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.PackageDefWriter.FormatForReg(System.Collections.Generic.IDictionary{JetBrains.Util.BackSlashSeparatedRelativePath,System.Collections.Generic.Dictionary{System.String,System.Object}})">
            <summary>
            Prepares entries for writing to the Reg file "as is", converting the values to strings and escaping the strings.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.PackageDefWriter.SubstituteMacros(System.Collections.Generic.IDictionary{JetBrains.Util.BackSlashSeparatedRelativePath,System.Collections.Generic.Dictionary{System.String,System.Object}},System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Applies macro substitutions to the entries and prepares them for writing into the REG file.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.PackageDefWriter.WriteReg(System.Collections.Generic.IDictionary{System.String,System.Collections.Generic.Dictionary{System.String,System.String}},System.IO.TextWriter)">
            <summary>
            Dumps the strings that are ready for writing.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.PackageDefWriter.PkgDefMacros">
            <summary>
            Macros that can be used in the form of <c>$MacroName$</c> within a pkgdef file.
            Taken from the <c>"PkgDef Management Design.docx"</c> classified document.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.PackageDefWriter.PkgDefMacros.AppDataLocalFolder">
            <summary>
            Path to the sub-folder of CSIDL_LOCAL_APPDATA used by this application – based on the user settings root (e.g. “C:\Users\{user}\AppData\Local\VisualStudio\10.0”).
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.PackageDefWriter.PkgDefMacros.AppName">
            <summary>
            Name of the Boutique application (not defined for other appids).
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.PackageDefWriter.PkgDefMacros.BaseInstallDir">
            <summary>
            Synonym for ShellFolder for backward compatibility.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.PackageDefWriter.PkgDefMacros.CommonFiles">
            <summary>
            Path to the common files folder for the application (i.e., value of CSICL_PROGRAM_FILES_COMMON) (e.g., “C:\ProgramData\VisualStudio\10.0”)
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.PackageDefWriter.PkgDefMacros.HivelessRootKey">
            <summary>
            Same as RootKey, without the HKEY_CURRENT_USER portion.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.PackageDefWriter.PkgDefMacros.MyDocuments">
            <summary>
            Path to the user’s Documents folder (e.g., “C:\Users\{user}\Documents”).
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.PackageDefWriter.PkgDefMacros.PackageFolder">
            <summary>
            Folder in which the PkgDef file was found.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.PackageDefWriter.PkgDefMacros.ProgramFiles">
            <summary>
            Parent folder for all program installations (e.g., “C:\Program Files”)
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.PackageDefWriter.PkgDefMacros.RootFolder">
            <summary>
            Path to the root of the application installation; for Visual Studio and the Express SKUs, this is the same as ShellFolder; for Boutique applications (Isolated shell) this is a different folder, specific to the application. In the latter case, the value is read from HKEY_LOCAL_MACHINE\{registry root}\RootFolder.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.PackageDefWriter.PkgDefMacros.RootKey">
            <summary>
            Parent key for all Configuration values (e.g. “HKEY_CURRENT_USER\Software\Microsoft\VisualStudio\10.0_Config”).
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.PackageDefWriter.PkgDefMacros.ShellFolder">
            <summary>
            Path to the root of the Visual Studio shell installation; read from HKEY_LOCAL_MACHINE\{registry root}\InstallDir; for Portable SKUs, this is computed by removing the last two levels of the path to the executable or by applying the rule specified by RelativeRootFolderPath.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.PackageDefWriter.PkgDefMacros.System">
            <summary>
            Windows\System32 directory.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.PackageDefWriter.PkgDefMacros.WinDir">
            <summary>
            Windows installation directory
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.RegistryToPackageDefConverter">
            <summary>
            When emitting for vs10+, turns VS-related Registry installation data into a Package Def file.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsExtensionsBuildHelper">
            <summary>
            Provides methods to register VS extensions.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsExtensionsInstaller.EnableExtensionsOnLocalInstallStep(JetBrains.Application.BuildScript.Application.HostInfo,JetBrains.VsIntegration.Shell.Build.VsEnvironmentInformationArtifact,JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsExtensionsBuildHelper,JetBrains.Util.ILogger)">
            <summary>
            The standard Local Installation step for enabling the VS extension being installed.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsIntegrationPaths">
            <summary>
            Common paths for installing VS-integration-related things.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsIntegrationPaths.GetExtensionFolderRelPath(JetBrains.Application.BuildScript.Application.HostInfo)">
            <summary>
            Gets the path to the folder into which the LNK files to R# VSIX Manifest and PkgDef (or the files themselves) are installed in per-machine or per-user installation scenario.
            Per-machine: the path is relative to the VS installdir, which is what's written into Registry by VS, and it points to the "IDE" folder not the very VS installation root.
            Per-user: the path is relative to the VS LocalAppData hive-specific folder.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsIntegrationPaths.GetProductBinariesVsSpecificRelPath(JetBrains.Util.DevEnv.IVsEnvironmentInformation)">
            <summary>
            Gets the relative path (based on product binaries dir) to the compile-time folder under product binaries which contains vs-version-specific things.
            Might be used as a relative path on the target system also.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsIntegrationPaths.GetProductBinariesVsSpecificRelPath(System.Version)">
            <summary>
            Gets the relative path (based on product binaries dir) to the compile-time folder under product binaries which contains vs-version-specific things.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsixHelper.AdjustExtensionToRunPerUser(JetBrains.Util.FileSystemPath,JetBrains.Application.BuildScript.Application.HostInfo,JetBrains.Util.DevEnv.IVsEnvironmentInformation,JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsExtensionsBuildHelper)">
            <summary>
            A per-machine extension is enabled by default, but a per-user must be augmented.
            This includes both modifying the extension manifest and telling extman it's enabled.
            </summary>
            <param name="pathManifest">Path to the extension manifest file. Use <see cref="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsixHelper.FindExtensionManifest(JetBrains.Util.FileSystemPath)" /> if you got just a folder.</param>
            <param name="hostInfo">Env.</param>
            <param name="vsenv">Visual Studio hive identification.</param>
            <param name="vsreg"></param>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsixHelper.EnableExtensionInRegistry(JetBrains.Util.FileSystemPath,JetBrains.Util.DevEnv.IVsEnvironmentInformation,JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsExtensionsBuildHelper)">
            <summary>
            Writes the Registry information so that Visual Studio treated the extension as being enabled.
            </summary>
            <param name="pathExtensionFolder">Path to the folder containing the extension.</param>
            <param name="vsenv">Visual Studio hive identification.</param>
            <param name="reghelp"></param>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsixHelper.FindAllCompanyExtensionsInHive(JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.ExclusionFlags,JetBrains.Util.DevEnv.IVsEnvironmentInformation)">
            <summary>
            Finds all extensions by this company in the extensions folders for this VS version.
            </summary>
            <param name="exclusionflags"> </param>
            <param name="vsenv">Visual Studio hive identification.</param>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsixHelper.FindExtensionManifest(JetBrains.Util.FileSystemPath)">
            <summary>
            In the extension folder, looks for the manifest. Or a shell link to the manifest, in which case it's resolved to the target.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsixHelper.LocalEnableCompanyVsExtensions(JetBrains.Application.BuildScript.Application.HostInfo,JetBrains.Util.DevEnv.IVsEnvironmentInformation,JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsExtensionsBuildHelper)">
            <summary>
            The standard Local Installation step for enabling all of our extensions in VS.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsixManifestWriter">
            <summary>
            Produces a VSIX Manifest XML File for the product.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsixManifestWriter.ourSupportedVsEditions">
            <summary>
            VS editions for vsixmanifest version 1.0
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsixManifestWriter.ourInstallationTargets">
            <summary>
            Installation targets for vsixmanifest version 2.0
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsixManifestWriter.WriteVsixManifest(System.Xml.XmlWriter,JetBrains.Application.BuildScript.Application.HostInfo,JetBrains.Application.BuildScript.BuildVersionSuffix,JetBrains.VsIntegration.Shell.Install.VsEnvironmentZoneForBuild,System.Uri,System.Uri,System.Uri,System.Uri,JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsixManifestWriter.DeploymentMode,JetBrains.Application.BuildScript.Solution.AllAssembliesOnPackagesEx,JetBrains.Application.BuildScript.ProductPartCatalogForBuild,JetBrains.VsIntegration.Shell.Install.VsPackageAssembly.VsPackageClassEmitters.PackageInfo)">
            <summary>
            Produces a VSIX Manifest XML File for the product. Supported by all known VS versions (10.0..15.X).
            </summary>
            <param name="writer">Writer for the XML output.</param>
            <param name="applicationHost"></param>
            <param name="buildVersionSuffix"></param>
            <param name="vsenvzone"></param>
            <param name="uriPartPkgDef">Path to the PkgDef file that should be referenced in the manifest. Must be relative to the root of the future VSIX container, ie a relative pack part path.</param>
            <param name="uriPartIcon">Part URI.</param>
            <param name="uriPartPreview">Part URI.</param>
            <param name="uriPartLicense">Part URI.</param>
            <param name="deploymentmode">Whether we're generating a manifest for the product installed MSI-way, where the manifest is needed for enabling MEF only. <c>False</c> means we're writing the standalone VSIX file.</param>
            <param name="allassPkg"></param>
            <param name="partcatalog">Allows to tell which assemblies might be using MEF and should be registered with VS as MEFable — catalogs have cached info on assembly references and do not require re-analyzing assemblies.</param>
            <param name="packageInfo"></param>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsixManifestWriter.WriteVsixManifest20(System.Xml.XmlWriter,JetBrains.Application.BuildScript.Application.HostInfo,JetBrains.Application.BuildScript.BuildVersionSuffix,JetBrains.VsIntegration.Shell.Install.VsEnvironmentZoneForBuild,JetBrains.Util.RelativePath,System.Uri,System.Uri,System.Uri,JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsixManifestWriter.DeploymentMode,JetBrains.Application.BuildScript.Solution.AllAssembliesOnPackagesEx,JetBrains.Application.BuildScript.ProductPartCatalogForBuild,System.Collections.Generic.IEnumerable{JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsdConfigArtifact},JetBrains.VsIntegration.Shell.Install.VsPackageAssembly.VsPackageClassEmitters.PackageInfo)">
            <summary>
            Produces an extension.vsixmanifest file version 2.0 supported since VS 11.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsixManifestWriter.GetFileNameOfProductAssembly(JetBrains.Metadata.Utils.IAssemblyItem)">
            <summary>
            Gets the disk filename for an assembly. Usually it's the assname + extension, but the extension might vary (.dll/.exe) and has to be specified exactly as on disk.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsixManifestWriter.GetMefAssemblyItems(JetBrains.Application.BuildScript.Solution.AllAssembliesOnPackagesEx,JetBrains.Application.BuildScript.ProductPartCatalogForBuild,JetBrains.VsIntegration.Shell.Install.VsEnvironmentZoneForBuild)">
            <summary>
            Lists assemblies to be inspected by VS in search of MEF components.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsixManifestWriter.DeploymentMode.Msi">
            <summary>
            Packaged into MSI.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsixManifestWriter.DeploymentMode.Manual">
            <summary>
            Just copied manually.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsixManifestWriter.DeploymentMode.Vsix">
            <summary>
            Packaged into VSIX.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsixManifestWriter.Elem._N">
            <summary>
            Embeds XML namespace into the element names, to ensure we always use them namespaced.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsixManifestWriter.XsdBoolean">
            <summary>
            Matches what XSD thinks to be a boolean constant.
            </summary>
        </member>
        <member name="P:JetBrains.Platform.VisualStudio.SinceVs10.Shell.IVsSynchronizedSettingsManager.VsSettingChanged">
            <summary>
            Raised on the main thread when a setting has changed.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.IVsSynchronizedSettingsManager.GetNames(System.String,JetBrains.Util.OnError)">
            <summary>
            Returns the names of all settings currently stored whose names begin with the given prefix (case-insensitive).
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.IVsSynchronizedSettingsManager.GetValue``1(System.String,JetBrains.Util.OnError)">
            <summary>
            Gets the value of the property.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.IVsSynchronizedSettingsManager.GetValueOrDefault``1(System.String,``0)">
            <summary>
            Gets the value of a property if it is set, or the default in all other cases.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.IVsSynchronizedSettingsManager.SetValueAsync(System.String,System.Object,System.Boolean)">
            <summary>
            Sets the value of a property.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Local.JumpVsixFromMachineToPerUser">
            <summary>
            In Internal mode, suggests turning a per-machine install into a per-user one.
            This is needed to have more than one hive: starting with DevTen, per-machine components can only be registered for ALL hives at once.
            This code takes the product shortcuts installed into <c>Common7\IDE\Extensions</c> and relocates them to <c>%LOCALAPPDATA%\Microsoft\VisualStudio\10.0\Extensions</c>.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Local.JumpVsixFromMachineToPerUser.AskCleanupInstallationsByOtherVersions">
            <summary>
            Checks if there are any extensions of the same product but different version registered into the same hive.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Local.JumpVsixFromMachineToPerUser.AskJump">
            <summary>
            Asks whether to jump. Returns whether a jump was needed (if dialog will be shown, returns before actually doing the jump, and the jump could then be canceled by the user).
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Local.JumpVsixFromMachineToPerUser.DoIfNotJumping">
            <summary>
            Called by <see cref="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Local.JumpVsixFromMachineToPerUser.AskJump"/> when it's decided (by logic or user) not to jump.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Local.JumpVsixFromMachineToPerUser.DoJumpWithUI">
            <summary>
            User chose to jump (or we did it automatically). Error handling in UI.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Local.JumpVsixFromMachineToPerUser.Jump_CleanupAllPerHiveExtensionsInThisHive(JetBrains.Application.IApplicationHost,JetBrains.Util.DevEnv.IVsEnvironmentInformation)">
            <summary>
            Before doing a jump, delete all possible per-hive extensions in this hive.
            More aggressive than <see cref="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Local.JumpVsixFromMachineToPerUser.AskCleanupInstallationsByOtherVersions"/>.
            </summary>
            <param name="applicationHost"> </param>
            <param name="vsenv"> </param>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Local.JumpVsixFromMachineToPerUser.GetExtensionsInHive(JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.ExclusionFlags,JetBrains.Application.BuildScript.Application.HostInfo,JetBrains.Util.DevEnv.IVsEnvironmentInformation)">
            <summary>
            Looks for any extensions of a different version in the same hive.
            </summary>
            <param name="exclusionflags">What to exclude from enumeration.</param>
            <param name="hostInfo">AppDesc.</param>
            <param name="vsenv">Visual Studio hive identification.</param>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Shell.MethTest.IMethTestServer">
            <summary>
            Detects broken installations.
            Now R# in DevTen consists of two separate things: VS Package and VS MEF extension. The first is the main one, but the second is required for normal operation. It's possible that one of them would fail. We consider the VS Package failure to load to be uncommon and fatal, whilst MEF would have its quirks from time to time. These situations we would like to explicitly detect and report, otherwise the symptoms could be ambiguous.
            This is the "server" part: an interface to the component registered with MEF, its presence to be checked by the package when it gets running.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Shell.MethTest.MethTestClient">
            <summary>
            Detects broken installations.
            Now R# in DevTen consists of two separate things: VS Package and VS MEF extension. The first is the main one, but the second is required for normal operation. It's possible that one of them would fail. We consider the VS Package failure to load to be uncommon and fatal, whilst MEF would have its quirks from time to time. These situations we would like to explicitly detect and report, otherwise the symptoms could be ambiguous.
            This is the "client" part: a VS Package component to check the presence of MEF-registered components some time after startup.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Shell.MethTest.MethTestServer">
            <summary>
            Detects broken installations.
            Now R# in DevTen consists of two separate things: VS Package and VS MEF extension. The first is the main one, but the second is required for normal operation. It's possible that one of them would fail. We consider the VS Package failure to load to be uncommon and fatal, whilst MEF would have its quirks from time to time. These situations we would like to explicitly detect and report, otherwise the symptoms could be ambiguous.
            This is the "server" part: a component registered with MEF, its presence to be checked by the package when it gets running.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.Shell.VsFileChangeWrapper.VSCOOKIE_NIL">
            <summary>
            See Microsoft.VisualStudio.Shell.Interop.Constants.VSCOOKIE_NIL
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Shell.VsFindManagerClientSinceVs10">
            <summary>
            VS10+ base implementation.
            Note: there is no way to get live properties in VS10, real working implementations are VS11+.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.DocumentModel.VsDocumentInSyncMoments.TryGetTextVersion(JetBrains.DocumentModel.RunningDocumentId,JetBrains.Application.Changes.ModificationStamp,JetBrains.Util.OnError)">
            <summary>
            Gets a text buffer version for the given modification stamp. NULL if no matching version available.
            </summary>
            <param name="documentId">The backend document ID.</param>
            <param name="modificationStamp">Modification stamp of that doc.</param>
            <param name="onerror">NULL to silently return NULL, or any <see cref="T:JetBrains.Util.OnError" /> to report a failure.</param>
            <returns>NULL when no match known.</returns>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Env.ApplicationShutdownRequestsSinceVs10">
            <summary>
            Implements VS-specific restart activity.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Env.ApplicationShutdownRequestsSinceVs10.#ctor(JetBrains.Lifetimes.Lifetime,JetBrains.Application.Threading.IThreading,JetBrains.Application.Hosting.IHostCommandLine,JetBrains.Application.Components.ILazy{JetBrains.VsIntegration.Interop.Shim.VsShell.Shell.IVsShell},JetBrains.Util.ILogger)">
            <summary>
            Implements VS-specific restart activity.
            </summary>
        </member>
        <member name="P:JetBrains.Platform.VisualStudio.SinceVs10.Env.VsMainWindowSinceVs10.MainWpfWindow">
            <summary>
            Gets the main window of the application as a WPF <see cref="T:System.Windows.Window"/> object.
            </summary>
        </member>
        <member name="P:JetBrains.Platform.VisualStudio.SinceVs10.Env.VsMainWindowSinceVs10.ActiveWpfWindow">
            <summary>
            An active VS top level window: main or floating tab well or floating tool window.
            </summary>
        </member>
        <member name="P:JetBrains.Platform.VisualStudio.SinceVs10.Env.VsMainWindowSinceVs10.JetBrains#Application#StdApplicationUI#IMainWindow{System#Windows#Window}#ActiveWindow">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.Platform.VisualStudio.SinceVs10.Env.VsMainWindowSinceVs10.JetBrains#Application#StdApplicationUI#IMainWindow{System#Windows#Window}#PrimaryWindow">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.Platform.VisualStudio.SinceVs10.Env.VsMainWindowSinceVs10.JetBrains#Application#StdApplicationUI#IMainWindow{System#Windows#Window}#TopLevelWindows">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Env.VsSkipFirstLaunchSetupProductCanBeStarted">
            <summary>
            On first startup, newer versions of VS might be spawning a secondary instance to have it perform certain one-time tasks.
            Our product shell should not be started up in these instances, because they're considered user-invisible, and our dialogs like licensing are unexpected in this mode.
            To detect the state, we're reading the FirstLaunchSetup VS cmdline parameter, as suggested by MSFT (maybe there's a better method, but we don't know of one yet.
            </summary>
            <remarks>NP-939 Product Shell Should Not Be Started in "FirstLaunchSetup" Mode</remarks>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Env.VsSkipFirstLaunchSetupProductCanBeStarted.#ctor(JetBrains.Application.Components.ILazy{Microsoft.VisualStudio.Shell.Interop.IVsAppCommandLine})">
            <summary>
            On first startup, newer versions of VS might be spawning a secondary instance to have it perform certain one-time tasks.
            Our product shell should not be started up in these instances, because they're considered user-invisible, and our dialogs like licensing are unexpected in this mode.
            To detect the state, we're reading the FirstLaunchSetup VS cmdline parameter, as suggested by MSFT (maybe there's a better method, but we don't know of one yet.
            </summary>
            <remarks>NP-939 Product Shell Should Not Be Started in "FirstLaunchSetup" Mode</remarks>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.IDE.EditorManager.FrontendFindTextControlByFileSearchDescriptorHelper">
            <summary>
            Just stores the olde code from front, which knew how to enum text controls and wait for them.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.IDE.EditorManager.FrontendFindTextControlByFileSearchDescriptorHelper.TryFindTextControlAsync(JetBrains.ProjectModel.Search.IProjectFileSearchDescriptor,JetBrains.Util.VirtualFileSystemPath,JetBrains.DocumentModel.RunningDocumentId,JetBrains.VsIntegration.Interop.Shim.VsShell.Shell.IVsWindowFrame,JetBrains.Platform.VisualStudio.Protocol.Backend.IDE.IVsEditorManagerFrontToBackInterop)">
            <summary>
            Looks if there's a text control for the given file currently open.
            Tries to poke into the frame to cause it open the text control if not yet open (needed for xaml aspx 'n shit).
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.IDE.EditorManager.VsEditorManagerFrontendServices.JetBrains#Platform#VisualStudio#Protocol#Frontend#IDE#IVsEditorManagerBackToFrontInterop#OpenEditorAsync(JetBrains.ProjectModel.Search.IProjectFileSearchDescriptor,JetBrains.Util.VirtualFileSystemPath,JetBrains.IDE.OpenFileOptions)">
            <summary>
              <para>Opens an editor in VS, forces its frame to show (this helps with finding editors sometimes), then exists without waiting for a text control to wire up with that.</para>
              <para>Text controls are wired to open editors elsewhere (<see cref="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.VsTextViewSink" /> catches new views, <see cref="M:JetBrains.VsIntegration.ProjectDocuments.VsDocumentManagerWhidbey.OnRegisterTextBuffer(JetBrains.VsIntegration.ProjectDocuments.Whidbey.VsTextBufferData,System.Boolean)" /> catches new buffers, <see cref="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.VsTextViewDataForTextControlCollectorDevTen" /> wires them up together, <see cref="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.VsAttachTransportTextControlsToTextViews" /> sees successful wireups and creates text controls transports, then they can be seen on backend).</para>
              <para>Caller is expected to be waiting for a text control on its own.</para>
              <para>Works in two modes: opening a project file (passed as a search descriptor), or opening a disk file path. Project file might fallback to opening by disk file path if project is not loaded yet.</para>
            </summary>
            <param name="filedescDesired">
            Mode “open project file”: search desc for that project file.
            Mode “open from disk path”: NULL.
            </param>
            <param name="filepathDesired">
            Mode “open project file”: <see cref="P:JetBrains.ProjectModel.Search.IProjectFileOrFolderSearchDescriptor.Location" />.
            Mode “open from disk path”: that disk path.
            </param>
            <param name="openFileOptions"></param>
            <returns>Descriptor of the HItem which has actually been open: original <paramref name="filedescDesired" /> if it could be used, or whatever were actually opened from path.</returns>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.IDE.EditorManager.VsEditorManagerFrontendServices.CallVs(JetBrains.VsIntegration.Interop.Shim.VsShell.Shell.Hierarchy.VsHierarchyItem,JetBrains.Util.VirtualFileSystemPath,JetBrains.IDE.FileView)">
            <summary>
            A single attempt of calling into VS to open the editor.
            Attempts cycle by view kind and provisional status.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.IDE.EditorManager.VsEditorManagerFrontendServices.OpenEditorHandleException(System.Exception,JetBrains.Util.VirtualFileSystemPath)">
            <summary>
            Exception handling when opening text controls for documents in VS (shared between a number of functions).
            Need to show some of the errors as message boxes (eg IO exceptions).
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.IDE.EditorManager.VsEditorManagerFrontendServices.ReportUserRelatedError(System.Exception,System.String,System.String)">
            <summary>
            Reports an error that could be understood by the user and should not be submitted to the tracker, eg File Not Found.
            Shows a message box.
            These should be located at one place for easier changing of the behavior, eg switching to the mode when no modal message boxes are shown.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.IDE.EditorManager.VsEditorManagerFrontendServices.ReportUserRelatedErrorWhenOpeningFile(System.Exception,JetBrains.Util.VirtualFileSystemPath)">
            <summary>
            A version of <see cref="M:JetBrains.Platform.VisualStudio.SinceVs10.IDE.EditorManager.VsEditorManagerFrontendServices.ReportUserRelatedError(System.Exception,System.String,System.String)" /> with a message about opening a file.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.IDE.EditorManager.VsEditorManagerFrontendServices.ForceContentCreation(JetBrains.VsIntegration.Interop.Shim.VsShell.Shell.IVsWindowFrame)">
            <summary>
            An experimental method, trying to solve the problem of window frames which are visible as tabs but have no content inside, or whose BringToFront does not cause content to be created.
            Proved somewhat effective, but sometimes in a weird way: might cause a fully-functional text control be created without no frame or tab visible on screen at all!
            Keeping for reference.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.IDE.InEditorFloatingPopup.Views.VsInEditorFloatingPopupView">
            <summary>
            VsInEditorFloatingPopupView
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.IDE.InEditorFloatingPopup.Views.VsInEditorFloatingPopupView.InitializeComponent">
            <summary>
            InitializeComponent
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.IDE.Roslyn.DiagnosticDataEx.WithMappedRange(JetBrains.Platform.VisualStudio.Protocol.Common.Ide.RoslynDiagnosticsFeedTransport.DiagnosticData,Microsoft.VisualStudio.Text.ITextSnapshot,Microsoft.VisualStudio.Text.ITextSnapshot)">
            <summary>
            Maps the range to another text snapshot.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.IDE.Roslyn.DiagnosticDataEx.WithMappedRange(JetBrains.Platform.VisualStudio.Protocol.Common.Ide.RoslynDiagnosticsFeedTransport.DiagnosticData,Microsoft.VisualStudio.Text.ITextVersion,Microsoft.VisualStudio.Text.ITextVersion)">
            <summary>
            Maps the range to another text snapshot.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.IDE.Roslyn.VsRoslynDiagnosticsFeed">
            <summary>
            Allows to track Roslyn diagnostics for a set of documents, live.
            Works only in certain VS versions where we have references to Roslyn. In others, OK to call, but would be empty. See <see cref="P:JetBrains.Platform.VisualStudio.SinceVs10.IDE.Roslyn.VsRoslynDiagnosticsFeed.IsSupported" />.
            </summary>
        </member>
        <member name="P:JetBrains.Platform.VisualStudio.SinceVs10.IDE.Roslyn.VsRoslynDiagnosticsFeed.IsSupported">
            <summary>
            If supported in this runtime. If not, can call, but will get empties.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.IDE.Roslyn.VsRoslynDiagnosticsFeed.GetLiveDiagnosticsFor(JetBrains.Lifetimes.Lifetime,JetBrains.VsIntegration.DocumentModel.Whidbey.VsDocumentWhidbeyEnvoy)">
            <summary>
            Starts tracking Roslyn to feed diagnostics for the given document, live.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.IDE.Roslyn.VsRoslynDiagnosticsFeedFrontendServices">
            <summary>
            Serves requests from back.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.IDE.VsDocumentManagerWhidbey_TrackVsTextViewDataForTextControlChanges">
            <summary>
            Binds doc man for firing text control re-bind event when document binding changes.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.IDE.VsDocumentManagerWhidbey_TrackVsTextViewDataForTextControlChanges.#ctor(JetBrains.Lifetimes.Lifetime,JetBrains.VsIntegration.ProjectDocuments.VsDocumentManagerWhidbey,JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.ITrackVsTextViewDataForTextControlChanges,JetBrains.Application.Threading.IShellLocks,JetBrains.ProjectModel.Tasks.ISolutionLoadTasksScheduler)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.IDE.VsProjectFileExtensionMappingFront.PublishEditorTypeOnTransport(JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlDevTenEnvoy,JetBrains.TextControl.Transport.TransportTextControl)">
            <summary>
            Back wants to know editor type GUIDs, were asking for the window frame previously, now just publish the GUID proactively.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Declarations.VsEnclosingScopes">
            <summary>
            Microsoft.VisualStudio.Shell.Interop.__VsEnclosingScopes, Microsoft.VisualStudio.Shell.Interop.__VsEnclosingScopes2
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Declarations.VsKnownPredefinedMarginNames">
            <summary>
            Type: Microsoft.VisualStudio.Text.Editor.PredefinedMarginNames
            Last update: 27.03.2024. Microsoft Visual Studio Professional 2022 Version 17.9.4.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Declarations.VsKnownPredefinedTextViewRoles">
            <summary>
            Type: Microsoft.VisualStudio.Text.Editor.PredefinedTextViewRoles
            Last update: 27.03.2024. Microsoft Visual Studio Professional 2022 Version 17.9.4.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Declarations.VsSettingsScope">
            <summary>
            Microsoft.VisualStudio.Settings.SettingsScope, Microsoft.VisualStudio.Shell.Interop.__VsSettingsScope2
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Declarations.VsSettingsType">
            <summary>
            Microsoft.VisualStudio.Settings.SettingsType
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.Documents.ITextBufferEx.GetIVsTextBuffer(Microsoft.VisualStudio.Text.ITextBuffer,Microsoft.VisualStudio.Editor.IVsEditorAdaptersFactoryService)">
            <summary>
            Gets the adapter to the legacy interface by the new interface.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.Documents.ITextBufferEx.GetIVsTextBuffer(Microsoft.VisualStudio.Text.ITextBuffer,System.Lazy{Microsoft.VisualStudio.Editor.IVsEditorAdaptersFactoryService})">
            <summary>
            Gets the adapter to the legacy interface by the new interface.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.Documents.ITextBufferEx.GetIVsTextBuffer(Microsoft.VisualStudio.Text.ITextBuffer,JetBrains.Application.Components.ILazy{Microsoft.VisualStudio.Editor.IVsEditorAdaptersFactoryService})">
            <summary>
            Gets the adapter to the legacy interface by the new interface.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.Documents.ITextBufferEx.GetTextBuffer(JetBrains.VsIntegration.Interop.Shim.TextManager.Documents.IVsTextBuffer,Microsoft.VisualStudio.Editor.IVsEditorAdaptersFactoryService)">
            <summary>
            Gets the new interface by the legacy interface.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.Documents.ITextBufferEx.TryGetIVsTextBuffer(Microsoft.VisualStudio.Text.ITextBuffer,Microsoft.VisualStudio.Editor.IVsEditorAdaptersFactoryService)">
            <summary>
            Tries to get the adapter to the legacy interface by the new interface.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.Documents.ITextBufferEx.TryGetPathFromTextDocument(Microsoft.VisualStudio.Text.ITextBuffer)">
            <summary>
            Helps with identifying VS buffers.
            In case the underlying document is file-based, extracts its path.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.Documents.ITextBufferEx.TryGetTextBuffer(JetBrains.VsIntegration.Interop.Shim.TextManager.Documents.IVsTextBuffer,Microsoft.VisualStudio.Editor.IVsEditorAdaptersFactoryService)">
            <summary>
            Tries to get the new interface by the legacy interface.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.Documents.ITextBufferEx.TryGetTextBuffer(JetBrains.VsIntegration.Interop.Shim.TextManager.Documents.IVsTextBuffer,System.Lazy{Microsoft.VisualStudio.Editor.IVsEditorAdaptersFactoryService})">
            <summary>
            Tries to get the new interface by the legacy interface.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.Documents.ITextBufferEx.TryGetTextBuffer(JetBrains.VsIntegration.Interop.Shim.TextManager.Documents.IVsTextBuffer,JetBrains.Application.Components.ILazy{Microsoft.VisualStudio.Editor.IVsEditorAdaptersFactoryService})">
            <summary>
            Tries to get the new interface by the legacy interface.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.Documents.ITextBufferEx.ContainsReadOnlyRegions(Microsoft.VisualStudio.Text.ITextBuffer)">
            <summary>
            A modern API counterpart for <see cref="M:JetBrains.VsIntegration.Interop.Shim.TextManager.Documents.IVsTextBufferEx.ContainsReadOnlyRegions(JetBrains.VsIntegration.Interop.Shim.TextManager.Documents.IVsTextBuffer)" />.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.IPropertyOwnerEx.GetPropertyByType``1(Microsoft.VisualStudio.Utilities.IPropertyOwner)">
            <summary>
            Gets property keyed by Type. Throws if missing.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.IPropertyOwnerEx.GetPropertyByType``1(Microsoft.VisualStudio.Utilities.IPropertyOwner,System.Func{``0})">
            <summary>
            Gets property keyed by Type. Creates with <paramref name="FCreateIfMissing" /> if missing.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.IPropertyOwnerEx.GetOrCreateLiveProperty``1(Microsoft.VisualStudio.Utilities.IPropertyOwner)">
            <summary>
            Gets a live <see cref="T:JetBrains.DataFlow.IProperty`1" /> property keyed by its value type. Creates with the default ctor.
            </summary>
            <seealso cref="M:JetBrains.VsIntegration.Interop.Shim.TextManager.Documents.IVsTextBuffer.GetOrCreateUserDataProperty``1"/>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.IPropertyOwnerEx.GetOrCreateLiveCollection``1(Microsoft.VisualStudio.Utilities.IPropertyOwner)">
            <summary>
            Gets a live <see cref="T:JetBrains.DataFlow.ICollectionEvents`1" /> property keyed by its value type. Creates with the default ctor.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.IPropertyOwnerEx.TryGetPropertyByType``1(Microsoft.VisualStudio.Utilities.IPropertyOwner)">
            <summary>
            Gets property keyed by Type. <c>Null</c> if missing.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.SnapshotSpanEx.CoerceToSnapshot(JetBrains.Util.TextRange,Microsoft.VisualStudio.Text.ITextSnapshot)">
            <summary>
            Coerces the text range to the snapshot. We assume offsets to not have to fit exactly, because versions might be slightly off, so start/end would be adjusted accordingly to be in range.
            Asserts the range is normalized and does not fall off the front end of the document, as these might not happen due to versioning problems.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.SnapshotSpanEx.ContainsFullyExclusive(Microsoft.VisualStudio.Text.SnapshotSpan,Microsoft.VisualStudio.Text.SnapshotSpan)">
            <summary>
            By default, <see cref="M:Microsoft.VisualStudio.Text.SnapshotSpan.Contains(Microsoft.VisualStudio.Text.SnapshotPoint)" /> includes the start point.
            Include both start and end points.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.SnapshotSpanEx.ContainsFullyInclusive(Microsoft.VisualStudio.Text.SnapshotSpan,Microsoft.VisualStudio.Text.SnapshotPoint)">
            <summary>
            By default, <see cref="M:Microsoft.VisualStudio.Text.SnapshotSpan.Contains(Microsoft.VisualStudio.Text.SnapshotPoint)" /> wouldn't include the end point.
            Include both start and end points.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.TextControl.IWpfTextViewEx">
            <summary>
            Extensions to <see cref="T:Microsoft.VisualStudio.Text.Editor.IWpfTextView" /> and related things (<see cref="T:Microsoft.VisualStudio.Text.Editor.ITextView" />, <see cref="T:JetBrains.VsIntegration.Interop.Shim.TextManager.TextControl.IVsTextView" />).
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.TextControl.IWpfTextViewEx.EnsureOutliningExpanded(Microsoft.VisualStudio.Text.Editor.IWpfTextView,Microsoft.VisualStudio.Text.SnapshotPoint,System.Lazy{Microsoft.VisualStudio.Text.Outlining.IOutliningManagerService})">
            <summary>
            Makes sure that the text control that supports outlining has the specified position expanded.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.TextControl.IWpfTextViewEx.EnsureOutliningExpanded(Microsoft.VisualStudio.Text.Editor.IWpfTextView,Microsoft.VisualStudio.Text.SnapshotSpan,System.Lazy{Microsoft.VisualStudio.Text.Outlining.IOutliningManagerService})">
            <summary>
            Makes sure that the text control that supports outlining has the specified span expanded.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.TextControl.IWpfTextViewEx.GetITextView(JetBrains.VsIntegration.Interop.Shim.TextManager.TextControl.IVsTextView,Microsoft.VisualStudio.Editor.IVsEditorAdaptersFactoryService)">
            <summary>
            Gets the managed text view from the adapter class.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.TextControl.IWpfTextViewEx.GetIVsTextView(Microsoft.VisualStudio.Text.Editor.IWpfTextView,System.Lazy{Microsoft.VisualStudio.Editor.IVsEditorAdaptersFactoryService})">
            <summary>
            Gets the adapter class that exposes the pre-VS-10 interfaces from the text view.
            DO NOT USE for things that could be achieved thru the modern API!
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.TextControl.IWpfTextViewEx.GetIVsTextView(Microsoft.VisualStudio.Text.Editor.IWpfTextView,JetBrains.Application.Components.ILazy{Microsoft.VisualStudio.Editor.IVsEditorAdaptersFactoryService})">
            <summary>
            Gets the adapter class that exposes the pre-VS-10 interfaces from the text view.
            DO NOT USE for things that could be achieved thru the modern API!
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.TextControl.IWpfTextViewEx.GetIVsTextView(Microsoft.VisualStudio.Text.Editor.IWpfTextView,Microsoft.VisualStudio.Editor.IVsEditorAdaptersFactoryService)">
            <summary>
            Gets the adapter class that exposes the pre-VS-10 interfaces from the text view.
            DO NOT USE for things that could be achieved thru the modern API!
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.TextControl.IWpfTextViewEx.GetServiceProvider(Microsoft.VisualStudio.Text.Editor.IWpfTextView,Microsoft.VisualStudio.Editor.IVsEditorAdaptersFactoryService)">
            <summary>
            Gets the Service Provider of the text view.
            It wraps the Visual Studio <see cref="T:Microsoft.VisualStudio.OLE.Interop.IServiceProvider" /> object, but exposes it with the System <see cref="T:System.IServiceProvider" /> API.
            The <see cref="T:Microsoft.VisualStudio.TextManager.Interop.IVsTextView" />-implementing object is the <c>VsTextViewAdapter</c> who derives from <c>WindowPane</c> who implements the system <see cref="T:System.IServiceProvider" />.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.TextControl.IWpfTextViewEx.GetTextViewHost(Microsoft.VisualStudio.Text.Editor.IWpfTextView,Microsoft.VisualStudio.Editor.IVsEditorAdaptersFactoryService)">
            <summary>
            Gets the WPF host of the given view.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.TextControl.IWpfTextViewEx.GetTextViewHost(JetBrains.VsIntegration.Interop.Shim.TextManager.TextControl.IVsTextView)">
            <summary>
            Gets the WPF host of the given view.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.TextControl.IWpfTextViewEx.GetWindowFrame(Microsoft.VisualStudio.Text.Editor.IWpfTextView,Microsoft.VisualStudio.Editor.IVsEditorAdaptersFactoryService)">
            <summary>
            Gets the old-fashioned COM interface for the VS window frame.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.TextControl.IWpfTextViewEx.OnLayoutChanged(Microsoft.VisualStudio.Text.Editor.ITextView)">
            <summary>
            A wrapper for <see cref="E:Microsoft.VisualStudio.Text.Editor.ITextView.LayoutChanged" />.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.TextControl.IWpfTextViewEx.GetTextViewLifetime(Microsoft.VisualStudio.Text.Editor.ITextView)">
            <summary>
            Get text view lifetime.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.TextControl.IWpfTextViewEx.ToFullHeightBoundsRect(Microsoft.VisualStudio.Text.Formatting.TextBounds)">
            <summary>
            To text-only bounds (not including the full line height).
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.TextControl.IWpfTextViewEx.ToTextBoundsRect(Microsoft.VisualStudio.Text.Formatting.TextBounds)">
            <summary>
            To text-only bounds (not including the full line height).
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.TextControl.IWpfTextViewEx.TryGetITextView(JetBrains.VsIntegration.Interop.Shim.TextManager.TextControl.IVsTextView,Microsoft.VisualStudio.Editor.IVsEditorAdaptersFactoryService)">
            <summary>
            Tries to get the managed text view from the adapter class.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.TextControl.IWpfTextViewEx.TryGetIVsTextView(Microsoft.VisualStudio.Text.Editor.IWpfTextView,Microsoft.VisualStudio.Editor.IVsEditorAdaptersFactoryService)">
            <summary>
            Gets the adapter class that exposes the pre-VS-10 interfaces from the text view.
            DO NOT USE for things that could be achieved thru the modern API!
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.TextControl.IWpfTextViewEx.TryGetServiceProvider(Microsoft.VisualStudio.Text.Editor.IWpfTextView,Microsoft.VisualStudio.Editor.IVsEditorAdaptersFactoryService)">
            <summary>
            Gets the Service Provider of the text view.
            It wraps the Visual Studio <see cref="T:Microsoft.VisualStudio.OLE.Interop.IServiceProvider" /> object, but exposes it with the System <see cref="T:System.IServiceProvider" /> API.
            The <see cref="T:Microsoft.VisualStudio.TextManager.Interop.IVsTextView" />-implementing object is the <c>VsTextViewAdapter</c> who derives from <c>WindowPane</c> who implements the system <see cref="T:System.IServiceProvider" />.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.TextControl.IWpfTextViewEx.TryGetWindowFrame(Microsoft.VisualStudio.Text.Editor.IWpfTextView,Microsoft.VisualStudio.Editor.IVsEditorAdaptersFactoryService)">
            <summary>
            Gets the old-fashioned COM interface for the VS window frame.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Shim.ShimDynamicApi">
            <summary>
            Temporary class while the API is non-stable. Shims the dynamic things.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Shim.TextControl.ConversionDevTen.AsDocLineColumn(Microsoft.VisualStudio.Text.VirtualSnapshotPoint)">
            <summary>
            This method does not perform coordinate conversion. You MUST make sure that <paramref name="vpt" /> is already in the text control coordinate space.
            <para>DO NOT USE this low-level routine unless absolutely sure the surface API will not do.</para>
            <para>Use <see cref="T:JetBrains.TextControl.ITextControl" />::<see cref="P:JetBrains.TextControl.ITextControl.Coords" /> and <see cref="T:JetBrains.TextControl.Coords.ITextControlPos" /> methods instead.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Shim.TextControl.ConversionDevTen.AsDocOffsetAndVirtual(Microsoft.VisualStudio.Text.VirtualSnapshotPoint)">
            <summary>
            This method does not perform coordinate conversion. You MUST make sure that <paramref name="vpt" /> is already in the text control coordinate space.
            <para>DO NOT USE this low-level routine unless absolutely sure the surface API will not do.</para>
            <para>Use <see cref="T:JetBrains.TextControl.ITextControl" />::<see cref="P:JetBrains.TextControl.ITextControl.Coords" /> and <see cref="T:JetBrains.TextControl.Coords.ITextControlPos" /> methods instead.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Shim.TextControl.ConversionDevTen.AsTextControlLineColumn(Microsoft.VisualStudio.Text.VirtualSnapshotPoint)">
            <summary>
            This method does not perform coordinate conversion. You MUST make sure that <paramref name="vpt" /> is already in the text control coordinate space.
            <para>DO NOT USE this low-level routine unless absolutely sure the surface API will not do.</para>
            <para>Use <see cref="T:JetBrains.TextControl.ITextControl" />::<see cref="P:JetBrains.TextControl.ITextControl.Coords" /> and <see cref="T:JetBrains.TextControl.Coords.ITextControlPos" /> methods instead.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Shim.TextControl.ConversionDevTen.MapUpToTop2(Microsoft.VisualStudio.Text.Projection.IBufferGraph,Microsoft.VisualStudio.Text.SnapshotPoint,Microsoft.VisualStudio.Text.PointTrackingMode,Microsoft.VisualStudio.Text.PositionAffinity)">
            <summary>
            Maps the point to the topmost buffer of the graph. Emulates <see cref="T:Microsoft.VisualStudio.Text.Projection.IBufferGraph" />::<c>MapUpToTop</c> function that were present in Beta1 but was gone in between August and September CTPs.
            </summary>
            <param name="graph">Buffer graph.</param>
            <param name="pointNonTop">A point in some buffer in the <see cref="T:Microsoft.VisualStudio.Text.Projection.IBufferGraph" />.</param>
            <param name="pointTrackingMode">How <paramref name="pointNonTop" /> is tracked to the current snapshot if necessary.</param>
            <param name="positionAffinity">If the mapping is ambiguous (the position is on a source span seam), determines
                        whether the mapping should target the position immediately after the preceding
                        character or immediately before the following character in the top buffer.
                        This setting has no effect if the mapping is unambiguous.</param>
            <returns>The corresponding position in a snapshot of the top buffer, or null if the position does not map to the top buffer using
                        this graph.</returns>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Shim.TextControl.ConversionDevTen.ToVsVirtualSnapshotPoint(JetBrains.TextControl.DocOffsetAndVirtual,System.Nullable{JetBrains.DocumentModel.RunningDocumentId},System.Nullable{JetBrains.Application.Changes.ModificationStamp},Microsoft.VisualStudio.Text.Editor.ITextView,JetBrains.Platform.VisualStudio.SinceVs10.DocumentModel.VsDocumentInSyncMoments)">
            <summary>
            <para>Maps from backend coords to fontend, on front.</para>
            </summary>
            <param name="docoffs">Offset, in backend document coords.</param>
            <param name="maybeDocId">See <paramref name="maybeModificationStamp"/>, defines the context for the modification stamp. Optional under the same rules: SHOULD be given whenever possible.</param>
            <param name="maybeModificationStamp">Modification stamp for the backend document version in which this coord was obtained. The current text buffer version on front might be out of sync. This SHOULD be defined in all new usages. For legacy usages (when we assume versions are in sync), you MIGHT leave this NULL, but the results MIGHT be incorrect.</param>
            <param name="textview">The front text view / text buffer, will map the coord to the current snapshot in it.</param>
            <param name="vsDocumentInSyncMoments">Service for versions.</param>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Shim.TextControl.ConversionDevTen.ToVsVirtualSnapshotPoint(JetBrains.DocumentModel.DocumentCoords,Microsoft.VisualStudio.Text.Editor.ITextView)">
            <summary>
              <para>DO NOT USE this low-level routine unless absolutely sure the surface API will not do.</para>
              <para>Use <see cref="T:JetBrains.TextControl.ITextControl" />::<see cref="P:JetBrains.TextControl.ITextControl.Coords" /> and <see cref="T:JetBrains.TextControl.Coords.ITextControlPos" /> methods instead.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Shim.TextControl.ConversionDevTen.ToVsVirtualSnapshotPoint(JetBrains.TextControl.TextControlLineColumn,Microsoft.VisualStudio.Text.Editor.ITextView)">
            <summary>
              <para>DO NOT USE this low-level routine unless absolutely sure the surface API will not do.</para>
              <para>Use <see cref="T:JetBrains.TextControl.ITextControl" />::<see cref="P:JetBrains.TextControl.ITextControl.Coords" /> and <see cref="T:JetBrains.TextControl.Coords.ITextControlPos" /> methods instead.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Shim.TextControl.ConversionDevTen.TrackInTime(JetBrains.Util.TextRange,Microsoft.VisualStudio.Text.ITextSnapshot,Microsoft.VisualStudio.Text.ITextSnapshot,Microsoft.VisualStudio.Text.SpanTrackingMode)">
            <summary>
            Tracks a text range (in our doc model data types) in time, from one VS buffre snapshot to another.
            In old VS versions, this will be allocating working objects (tracking span), because it works similarly to overload with versions.
            In newer VS versions, this converts without a tracking span using a helper class.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Shim.TextControl.ConversionDevTen.TrackInTime(JetBrains.TextControl.DocOffset,Microsoft.VisualStudio.Text.ITextSnapshot,Microsoft.VisualStudio.Text.ITextSnapshot,Microsoft.VisualStudio.Text.PointTrackingMode)">
            <summary>
            Tracks a text position (in our doc model data types) in time, from one VS buffre snapshot to another.
            In old VS versions, this will be allocating working objects (tracking span), because it works similarly to overload with versions.
            In newer VS versions, this converts without a tracking span using a helper class.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Shim.TextControl.ConversionDevTen.TrackInTime(JetBrains.Util.TextRange,Microsoft.VisualStudio.Text.ITextVersion,Microsoft.VisualStudio.Text.ITextVersion,Microsoft.VisualStudio.Text.SpanTrackingMode)">
            <summary>
            Tracks a text range (in our doc model data types) in time, from one VS buffer snapshot to another.
            In any VS versions, this will be allocating working objects (tracking spans). Use <see cref="T:Microsoft.VisualStudio.Text.ITextSnapshot" /> overload when possible.
            In newer VS versions, a non-allocating helper class exists (Tracking). Call it directly in Since* code whenever reasonable.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Shim.TextControl.ConversionDevTen.TrackInTime(JetBrains.TextControl.DocOffsetAndVirtual,Microsoft.VisualStudio.Text.ITextVersion,Microsoft.VisualStudio.Text.ITextVersion,Microsoft.VisualStudio.Text.PointTrackingMode)">
            <inheritdoc cref="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Shim.TextControl.ConversionDevTen.TrackInTime(JetBrains.TextControl.DocOffset,Microsoft.VisualStudio.Text.ITextVersion,Microsoft.VisualStudio.Text.ITextVersion,Microsoft.VisualStudio.Text.PointTrackingMode)" />
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Shim.TextControl.ConversionDevTen.TrackInTime(JetBrains.TextControl.DocOffset,Microsoft.VisualStudio.Text.ITextVersion,Microsoft.VisualStudio.Text.ITextVersion,Microsoft.VisualStudio.Text.PointTrackingMode)">
            <summary>
            Tracks a text position (in our doc model data types) in time, from one VS buffer snapshot to another.
            In any VS versions, this will be allocating working objects (tracking spans). Use <see cref="T:Microsoft.VisualStudio.Text.ITextSnapshot" /> overload when possible.
            In newer VS versions, a non-allocating helper class exists (Tracking). Call it directly in Since* code whenever reasonable.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Shim.TextControl.ConversionDevTen.TryToDocOffset(Microsoft.VisualStudio.Text.IMappingPoint,JetBrains.DocumentModel.RunningDocumentId,JetBrains.Application.Changes.ModificationStamp,JetBrains.Platform.VisualStudio.SinceVs10.DocumentModel.VsDocumentInSyncMoments,JetBrains.Util.ILogger,Microsoft.VisualStudio.Text.PointTrackingMode)">
            <summary>
            Tracks a text position in time and in buffer graph, from some VS text view snapshot mapping point to a VS buffer version which corresponds to the given time stamp on the given document (using <see cref="T:JetBrains.Platform.VisualStudio.SinceVs10.DocumentModel.VsDocumentInSyncMoments" />).
            Might return NULL if in-sync version for this modification stamp is not known.
            In any VS versions, this will be allocating working objects (tracking spans). Use <see cref="T:Microsoft.VisualStudio.Text.ITextSnapshot" /> overload when possible.
            In newer VS versions, a non-allocating helper class exists (Tracking). Call it directly in Since* code whenever reasonable.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Shim.TextControl.ConversionDevTen.TryTrackInTime(JetBrains.TextControl.DocumentMarkup.Adornments.IntraTextAdornments.Careting.IntraTextPosition,JetBrains.Application.Changes.ModificationStamp,JetBrains.Application.Changes.ModificationStamp,JetBrains.DocumentModel.RunningDocumentId,JetBrains.Platform.VisualStudio.SinceVs10.DocumentModel.VsDocumentInSyncMoments,Microsoft.VisualStudio.Text.PointTrackingMode)">
            <summary>
            See <see cref="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Shim.TextControl.ConversionDevTen.TryTrackInTime(JetBrains.TextControl.DocOffset,JetBrains.Application.Changes.ModificationStamp,JetBrains.Application.Changes.ModificationStamp,JetBrains.DocumentModel.RunningDocumentId,JetBrains.Platform.VisualStudio.SinceVs10.DocumentModel.VsDocumentInSyncMoments,Microsoft.VisualStudio.Text.PointTrackingMode)" />.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Shim.TextControl.ConversionDevTen.TryTrackInTime(JetBrains.TextControl.DocOffset,JetBrains.Application.Changes.ModificationStamp,JetBrains.Application.Changes.ModificationStamp,JetBrains.DocumentModel.RunningDocumentId,JetBrains.Platform.VisualStudio.SinceVs10.DocumentModel.VsDocumentInSyncMoments,Microsoft.VisualStudio.Text.PointTrackingMode)">
            <summary>
            Tracks a text position (in our doc model data types) in time, from one VS buffer snapshot to another. Snapshots are identified by our document modification stamp.
            In any VS versions, this will be allocating working objects (tracking spans). Use <see cref="T:Microsoft.VisualStudio.Text.ITextSnapshot" /> overload when possible.
            In newer VS versions, a non-allocating helper class exists (Tracking). Call it directly in Since* code whenever reasonable.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Interop.VsFrameMoniker">
            <summary>
            Frame moniker format: "T:I:S:guid", where: 
            ':' is a separator;
            T - frame type: 'D' - document; 'T' - tool window; 'ST' - singleton tool window>; 
            I - instamce ID;
            S - surface ID;
            guid - tool window guid or document window moniker.
            </summary>
        </member>
        <member name="P:JetBrains.Platform.VisualStudio.SinceVs10.ProjectDocumentsNuget.NugetEventsWrapper.VsModel">
            <summary>
             Raw api to events
            </summary>
        </member>
        <member name="P:JetBrains.Platform.VisualStudio.SinceVs10.ProjectDocumentsNuget.NugetEventsWrapper.IsNugetRunningEx">
            <summary>
            True when NuGet is running at least one batch
            </summary>
        </member>
        <member name="P:JetBrains.Platform.VisualStudio.SinceVs10.ProjectDocumentsNuget.NugetEventsWrapper.ProjectsUpdated">
            <summary>
            Fires when NuGet batches finish. Contains projects that were updated by that batch.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.ProjectDocuments.References.Impl.FixReferencesWithoutDescriptorModifier">
            <inheritdoc />
            <summary>
            Explicitly call MsBuild to resolve references to unloaded projects.
            In VisualStudio 2010/ 2012 when unloaded project is referenced, Reference object does not contain path to its output unlike VisualStudio 2010
            see http://youtrack.jetbrains.com/issue/RSRP-329744
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.FindDocumentWindowFrameViaDocumentMoniker">
            <summary>
            Find the text view's window frame by enumerating all open document window frames.
            Used as a fallback when the service provider has not returned a window frame <see cref="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.FindWindowFrameViaTextViewServiceProvider"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.FindWindowFrameViaTextViewServiceProvider">
            <summary>
            For most text views, their window frame is but a wrapper over the VS Window Frame representing a document tab.
            Get it out of the service provider on the VS wrapper of the WPF text view.
            VS 10–11: We skip attaching text controls without frames, those should be handled manually, otherwise we do not have full context (eg a DevTen text control locally (bypassing RDT), eg in a refactoring preview, will not have a VS window frame — ok to skip here).
            VS 12: Here we got the new “Embedded Peek Text View” inserted as an island inside a big text view, which we also would like to treat as a text control, and it actually does not have a VS Window Frame on its own — we should execute special operations for finding its window frame.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.IFindWindowFrameForVsTextView">
            <summary>
            For most text views, their window frame is but a wrapper over the VS Window Frame representing a document tab. But sometimes it gets complicated.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.IFindWindowFrameForVsTextView.TryFindWindowFrameForVsTextView(Microsoft.VisualStudio.Text.Editor.IWpfTextView)">
            <summary>
            For most text views, their window frame is but a wrapper over the VS Window Frame representing a document tab. But sometimes it gets complicated.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.IFindWindowFrameForVsTextView.WindowFramePromise">
            <summary>
            Promises it will be able to return a window frame given a lifetime.
            </summary>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.ITrackVsTextViewDataForTextControlChanges">
            <summary>
            Tracks when any VS text view properties change which might need respawning a text control.
            Must be a Shell component.
            </summary>
        </member>
        <member name="P:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.ITrackVsTextViewDataForTextControlChanges.TextViewDataChanged">
            <summary>
            Notifies of the possible change in the view, or any of the existing views if value is NULL.
            Use <see cref="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.TrackVsTextViewDataForTextControlChangesEx.FireTextViewDataChanged(JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.ITrackVsTextViewDataForTextControlChanges,JetBrains.Lifetimes.Lifetime,JetBrains.Application.Threading.IShellLocks,System.Func{System.Boolean},Microsoft.VisualStudio.Text.Editor.IWpfTextView)" /> to fire the change so it works properly with guards and locks.
            there might be a situation when read lock is taken and guard is released. See <see cref="M:JetBrains.VsIntegration.Shell.Actions.Revised.SharedDataContext.AllowSharing(JetBrains.Lifetimes.Lifetime,JetBrains.Application.Threading.IShellLocks)" />
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.TrackVsTextViewDataForTextControlChanges">
            <inheritdoc cref="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.ITrackVsTextViewDataForTextControlChanges" />
        </member>
        <member name="P:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.TrackVsTextViewDataForTextControlChanges.JetBrains#Platform#VisualStudio#SinceVs10#TextControl#AttachTextControlsToTextViews#ITrackVsTextViewDataForTextControlChanges#TextViewDataChanged">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.TrackVsTextViewDataForTextControlChangesEx.FireTextViewDataChanged(JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.ITrackVsTextViewDataForTextControlChanges,JetBrains.Lifetimes.Lifetime,JetBrains.Application.Threading.IShellLocks,System.Func{System.Boolean},Microsoft.VisualStudio.Text.Editor.IWpfTextView)">
            <summary>
            Notifies of the possible change in the view, or any of the existing views if value is NULL.
            Use <see cref="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.TrackVsTextViewDataForTextControlChangesEx.FireTextViewDataChanged(JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.ITrackVsTextViewDataForTextControlChanges,JetBrains.Lifetimes.Lifetime,JetBrains.Application.Threading.IShellLocks,System.Func{System.Boolean},Microsoft.VisualStudio.Text.Editor.IWpfTextView)"/> to fire the change so it works properly with guards and locks.
            there might be a situation when read lock is taken and guard is released. See <see cref="M:JetBrains.VsIntegration.Shell.Actions.Revised.SharedDataContext.AllowSharing(JetBrains.Lifetimes.Lifetime,JetBrains.Application.Threading.IShellLocks)"/>
            </summary>
            <param name="trackVsTextViewDataForTextControlChanges">The interface that fires the signal</param>
            <param name="lifetime">Lifetime for queueing</param>
            <param name="locks">IShellLocks to take guard</param>
            <param name="isEventStillActual">Optional check if signal should be fired (things might be changed when queued)</param>
            <param name="wpfTextView">Optional argument for firing. Null means update all views</param>      
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.VsAttachTransportTextControlsToTextViews">
            <summary>
            Whenever we see a new text view, create our text control over it.
            We must give a document to the text control, which is normally per-solution, that's why 'tis a solution component.
            Solutionless text controls (eg LT editor) are created elsewhere.
            We hope no text view's buffer has corresponding IDocument in more than one solution :)
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.VsInPlaceTextControlViewDevTen">
            <summary>
            Renders a view for the Text Control Automation Object.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.VsInPlaceTextControlViewDevTen.#ctor">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.VsTextViewCollectorDevTen">
            <summary>
            Collects text views, getting them from any possible sources (MEF export collector, RDT events, by enumerating available text views periodically).
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.VsTextViewCollectorDevTen.AdviseViewClosedSafe(Microsoft.VisualStudio.Text.Editor.IWpfTextView,JetBrains.Util.JetWeakReference{JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.VsTextViewCollectorDevTen})">
            <summary>
            Prevents csc from pulling too many objects into the closure. Should have just the view (which defines the lifetime of all this stuff) and a weak ref to our object (which might live shorter if we're suspended).
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.VsTextViewCollectorDevTen.VsTextViewsGuarded">
            <summary>
            Lists the VS text controls (views) currently discovered. Guarded.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.VsTextViewCollectorDevTen.GetCurrentVsViewsFromRdt(JetBrains.VsIntegration.Interop.Shim.VsShell.Documents.IRunningDocumentTable,JetBrains.Application.Threading.IThreading,System.Lazy{Microsoft.VisualStudio.Editor.IVsEditorAdaptersFactoryService},System.Lazy{Microsoft.VisualStudio.TextManager.Interop.IVsTextManager})">
            <summary>
            Enums RDT buffers, then gets text views attached to them.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.VsTextViewDataForTextControlCollectorDevTen">
            <summary>
            Maintains a listing of <see cref="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.VsTextViewDataForTextControlDevTen" />, on which text controls should be created.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.VsTextViewDataForTextControlCollectorDevTen.VsTextViewsWithData">
            <summary>
            Text views which are ready for spawning text controls over them.
            When some crucial property changes for the text control, like a document to be attached to it, an item is revoked from this collection and re-added with new properties, so that the text control could be correctly re-created with the new properties, following the whole text control creation pipeline.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.VsTextViewDataForTextControlDevTen">
            <summary>
            Based on an <see cref="T:JetBrains.VsIntegration.Interop.Shim.TextManager.TextControl.IVsTextView" />, adds the data which is:
            (1) Sufficient to successfully create a text control over it.
            (2) Uniquely identifies the text control — that is, if this info changes, the text control should be respawned over the same text view.
            The main cause is that out text control strongly binds to the single document
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.VsTextViewSink">
            <summary>
            Monitors vs' creation of text views and maintains the <see cref="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.VsTextViewSink.VsTextViewsUnugarded"/> collection.
            This class is created by MEF, and its lifetime does not agree to the Shell lifetime.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.VsTextViewSink.VsTextViewsUnugarded">
            <summary>
            Lists the VS text controls (views).
            As this collection directly reflects the VS state, even at times when the Shell is not running, it's not guarded.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.VsTextViewSink.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:System.Object"/> class.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.VsTextViewSink.Microsoft#VisualStudio#Text#Editor#IWpfTextViewCreationListener#TextViewCreated(Microsoft.VisualStudio.Text.Editor.IWpfTextView)">
            <summary>
            Called when a text view having matchine roles is created over a text data model having a matching content type.
                        Exporters must specify at least one ContentTypeAttribute and one TextViewRole, and should mark their export using the following attribute:
                        [Export(typeof(TextViewCreationListener))], along with [ContentType()] and [TextViewRole()].
            </summary>
            <param name="textView">The newly created text view.</param>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.VsWindowFrameHelpersDevTen.AttachWindowFrameToTextViewRootParent(JetBrains.Lifetimes.Lifetime,JetBrains.Application.UI.WindowManagement.WindowFrame,System.Object,Microsoft.VisualStudio.Editor.IVsEditorAdaptersFactoryService,JetBrains.Application.Interop.NativeHook.IWindowsHookManager)">
            <summary>
            We cannot yet rip off information about the window off the <see cref="T:JetBrains.VsIntegration.Interop.Shim.VsShell.Shell.IVsWindowFrame" />.
            Thus, when we're attaching to a VS text control, we only know its <see cref="F:JetBrains.Application.UI.WindowManagement.WindowFrame.RootParentHwnd" /> from the text view.
            </summary>
            <param name="lifetime"></param>
            <param name="frame">Frame of the text control, to be completed with <see cref="F:JetBrains.Application.UI.WindowManagement.WindowFrame.RootParentHwnd" /> info.</param>
            <param name="textview">Text view of either implementation. HWND-based in Whidbey, Avalon-based in DevTen.</param>
            <param name="vsEditorAdaptersFactoryService"></param>
            <param name="hookman"></param>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.ContextNotifications.VsContextNotificationHost.CurrentViewCandidates">
            <summary>
            Tracks candidates. Focus events might be out of sync a bit, and we might see more than one at a time.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextControlCoordinateConversionDevTen.MarkersSingleLinePadding">
            <summary>
            Borrowed from <c>Microsoft.VisualStudio.Text.Utilities.Markers::SingleLinePadding</c>. Used when calculating marker background rect from text boundaries.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextControlCoordinateConversionDevTen.DocLineColumn_To_DocOffset(JetBrains.DocumentModel.DocumentCoords,Microsoft.VisualStudio.Text.Editor.IWpfTextView)">
            <summary>
            Uses VS Text Buffer lines.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextControlCoordinateConversionDevTen.DocLineColumn_To_DocOffset_ForSnapshot(JetBrains.DocumentModel.DocumentCoords,Microsoft.VisualStudio.Text.ITextSnapshot)">
            <summary>
            Uses VS Text Buffer lines.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextControlCoordinateConversionDevTen.DocOffset_To_DocLineColumn(JetBrains.TextControl.DocOffsetAndVirtual,Microsoft.VisualStudio.Text.Editor.IWpfTextView)">
            <summary>
            Uses VS Text Buffer lines.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextControlCoordinateConversionDevTen.EnumFullLineHeightBoundsForSpan(Microsoft.VisualStudio.Text.SnapshotSpan@,Microsoft.VisualStudio.Text.Editor.IWpfTextView,JetBrains.Util.dataStructures.FrugalLocalList{System.Windows.Rect}@)">
            <summary>
            Full text bounds
            This means the full height of the line, including any possible in-line adornments, like in VS12beta
            Mostly mimics <see cref="M:Microsoft.VisualStudio.Text.Editor.ITextViewLineCollection.GetNormalizedTextBounds(Microsoft.VisualStudio.Text.SnapshotSpan)" />, but without allocations.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextControlCoordinateConversionDevTen.EnumSignificantTextBoundsForSpan(Microsoft.VisualStudio.Text.SnapshotSpan@,System.Boolean,Microsoft.VisualStudio.Text.Editor.IWpfTextView,JetBrains.Util.dataStructures.FrugalLocalList{System.Windows.Rect}@)">
            <summary>
            This includes only the text glyphs, not any space allocated within the text view line for in-line adornments, like in VS12beta.
            This also does not include the whitespace in the beginning of the line.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextControlCoordinateConversionDevTen.GetSignificantTextBounds(Microsoft.VisualStudio.Text.Formatting.ITextViewLine,Microsoft.VisualStudio.Text.SnapshotSpan@,System.Boolean,System.Boolean,JetBrains.Util.dataStructures.FrugalLocalList{System.Windows.Rect}@,JetBrains.Util.dataStructures.FrugalLocalList{System.Windows.Rect}@,System.Boolean,System.Boolean)">
            <summary>
            Bounds of covered text, leading/tail whitespace excluded.
            </summary>
            <param name="line">Current text control line (not document line!).</param>
            <param name="editBufferSpan">The whole tag (might cover many lines), we're analyzing only one line here.</param>
            <param name="isLineFirst">For rects height (text only / fill to adjacent line).</param>
            <param name="isLineLast">For rects height (text only / fill to adjacent line).</param>
            <param name="boundrects">Filled with rects with text covered with span.</param>
            <param name="rectsWithExcludedNonWhitespaceChars">Optionally fills with rects of all non-edge-wsp chars in this line not covered with our span.</param>
            <param name="isCollectingExcludedNonWhitespaceChars">Whether to fill prev param. If <c>False</c>, safe to pass the same list twice, won't touch the second one.</param>
            <param name="skipWhitespaceChars">Skip whitespace characters if true</param>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextControlCoordinateConversionDevTen.GetTextViewLinesIntersectingSpan(Microsoft.VisualStudio.Text.SnapshotSpan@,Microsoft.VisualStudio.Text.Editor.IWpfTextView)">
            <summary>
            Basically the same as <see cref="M:Microsoft.VisualStudio.Text.Editor.ITextViewLineCollection.GetTextViewLinesIntersectingSpan(Microsoft.VisualStudio.Text.SnapshotSpan)" />, but nonallocating.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextControlCoordinateConversionDevTen.TextControlLineColumn_To_Viewport(JetBrains.TextControl.TextControlLineColumn,Microsoft.VisualStudio.Text.Editor.IWpfTextView)">
            <summary>
            This is the central char-to-pixel conversion method in the DevTen case.
            It has no such immanent thing as canvas coordinate system, only viewport-relative coords are defined with acceptable accuracy.
            The scrolling is probably in lines, and canvas coord depends on the line height of the lines above the view, which is not calculated until they get into the viewport.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextControlCoordinateConversionDevTen.TryMakeOutlineGeometryForTextBounds(Microsoft.VisualStudio.Text.SnapshotSpan@,Microsoft.VisualStudio.Text.Editor.IWpfTextView)">
            <summary>
            Makes an outline geometry for the tag.
            Basically, it's a minimum spanning rect. But it must have cuts on the first and the last lines, to let out anything not falling into the span (example: java-style braces).
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextControlCoordinateConversionDevTen.TryRenderOutlineGeometryForTextBounds(Microsoft.VisualStudio.Text.SnapshotSpan@,Microsoft.VisualStudio.Text.Editor.IWpfTextView,System.Windows.Media.StreamGeometryContext)">
            <summary>
            Makes an outline geometry for the tag.
            Basically, it's a minimum spanning rect. But it must have cuts on the first and the last lines, to let out anything not falling into the span (example: java-style braces).
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextControlCoordinateConversionDevTen.Viewport_To_TextControlLineColumn(System.Windows.Point,Microsoft.VisualStudio.Text.Editor.IWpfTextView)">
            <summary>
            This is the central pixel-to-char conversion method in the DevTen case.
            It has no such immanent thing as canvas coordinate system, only viewport-relative coords are defined with acceptable accuracy.
            The scrolling is probably in lines, and canvas coord depends on the line height of the lines above the view, which is not calculated until they get into the viewport.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextControlCoordinateConversionDevTen.GetAverageLineHeight(Microsoft.VisualStudio.Text.Editor.IWpfTextView)">
            <summary>
            Lines outside the viewport do not have layout, pixel coordinates, or height values.
            To approximate pixel y-coordinates outside the viewport, we use the average viewport line height.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextControlCoordinateConversionDevTen.GetTextViewLineNumber(Microsoft.VisualStudio.Text.Editor.IWpfTextView,Microsoft.VisualStudio.Text.Formatting.ITextViewLine,Microsoft.VisualStudio.Text.PointTrackingMode)">
            <summary>
            Takes the text view formatted line, maps it to the visual buffer and gets its line number in the visual buffer.
            </summary>
            <param name="textview">The owning text view. Used for getting the visual buffer.</param>
            <param name="line">The formatted line to get the number of.</param>
            <param name="whichend">Whether to try the beginning or the end of the formatted line for the text view line number. They're not mathematically guaranteed to be the same.</param>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextControlCoordinateConversionDevTen.GetViewportRectFromTextView(Microsoft.VisualStudio.Text.Editor.IWpfTextView)">
            <summary>
            Calculates the viewport rectangle in canvas coordinates.
            Guard-invariant (ie updates even when under a guard).
            NOTE: VS itself does not operate in terms of canvas coords, its coord space is relative to viewport, so use <see cref="T:Microsoft.VisualStudio.Text.Editor.IWpfTextView" />'s <c>Viewport*</c> members.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextControlCoordinateConversionDevTen.MapVsVirtualPoint_DocToTextControl(Microsoft.VisualStudio.Text.VirtualSnapshotPoint,Microsoft.VisualStudio.Text.Editor.IWpfTextView)">
            <summary>
            Raw mapping of VS snapshot points. Preserves virtual space.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextControlCoordinateConversionDevTen.MapVsVirtualPoint_TextControlToDoc(Microsoft.VisualStudio.Text.VirtualSnapshotPoint,Microsoft.VisualStudio.Text.Editor.IWpfTextView)">
            <summary>
            Raw mapping of VS snapshot points. Preserves virtual space.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextViewControlPosDevTen">
            <summary>
            A text control pos impl which does not rely on backend stuff like <see cref="T:JetBrains.TextControl.ITextControl" /> and <see cref="T:JetBrains.DocumentModel.IDocument" /> and fully operates on the VS text view.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextViewControlPosDevTen.#ctor(JetBrains.TextControl.DocOffsetAndVirtual,System.Nullable{System.Windows.Rect},Microsoft.VisualStudio.Text.Editor.IWpfTextView)">
            <summary>
            Inits the position.
            </summary>
            <param name="position">The basic position, now always based on the doc offset + virtual.</param>
            <param name="viewportExact">If originating from exact pixel position, retains that pixel position. Otherwise gets calculated from the pointed char.</param>
            <param name="vsTextView"></param>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextViewControlPosDevTen.System#IEquatable{JetBrains#TextControl#Coords#ITextControlPos}#Equals(JetBrains.TextControl.Coords.ITextControlPos)">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextViewControlPosDevTen.JetBrains#TextControl#Coords#ITextControlPos#TextControl">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextViewControlPosDevTen.JetBrains#TextControl#Coords#ITextControlPos#ToDocLineColumn">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextViewControlPosDevTen.JetBrains#TextControl#Coords#ITextControlPos#ToDocOffset">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextViewControlPosDevTen.JetBrains#TextControl#Coords#ITextControlPos#ToDocOffsetAndVirtual">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextViewControlPosDevTen.JetBrains#TextControl#Coords#ITextControlPos#ToRetainedPos">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextViewControlPosDevTen.JetBrains#TextControl#Coords#ITextControlPos#ToScreen">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextViewControlPosDevTen.JetBrains#TextControl#Coords#ITextControlPos#ToTextControlLineColumn">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextViewCoordsDevTen">
            <summary>
            A text control pos impl which does not rely on backend stuff like <see cref="T:JetBrains.TextControl.ITextControl" /> and <see cref="T:JetBrains.DocumentModel.IDocument" /> and fully operates on the VS text view.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextViewCoordsDevTen.#ctor(Microsoft.VisualStudio.Text.Editor.IWpfTextView)">
            <param name="vsTextView"></param>
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextViewCoordsDevTen.JetBrains#TextControl#Coords#ITextControlCoords#FromDocLineColumn(JetBrains.DocumentModel.DocumentCoords)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextViewCoordsDevTen.JetBrains#TextControl#Coords#ITextControlCoords#FromDocOffset(JetBrains.TextControl.DocOffset)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextViewCoordsDevTen.JetBrains#TextControl#Coords#ITextControlCoords#FromDocOffsetAndVirtual(JetBrains.TextControl.DocOffsetAndVirtual)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextViewCoordsDevTen.JetBrains#TextControl#Coords#ITextControlCoords#FromScreen(JetBrains.Util.Media.JetPhysicalPoint)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextViewCoordsDevTen.JetBrains#TextControl#Coords#ITextControlCoords#FromTextControlLineColumn(JetBrains.TextControl.TextControlLineColumn)">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.GrayCodeCompletion.Adornments.VsGrayCodeAdornmentRenderer">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.GrayCodeCompletion.ZoneMarker">
            TODO: Graycode completion should be rewritten without relying on backend text control zone
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.InplaceControl.VsCodeEditorDevTen">
            <summary>
            VS text control to be embedded into tool and popup windows.
            </summary>
            <remarks>
            The control works out of the box for VS tool windows, WinForms forms, and WPF windows.
            </remarks>>
        </member>
        <member name="P:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.InplaceControl.VsCodeEditorDevTen.WpfTextView">
            <summary>
            The text view. This is NOT the root UI Element of the text editor, see <see cref="P:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.InplaceControl.VsCodeEditorDevTen.RootUIElement" />.
            </summary>
        </member>
        <member name="P:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.InplaceControl.VsCodeEditorDevTen.RootUIElement">
            <summary>
            This is the root UI Element of the text editor UI controls graph. The WPF Text View itself sits somewhere under it.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.InplaceControl.VsCodeEditorDevTen.Params">
            <summary>
            Collects ctor params which are not components but actual data to be manually supplied by caller, for simplicity of syncing of declaration and call site.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.InplaceControl.VsCodeEditorDevTen.Params.#ctor(JetBrains.VsIntegration.Interop.Shim.TextManager.Documents.IVsTextBuffer,JetBrains.Application.UI.WindowManagement.WindowFrame,JetBrains.TextControl.TextControlHostedIn,JetBrains.TextControl.TextControlPreferences,System.Boolean,System.Boolean)">
            <summary>
            Collects ctor params which are not components but actual data to be manually supplied by caller, for simplicity of syncing of declaration and call site.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Intellisense.MEF.VsCompletionSourceSinceVs10">
            <summary>
            Hooks into VS10+ completion to dismiss VS completion sessions when R# is ready to show its own completion.
            It works in conjunction with <see cref="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Intellisense.VsTextControlIntellisenseComponent"/> text control component which implements all the logic.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Intellisense.VsIntellisenseUtil.DoNotDismissSessionKey">
            <summary>
            An intellisense session property with R# guid key serves as a flag that the session should not be dismissed.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Intellisense.VsIntellisenseUtil.IsVimWordCompletionActive(Microsoft.VisualStudio.Text.Editor.ITextView)">
            <summary>
            <para>VsVim extension has its own WordCompletion. R# should not dismiss it.</para>
            <para>For the completion session lifetime Vim sets a TextView property with a value of type Vim.UI.Wpf.Implementation.WordCompletion.WordCompletionSessionFactoryService.CompletionData</para>
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Intellisense.VsTextControlIntellisenseComponent.TryGetInsertionBuffer(Microsoft.VisualStudio.Language.Intellisense.IIntellisenseSession)">
            <summary>
            Return an insertion buffer for the trigger position of the intellisense session.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Intellisense.VsTextControlIntellisenseComponent.TryGetInsertionBuffer(Microsoft.VisualStudio.Text.Editor.ITextView,System.Nullable{Microsoft.VisualStudio.Text.SnapshotPoint})">
            <summary>
            Return an insertion buffer for the point of the text view.
            </summary>
        </member>
        <member name="P:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.InterLineBlocks.InterLineBlocksContext.Blocks">
            <summary>
            Blocks related to this particular text control
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.MapTextControlIdsToTextViews">
            <summary>
            For transport text controls (which have an ID of type <see cref="T:JetBrains.TextControl.RunningTextControlId" />), WPF Text Views are created or attached. This component keeps track of the mapping on the frontend.
            </summary>
            <remarks>
            An ID (and a Transport Text Control) gets associated with a text view when:
            (1) Frontend sees a new VS Text View created over a VS Text Buffer which represents a document we support, and creates a matching Transport Text Control for it.
            (2) Backend wants a UI control with a Text Control, initiates a Transport Text Control creation from back, and inserts a <see cref="T:JetBrains.TextControl.TextControlAutomation" /> into view on the front which causes a VS Text View to be spawned.
            There might be a VS Text View which has no Running Text Control ID / Transport Text Control associated, if it's not a regular text view or an unsupported VS Text Buffer kind.
            There might be a Running Text Control ID / Transport Text Control without a VS Text View associated, if it's been created on backend and either not intended for frontend (e.g. a mock <see cref="T:JetBrains.TextControl.BaseImpl.UselessTextControl" />) or intended for a UI control but its automation has not been placed into the view graph yet.
            Also it might be a transitional situation when stuff is being created or destroyed.
            It is preferable to write a <see cref="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlComponentAttribute" />-component which gets both the ID and view in its parameters (as a <see cref="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlDevTenEnvoy" />) and needs do no mapping.
            </remarks>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.MapTextControlIdsToTextViews.#ctor(JetBrains.Lifetimes.Lifetime,JetBrains.Util.ILogger,JetBrains.Application.Threading.IThreading)">
            <summary>
            For transport text controls (which have an ID of type <see cref="T:JetBrains.TextControl.RunningTextControlId" />), WPF Text Views are created or attached. This component keeps track of the mapping on the frontend.
            </summary>
            <remarks>
            An ID (and a Transport Text Control) gets associated with a text view when:
            (1) Frontend sees a new VS Text View created over a VS Text Buffer which represents a document we support, and creates a matching Transport Text Control for it.
            (2) Backend wants a UI control with a Text Control, initiates a Transport Text Control creation from back, and inserts a <see cref="T:JetBrains.TextControl.TextControlAutomation" /> into view on the front which causes a VS Text View to be spawned.
            There might be a VS Text View which has no Running Text Control ID / Transport Text Control associated, if it's not a regular text view or an unsupported VS Text Buffer kind.
            There might be a Running Text Control ID / Transport Text Control without a VS Text View associated, if it's been created on backend and either not intended for frontend (e.g. a mock <see cref="T:JetBrains.TextControl.BaseImpl.UselessTextControl" />) or intended for a UI control but its automation has not been placed into the view graph yet.
            Also it might be a transitional situation when stuff is being created or destroyed.
            It is preferable to write a <see cref="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlComponentAttribute" />-component which gets both the ID and view in its parameters (as a <see cref="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlDevTenEnvoy" />) and needs do no mapping.
            </remarks>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.MapTextControlIdsToTextViews.EnumTextViews">
            <summary>
            Gets currently known text controls which have attached views.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.MapTextControlIdsToTextViews.GetIdByViewLive(JetBrains.Lifetimes.Lifetime,Microsoft.VisualStudio.Text.Editor.IWpfTextView)">
            <summary>
            Gets a non-NULL property whose value is a Running Text Control ID (which represents a Transport Text Control) for a VS Text View, when such has been attached to that text view, or NULL at other times.
            See remarks on <see cref="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.MapTextControlIdsToTextViews" /> to see when it's NULL.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.MapTextControlIdsToTextViews.GetViewByIdLive(JetBrains.Lifetimes.Lifetime,JetBrains.TextControl.RunningTextControlId)">
            <summary>
            Gets a non-NULL property whose value is a VS Text View for a Running Text Control ID (which represents a Transport Text Control), when such has been attached to that text view, or NULL at other times.
            See remarks on <see cref="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.MapTextControlIdsToTextViews" /> to see when it's NULL.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.MapTextControlIdsToTextViews.TryGetIdByView(Microsoft.VisualStudio.Text.Editor.IWpfTextView)">
            <summary>
            Gets a Running Text Control ID (which represents a Transport Text Control) for a VS Text View, if such has been attached to that text view, or NULL.
            See remarks on <see cref="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.MapTextControlIdsToTextViews" /> to see when it's NULL.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.MapTextControlIdsToTextViews.TryGetViewById(JetBrains.TextControl.RunningTextControlId)">
            <summary>
            Gets a VS Text View for a Running Text Control ID (which represents a Transport Text Control), if such has been attached to that text view, or NULL.
            See remarks on <see cref="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.MapTextControlIdsToTextViews" /> to see when it's NULL.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.MapTextControlIdsToTextViewsEx.GetTextControlId(Microsoft.VisualStudio.Text.Editor.IWpfTextView,JetBrains.Platform.VisualStudio.SinceVs10.TextControl.MapTextControlIdsToTextViews)">
            <summary>
            This overload throws an exception when there is nothing to return.
            </summary>
            <inheritdoc cref="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.MapTextControlIdsToTextViews.TryGetIdByView(Microsoft.VisualStudio.Text.Editor.IWpfTextView)" />
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.MapTextControlIdsToTextViewsEx.GetTextControlIdLive(Microsoft.VisualStudio.Text.Editor.IWpfTextView,JetBrains.Lifetimes.Lifetime,JetBrains.Platform.VisualStudio.SinceVs10.TextControl.MapTextControlIdsToTextViews)">
            <inheritdoc cref="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.MapTextControlIdsToTextViews.GetIdByViewLive(JetBrains.Lifetimes.Lifetime,Microsoft.VisualStudio.Text.Editor.IWpfTextView)" />
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.MapTextControlIdsToTextViewsEx.GetVsTextView(JetBrains.TextControl.RunningTextControlId,JetBrains.Platform.VisualStudio.SinceVs10.TextControl.MapTextControlIdsToTextViews)">
            <summary>
            This overload throws an exception when there is nothing to return.
            </summary>
            <inheritdoc cref="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.MapTextControlIdsToTextViews.TryGetViewById(JetBrains.TextControl.RunningTextControlId)" />
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.MapTextControlIdsToTextViewsEx.GetVsTextViewLive(JetBrains.TextControl.RunningTextControlId,JetBrains.Lifetimes.Lifetime,JetBrains.Platform.VisualStudio.SinceVs10.TextControl.MapTextControlIdsToTextViews)">
            <inheritdoc cref="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.MapTextControlIdsToTextViews.GetViewByIdLive(JetBrains.Lifetimes.Lifetime,JetBrains.TextControl.RunningTextControlId)" />
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.MapTextControlIdsToTextViewsEx.TryGetTextControlId(Microsoft.VisualStudio.Text.Editor.IWpfTextView,JetBrains.Platform.VisualStudio.SinceVs10.TextControl.MapTextControlIdsToTextViews)">
            <inheritdoc cref="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.MapTextControlIdsToTextViews.TryGetIdByView(Microsoft.VisualStudio.Text.Editor.IWpfTextView)" />
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.MapTextControlIdsToTextViewsEx.TryGetVsTextView(JetBrains.TextControl.RunningTextControlId,JetBrains.Platform.VisualStudio.SinceVs10.TextControl.MapTextControlIdsToTextViews)">
            <inheritdoc cref="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.MapTextControlIdsToTextViews.TryGetViewById(JetBrains.TextControl.RunningTextControlId)" />
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlDynamicMargin">
            <summary>
            A dynamic (runtime-defined) margin for the <see cref="T:Microsoft.VisualStudio.Text.Editor.IWpfTextView"/>-kind text control.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlDynamicMargin.myCachedUiElement">
            <summary>
            Create one from the <see cref="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlDynamicMargin.myData"/>, cache from then on.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlDynamicMargin.#ctor(JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlDynamicMargin.Data)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Object"/> class.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlDynamicMargin.AddToTextControl(Microsoft.VisualStudio.Text.Editor.IWpfTextView,JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlDynamicMargin.Data,System.Windows.Controls.Dock,Microsoft.VisualStudio.Editor.IVsEditorAdaptersFactoryService,JetBrains.Application.IApplicationHost)">
            <summary>
            Adds a margin/provider to the text control.
            </summary>
            <param name="textview">The host.</param>
            <param name="data">Describes the margin to be created.</param>
            <param name="dock">The side of the text control to dock the margin at.</param>
            <param name="vsEditorAdaptersFactoryService"></param>
            <param name="applicationDescriptor"></param>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlDynamicMargin.System#IDisposable#Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlDynamicMargin.Microsoft#VisualStudio#Text#Editor#ITextViewMargin#GetTextViewMargin(System.String)">
            <summary>
            Gets the <see cref="T:Microsoft.VisualStudio.Text.Editor.ITextViewMargin"/> with the given <paramref name="marginName"/>.
            </summary>
            <param name="marginName">The name of the <see cref="T:Microsoft.VisualStudio.Text.Editor.ITextViewMargin"/>.</param>
            <returns>
            The <see cref="T:Microsoft.VisualStudio.Text.Editor.ITextViewMargin"/> named <paramref name="marginName"/>, or null if no match is found.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="marginName"/> is null.</exception>
            <remarks>
            A margin must return itself if passed its name, and a container margin must forward the call to its children.
            </remarks>
        </member>
        <member name="P:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlDynamicMargin.Microsoft#VisualStudio#Text#Editor#ITextViewMargin#Enabled">
            <summary>
            Determines whether the margin is enabled.
            </summary>
            <exception cref="T:System.ObjectDisposedException">The margin is disposed.</exception>
        </member>
        <member name="P:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlDynamicMargin.Microsoft#VisualStudio#Text#Editor#ITextViewMargin#MarginSize">
            <summary>
            Gets the size of the margin. 
            </summary>
            <remarks>
            For a horizontal margin this is the height of the margin, 
                        since the width will be determined by the <see cref="T:Microsoft.VisualStudio.Text.Editor.ITextView"/>. 
                        For a vertical margin this is the width of the margin, since the height will be determined by the <see cref="T:Microsoft.VisualStudio.Text.Editor.ITextView"/>.
            </remarks>
            <exception cref="T:System.ObjectDisposedException">The margin is disposed.</exception>
        </member>
        <member name="P:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlDynamicMargin.Microsoft#VisualStudio#Text#Editor#IWpfTextViewMargin#VisualElement">
            <summary>
            Gets the FrameworkElement that renders the margin.
            </summary>
            <exception cref="T:System.ObjectDisposedException">if the margin is disposed.</exception>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlDynamicMargin.Data">
            <summary>
            Describes the margin context to be dragged thru the provider and so on.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlDynamicMargin.Data.#ctor(JetBrains.Lifetimes.Lifetime,System.String,System.Double,System.Func{JetBrains.Lifetimes.Lifetime,System.Windows.FrameworkElement})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Object"/> class.
            </summary>
            <param name="lifetime"></param>
            <param name="id">Margin name. One can get a margin by its name from the text view.</param>
            <param name="width">Margin width, in logical pixels.</param>
            <param name="FCreateView">Creates the presentation for the new margin, given its lifetime.</param>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlDynamicMargin.Provider">
            <summary>
            A provider to create the preconfigured margin.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlDynamicMargin.Provider.Clone">
            <summary>
            Used in contexts where a <c>Func</c> for creating a provider is required.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlDynamicMargin.Provider.Microsoft#VisualStudio#Text#Editor#IWpfTextViewMarginProvider#CreateMargin(Microsoft.VisualStudio.Text.Editor.IWpfTextViewHost,Microsoft.VisualStudio.Text.Editor.IWpfTextViewMargin)">
            <summary>
            Creates an <see cref="T:Microsoft.VisualStudio.Text.Editor.IWpfTextViewMargin"/> for the given <see cref="T:Microsoft.VisualStudio.Text.Editor.IWpfTextViewHost"/>.
            </summary>
            d\
                        <param name="wpfTextViewHost">The <see cref="T:Microsoft.VisualStudio.Text.Editor.IWpfTextViewHost"/> for which to create the <see cref="T:Microsoft.VisualStudio.Text.Editor.IWpfTextViewMargin"/>.</param><param name="marginContainer">The margin that will contain the newly-created margin.</param>
            <returns>
            The <see cref="T:Microsoft.VisualStudio.Text.Editor.IWpfTextViewMargin"/>.  
                        The value may be null if this <see cref="T:Microsoft.VisualStudio.Text.Editor.IWpfTextViewMarginProvider"/> does not participate for this context.
            </returns>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlMarginDevTen">
            <summary>
            The common margin implementation type.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlMarginDevTenEx.GetMargin(Microsoft.VisualStudio.Text.Editor.ITextView,System.Windows.Controls.Dock)">
            <summary>
            Gets our multi-control-host margin from the text view.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlMarginProviderBaseDevTen">
            <summary>
            Base class for standard around-the-editor margins.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlMarginProviderBaseDevTen.MarginTextViewRole00">
            <summary>
            Works for most of the views.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlMarginProviderBaseDevTen.MarginTextViewRole01">
            <summary>
            Smth new with VS12: a peek view inserted into a larger text view. Requires a separate flag to run a margin inside.
            In older VSes would be silently ignored.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlMarginProviderBottomDevTen">
            <summary>
            Bottom standard margin.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlMarginProviderBottomDevTen.#ctor">
            <summary>
            Bottom standard margin.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlMarginProviderLeftDevTen">
            <summary>
            Left standard margin.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlMarginProviderLeftDevTen.#ctor">
            <summary>
            Left standard margin.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlMarginProviderRightDevTen">
            <summary>
            Right standard margin.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlMarginProviderRightDevTen.#ctor">
            <summary>
            Right standard margin.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlMarginProviderTopDevTen">
            <summary>
            Top standard margin.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlMarginProviderTopDevTen.#ctor">
            <summary>
            Top standard margin.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.Adornments.InterLineAdornments.InterLinePosition">
            <summary>
            Determines the inter line element's preferences for placing between lines. <br/>
            Takes part in inter line adornments space allocation and rendering.
            </summary>
            <param name="VerticalPriority">The higher the value the lower the element is placed.</param>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.Adornments.InterLineAdornments.InterLinePosition.#ctor(System.Double,System.Boolean,System.Func{System.Double},System.Windows.Size,System.Windows.Thickness)">
            <summary>
            Determines the inter line element's preferences for placing between lines. <br/>
            Takes part in inter line adornments space allocation and rendering.
            </summary>
            <param name="VerticalPriority">The higher the value the lower the element is placed.</param>
        </member>
        <member name="P:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.Adornments.InterLineAdornments.InterLinePosition.VerticalPriority">
            <summary>The higher the value the lower the element is placed.</summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.Adornments.InterLineAdornments.InterLineAdornmentsPlaceManager">
            <summary>
            Tracks all the taggers whose tags were marked by implementing <see cref="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.Adornments.InterLineAdornments.IInterLineAdornmentTag"/> <br/>
            Arranges inter line space according to tags priorities. <br/>
            Use it for rendering and hit testing your inter line adornments.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.Adornments.InterLineAdornments.InterLineAdornmentsPlaceManager.TagsChanged">
            <summary>
            Indicates that inter line adornments tags changed which means that we must rearrange and repaint
            all inter line adornments.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.Adornments.InterLineAdornments.IInterLineAdornmentTag">
            <summary>
            Indicates that tag may require inter line space. <br/>
            IMPORTANT: If your tagger may yield tags that require inter line space mark your tagger's tag by implementing this interface.
            <seealso cref="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.Adornments.InterLineAdornments.InterLineAdornmentsPlaceManager"/>
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.Adornments.InterLineAdornments.VsInterLineAdornmentRenderer">
            <summary>
            <inheritdoc/> <br/>
            Special implementation for rendering adornments located between lines.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.Adornments.IntraTextAdornments.CaretIntraDetails.IntraPosition">
            <summary>
            Doc offset (in <see cref="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.Adornments.IntraTextAdornments.CaretIntraDetails.ModificationStamp" />) plus intra offset.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.Adornments.IntraTextAdornments.CaretIntraDetails.ModificationStamp">
            <summary>
            Stamp for doc offset in <see cref="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.Adornments.IntraTextAdornments.CaretIntraDetails.IntraPosition" />.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.Adornments.IntraTextAdornments.IIntraTextAdornmentBaselineProvider.GetTextBaseline(System.Double,System.Double)">
            <summary>
            A proper way for text baseline estimation may vary depending on the VS version
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.Adornments.IntraTextAdornments.VsIntraTextAdornmentRenderer">
            <summary>
            <inheritdoc/> <br/>
            Special implementation for rendering adornments located between text characters.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.Adornments.VsAdornmentPresentationBase">
            <summary>
            Per-adornment lightweight presentation object. <br/>
            Caches information on measurements which have to be calculated for tagging the size and then reused for actually rendering. <br/>
            Serves as the tag identity.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.Adornments.VsAdornmentPresentationBase.HitTestResult.Client">
            <summary>
            Proper hitting filled background.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.Adornments.VsAdornmentPresentationBase.HitTestResult.NonClient">
            <summary>
            Within allocated space for the tag, but outside its filled background (=> should not be considered hit).
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.Adornments.VsAdornmentPresentationWithTextBase.GetTextMeasurement(System.Windows.Media.FormattedText)">
            <summary>
            What we take into account from the text line when measuring
            </summary>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.Adornments.VsAdornmentRendererBase">
            <summary>
            Feeds data into the tagger.
            Inserts a layer for presenting them, and creates the view control there.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.Adornments.VsAdornmentRendererBase.#ctor(JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlDevTenEnvoy,JetBrains.Application.Threading.IThreading,JetBrains.Util.ILogger)">
            <summary>
            Feeds data into the tagger.
            Inserts a layer for presenting them, and creates the view control there.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.Adornments.VsAdornmentViewBase">
            <summary>
            Implements adornments rendering process based on VS tagging mechanism.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.Adornments.VsAdornmentViewBase.TaggerProviderTag">
            <summary>
            Provider tag for the yielded tags related to adornment.
            Different adornment or adornment layers have different taggers.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.Adornments.VsAdornmentViewBase.PresentationShouldBeRendered(JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.Adornments.VsAdornmentPresentationBase)">
            <summary>
            Filter presentations that are provided by <see cref="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.Adornments.VsAdornmentViewBase.TaggerProviderTag"/>
            but aren't supposed to be rendered due to some reason.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.Adornments.VsAdornmentViewBase.HitTestCore(System.Windows.Media.PointHitTestParameters)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.Adornments.VsAdornmentViewBase.MeasureCore(System.Windows.Size)">
            <summary>
            We don't need this for rendering, but some of our helpers like mouse down handler check RenderSize and to get it right we should declare that we have it (set in base ArrangeCore).
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.Adornments.VsAdornmentWithHighlighterPresentationBase">
            <inheritdoc/>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.Adornments.VsAdornmentWithHighlighterPresentationBase.#ctor(JetBrains.TextControl.DocumentMarkup.Adornments.AdornmentsTransportBase.AdornmentHighlighter@,JetBrains.Application.Changes.ModificationStamp)">
            <inheritdoc/>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.Adornments.VsAdornmentWithHighlighterRendererBase`2">
            <summary>
            <inheritdoc />
            Additionally binds adorns highlighters transport to tags invalidation and adornment interaction.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.Adornments.VsAdornmentWithHighlighterRendererBase`2.#ctor(JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlDevTenEnvoy,JetBrains.Application.Threading.IThreading,JetBrains.Application.Components.ILazy{JetBrains.Platform.VisualStudio.SinceVs10.DocumentModel.VsDocumentInSyncMoments},JetBrains.TextControl.Transport.TransportTextControl,JetBrains.DataFlow.PropertyId{`1},JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlViewportTrackingForTransport,JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.Adornments.VsTextControlPushToHint,JetBrains.Application.Components.ILazy{Microsoft.VisualStudio.Text.Projection.IBufferGraphFactoryService},JetBrains.Application.Components.ILazy{Microsoft.VisualStudio.Editor.IVsEditorAdaptersFactoryService},JetBrains.Platform.VisualStudio.Protocol.Frontend.TextControl.IVsHighlighterCustomization,JetBrains.Application.UI.Components.Theming.ITheming,JetBrains.Util.ILogger)">
            <summary>
            <inheritdoc />
            Additionally binds adorns highlighters transport to tags invalidation and adornment interaction.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.Adornments.VsAdornmentWithHighlighterViewBase.MouseDownRequested">
            <summary>
            Offsets not adjusted, match the given stamp.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.Adornments.VsAdornmentWithHighlighterViewBase.TooltipRequested">
            <summary>
            Offsets not adjusted, match the given stamp.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.Adornments.VsTextControlPushToHint">
            <summary>
            Monitors text control front to see when push to hint should be active, exposes the state property.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.Adornments.VsTextControlPushToHint.myCtrlPressCountDecrementInterval">
            <summary>
            Interval for catching the second pressing
            of ctrl button after which <see cref="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.Adornments.VsTextControlPushToHint.myIsPermanentMode"/> is set at true
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.FormatDefinitions.GeneratedClassificationFormatDefinitionBase">
            <summary>
            Base class of all generated VS classification format definitions.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.FormatDefinitions.Install.VsPackageEmitsVsClassificationFormatDefinitions">
            <summary>
            Classification definition classes are required to have highlighters in VS10+ text editor.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.FormatDefinitions.VsClassificationPriority">
            <summary>
            VS standard priorities:
              Low Priority
              Default Priority
                Natural Language Priority
                Formal Language Priority
                MarkerPlaceHolder
             High Priority
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.GutterMarks.GlyphMargin.VsGlyphFactoryProvider.VsGlyphFactory.Microsoft#VisualStudio#Text#Editor#IGlyphFactory#GenerateGlyph(Microsoft.VisualStudio.Text.Formatting.IWpfTextViewLine,Microsoft.VisualStudio.Text.Editor.IGlyphTag)">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.GutterMarks.GlyphMargin.VsGlyphMarginTag">
            <summary>
            A produce of <see cref="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.GutterMarks.GlyphMargin.VsGlyphMarginTagger" />, sits in a VS document (text buffer), but applies to a specific VS text control (text view) because it's been baked for it.
            Consumed by <see cref="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.GutterMarks.GlyphMargin.VsGlyphFactoryProvider" /> which makes a view element over it.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.GutterMarks.GlyphMargin.VsGlyphMarginTagger">
            <summary>
            Serves VS native gutter marks.
            NOTE this is per-document, not per-text-control!
            This is only operational if we have to JetActionMargin active, otherwise the action margin takes on rendering everything.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.GutterMarks.GlyphMargin.VsGlyphMarginTagger.Microsoft#VisualStudio#Text#Tagging#ITagger{JetBrains#Platform#VisualStudio#SinceVs10#TextControl#Markup#GutterMarks#GlyphMargin#VsGlyphMarginTag}#GetTags(Microsoft.VisualStudio.Text.NormalizedSnapshotSpanCollection)">
            <inheritdoc />
        </member>
        <member name="E:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.GutterMarks.GlyphMargin.VsGlyphMarginTagger.Microsoft#VisualStudio#Text#Tagging#ITagger{JetBrains#Platform#VisualStudio#SinceVs10#TextControl#Markup#GutterMarks#GlyphMargin#VsGlyphMarginTag}#TagsChanged">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.GutterMarks.GlyphMargin.VsGlyphMarginTagger.VsGlyphMarginTaggerDataOnTextBuffer">
            <summary>
            Stored in VS Text Buffer userdata, per frontend document.
            Running text controls know which combined gutter marks per view line they want to show on the VS native glyph margin, so they put this info here.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.GutterMarks.GlyphMargin.VsGlyphMarginTagger.VsGlyphMarginTaggerDataOnTextBuffer.MapDataForTextViews">
            <summary>
            The tagger is per-document, but each text control over the document has its own layout and its set of glyphs might differ, especially if contextual.
            So they have all to be added to the document by the tagger as tags, and then differentiated when the factory wants to create glyphs for them.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.GutterMarks.GlyphMargin.VsGlyphMarginTagger.VsGlyphMarginTaggerDataOnTextBuffer.PerTextView.GutterMarks">
            <summary>
            Common transport.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.GutterMarks.GlyphMargin.VsGlyphMarginTagger.VsGlyphMarginTaggerDataOnTextBuffer.PerTextView.Lifetime">
            <summary>
            Limiting lifetime for use of components.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.GutterMarks.GlyphMargin.VsGlyphMarginTagger.VsGlyphMarginTaggerDataOnTextBuffer.PerTextView.LinesSession">
            <summary>
            Specific session for this text control out of all sessions in <see cref="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.GutterMarks.GlyphMargin.VsGlyphMarginTagger.VsGlyphMarginTaggerDataOnTextBuffer.PerTextView.GutterMarks" />.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.GutterMarks.GlyphMargin.VsGlyphMarginTaggerProvider">
            <summary>
            Tells VS we have <see cref="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.GutterMarks.GlyphMargin.VsGlyphMarginTagger" />.
            NOTE this is asked per-document, not per-text-control.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.GutterMarks.GlyphMargin.VsGlyphMarginTaggerProvider.Microsoft#VisualStudio#Text#Tagging#ITaggerProvider#CreateTagger``1(Microsoft.VisualStudio.Text.ITextBuffer)">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.GutterMarks.GutterMarksFrontendServices.IGutterMarkLineRequestOptionsProvider">
            <summary>
            Add custom options to <see cref="T:JetBrains.TextControl.DocumentMarkup.GutterMarksTransport.LineRequest" />.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.GutterMarks.GutterMarksFrontendServices.JetActionMarginActiveSession">
            <summary>
            Pushed to the text view to pass the shared lines request session object, and its presence tells whether the action margin should be active.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.GutterMarks.JetActionMargin.VsJetActionMargin.ContextIfShouldBeVisible">
            <summary>
            A valid context whenif we should create a view for this margin.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.GutterMarks.JetActionMargin.VsJetActionMargin.myLifetimeDefinitionUnreliable">
            <summary>
            #RSRP-453770. VS 2015 does not dispose margins on exit, so EnsureEverTerminated() is removed.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.GutterMarks.JetActionMargin.VsJetActionMargin.System#IDisposable#Dispose">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.GutterMarks.JetActionMargin.VsJetActionMargin.Microsoft#VisualStudio#Text#Editor#ITextViewMargin#Enabled">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.GutterMarks.JetActionMargin.VsJetActionMargin.Microsoft#VisualStudio#Text#Editor#ITextViewMargin#GetTextViewMargin(System.String)">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.GutterMarks.JetActionMargin.VsJetActionMargin.Microsoft#VisualStudio#Text#Editor#ITextViewMargin#MarginSize">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.GutterMarks.JetActionMargin.VsJetActionMargin.Microsoft#VisualStudio#Text#Editor#IWpfTextViewMargin#VisualElement">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.GutterMarks.JetActionMargin.VsJetActionMarginProvider">
            <summary>
            Jet Action Margin — to the left of the text editor view, similar to the standard Glyph Margin, but for our glyphs exclusively, plus the bulb menu.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.GutterMarks.JetActionMargin.VsJetActionMarginView.myArrangedGlyphs">
            <summary>
            Changed under local reentrancy guard. Sorted by bounds top coord.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.GutterMarks.JetActionMargin.VsJetActionMarginView.#ctor(JetBrains.Lifetimes.Lifetime,JetBrains.TextControl.DocumentMarkup.GutterMarksTransport,JetBrains.TextControl.DocumentMarkup.GutterMarksTransport.GutterMarksInLinesSession,Microsoft.VisualStudio.Text.Editor.IWpfTextViewHost,JetBrains.Application.Threading.IThreading,JetBrains.Application.Icons.IThemedIconManager,JetBrains.Application.UI.PopupLayout.PopupWindowContextSource,JetBrains.Application.Interop.NativeHook.IWindowsHookManager,JetBrains.Util.ILogger)">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.GutterMarks.JetActionMargin.VsJetActionMarginView.ArrangedGlyphs">
            <summary>
            For diagnostic purposes.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.GutterMarks.JetActionMargin.VsJetActionMarginView.ArrangeCore(System.Windows.Rect)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.GutterMarks.JetActionMargin.VsJetActionMarginView.MeasureCore(System.Windows.Size)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.GutterMarks.JetActionMargin.VsJetActionMarginView.OnRender(System.Windows.Media.DrawingContext)">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.GutterMarks.JetActionMargin.VsJetActionMarginView.ArrangedGlyph">
            <summary>
            Glyph totally ready for rendering and mousing. Updated in <see cref="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.GutterMarks.JetActionMargin.VsJetActionMarginView.ArrangeGlyphs(System.Windows.Rect)" /> based on the current <see cref="!:GutterMarksTransport.FwdGlyphsInLinesResponse" />.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.PushToHintStateTransportSender">
            <summary>
            Establishes the <see cref="T:JetBrains.TextControl.DocumentMarkup.PushToHintTransport"/> updating
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.VsHighlighterClassifications">
            <summary>
            Helps with getting Text Classification Types for our registered highlighters correctly.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.VsHighlighterClassifications.myCacheByAttrId">
            <summary>
            Cache request results + report errors only once.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.VsHighlighterClassifications.myCacheByAttrIdHash">
            <summary>
            Cache request results + report errors only once.
            </summary>
        </member>
        <member name="P:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.VsHighlighterClassifications.DummyClassificationType">
            <summary>
            For use as a dummy fallback. Expected to exist.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.VsHighlighterClassifications.GetClassificationType(System.String)">
            <summary>
            Gets the registered VS classification type for this highlighter, with all fallbacks as appropriate.
            In case of an error, reports an exception and returns some dummy classification.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.VsHighlighterClassifications.GetClassificationType(JetBrains.Util.Maths.OWORD)">
            <summary>
            Gets the registered VS classification type for this highlighter, with all fallbacks as appropriate.
            In case of an error, reports an exception and returns some dummy classification.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.VsRegisterHighlighterAdornmentLayers">
            <summary>
            Allocate layers for use when creating adornment elements.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.VsTextViewRangeMappingFromDocument">
            <summary>
            Spans in text view map to ranges in our documents in a complicated way:
            • Versions. As info travels from back to front, the text view might already be ahead with a newer version of text.
            • Projections. Complex text views (like HTML and Razor prior to VS17) operate on text buffers projected from the original “document” text buffers from the RDT.
            This class handles mapping for a single session of a tagger call (specific spans requested, specific set of versions).
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.VsTextViewRangeMappingFromDocument.TryCreateSessionForSnapshot(Microsoft.VisualStudio.Text.NormalizedSnapshotSpanCollection,JetBrains.Application.Changes.ModificationStamp)">
            <summary>
            When asked on a specific set of front snapshot spans and back doc version, prepares the mapping and range checks session.
            Intended for a single tagger ask run.
            </summary>
            <param name="spansRequested">
            1) Identifies the text buffer snapshot into which we will be mapping.
            2) Declares a range we will be serving (given to us as an argument to tagger, or the viewport range for an adornment layer). This can later be accessed with <see cref="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.VsTextViewRangeMappingFromDocument.Session.IsRelevantToRequestOnFront(Microsoft.VisualStudio.Text.SnapshotSpan@)" />, <see cref="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.VsTextViewRangeMappingFromDocument.Session.IsRelevantToRequestOnBack(JetBrains.Util.TextRange@)" />.
            </param>
            <param name="stamp">Identifies the document revision from which we will be mapping into the front revision given by <paramref name="spansRequested" />.</param>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.VsTextViewRangeMappingFromDocument.Session.mySnapshotBottomForMapping">
            <summary>
            A snapshot in the text buffer which corresponds to our document in the graph which can be used for mapping up to top.
            NOTE that our document might be in sync with this or another snapshot (but we only have that snapshot as a version and not a snapshot).
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.VsTextViewRangeMappingFromDocument.Session.mySnapshotOfRequest">
            <summary>
            Snapshot in the topmost buffer in which we must return spans in the end.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.VsTextViewRangeMappingFromDocument.Session.VersionInSyncWithDocument">
            <summary>
            Version in sync with the doc, on the same buffer as <see cref="T:Microsoft.VisualStudio.Text.ITextSnapshot" />.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.VsTextViewTagger`1">
            <summary>
            A common view tagger impl.
            Register by creating an instance in a <see cref="T:Microsoft.VisualStudio.Text.Tagging.IViewTaggerProvider" />-exporting class.
            Use by attaching to the live list from <see cref="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.VsTextViewTagger`1.GetTaggersOverTextView(Microsoft.VisualStudio.Text.Editor.ITextView)" /> in a <see cref="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlComponentAttribute" />-class over its view.
            </summary>
            <typeparam name="TTag"></typeparam>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.VsTextViewTagger`1.ContentType">
            <summary>
              <para>The content type you should specify on the view tagger content type filter.</para>
              <para>Currently, a no-filter, <see cref="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.VsTextViewTagger`1.TryCreateTagger``1(Microsoft.VisualStudio.Text.Editor.ITextView,Microsoft.VisualStudio.Text.ITextBuffer)" /> will hand-pick the proper buffer, because the actual content type of the buffer will be implementation-dependent (code/text in regular views, projection in legacy razor views, potentially anything else).</para>
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.VsTextViewTagger`1.myLifetimeDefinitionNonGuaranteed">
            <summary>
            Not always guaranteed to be terminated.
            When the tagger is created temporarily, it will most probably be called.
            When the tagger lives with the view, it might be just dropped.
            So do not rely native resources on it, but can put view-detach acvitivies.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.VsTextViewTagger`1.TagsChanged">
            <summary>
            Sink to provide tags.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.VsTextViewTagger`1.ParticularAreaTagsChanged">
            <summary>
            <inheritdoc cref="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.VsTextViewTagger`1.TagsChanged"/> <br/>
            Allows to specify a specific area for tags updating that prevents e.g. adorns blinking while scrolling. 
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.VsTextViewTagger`1.TagsRequested">
            <summary>
            Fire to cause your tagger be re-requested.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.VsTextViewTagger`1.GetTaggersOverTextView(Microsoft.VisualStudio.Text.Editor.ITextView)">
            <summary>
            Gets all taggers that have been created over this text view and should be serving tags.
            Note that they might be attached to different buffers and queried for tags over those buffers, not necessarily the main document buffer of the text view. This only reproduces with complex projection views like HTML view or Razor view (up to VS16). Other views are simpler and query for the document buffer only.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.VsTextViewTagger`1.TryCreateTagger``1(Microsoft.VisualStudio.Text.Editor.ITextView,Microsoft.VisualStudio.Text.ITextBuffer)">
            <summary>
            Factory helper which asserts that generic specialization of the class will be correct and the collections in <see cref="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.VsTextViewTagger`1.GetTaggersOverTextView(Microsoft.VisualStudio.Text.Editor.ITextView)" /> are of the same type and meed each other in MEF and in component parts.
            Call in an <see cref="T:Microsoft.VisualStudio.Text.Tagging.IViewTaggerProvider" /> implementor from its <see cref="M:Microsoft.VisualStudio.Text.Tagging.IViewTaggerProvider.CreateTagger``1(Microsoft.VisualStudio.Text.Editor.ITextView,Microsoft.VisualStudio.Text.ITextBuffer)" /> method.
            On that class, place attributes like this:
            <code>
            [Export(typeof(IViewTaggerProvider))]
            [ContentType(VsTextViewTagger&lt;TTag&gt;.ContentType)]
            [TagType(typeof(TTag))]
            </code>
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.VsTextViewTagger`1.System#IDisposable#Dispose">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.VsTextViewTagger`1.Microsoft#VisualStudio#Text#Tagging#ITagger{TTag}#GetTags(Microsoft.VisualStudio.Text.NormalizedSnapshotSpanCollection)">
            <inheritdoc />
        </member>
        <member name="E:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.VsTextViewTagger`1.Microsoft#VisualStudio#Text#Tagging#ITagger{TTag}#TagsChanged">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponentsAlter.VsAlterHacks.IgnoreActionRetry(JetBrains.Platform.VisualStudio.Protocol.Frontend.TextControl.AlterTextControlActionRequest)">
            Undo and redo actions are currently considered frontend-only.
            It is not clear at the moment, is it worth to retry them or not.
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponentsAlter.VsTextControlCommandsAlter">
            <summary>
            Integrates with commanding subsystem on the DevTen text control: plugs into the OLE Command Target and wires intercepted commands into Action System Action Handlers or Typing Handlers, depending on the command kind.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponentsAlter.VsTextControlScrollAlterExecutor.AlterScrollRequestPropertyId">
            for guid magic see comments in TransportTextControl (nonce)
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponentsAlter.VsTextControlScrollingAlter.myRealFwdScrollTo">
             Duality on transport text control is required in async typing mode, but all backend methods on ITextControls does
             not provide any seam, all injected code for scrolling are inserted on text control components level.
            
             This is a property which is listened by <see cref="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlScrollingDevTen"/> component and by firing which real scrolling should happen.
             The property in transport text control is logical, firing it will only produce an AlterAction, which will be serialized and send to frontend. 
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponentsAlter.VsTextControlSelectionAlter.mySelection">
            <summary>
            Cache for the frontend version  of selection
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponentsAlter.VsTextControlSyncAlter">
            Sync caret on valid states.
            Caret can be moved by visual studio when we apply document changes. If only document changes was applied from
            backend side, the caret should stay at the same position to remain in sync
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.IVsTextControlCommandExecutingInsideVsNotifySink.OnCommandExecutingInsideVs(JetBrains.Lifetimes.Lifetime,System.ComponentModel.Design.CommandID)">
            <summary>
            Called when a text editor command (for typing or not) is being executed inside the VS implementation.
            This happens when either we do not intercept this sort of commands, or if none of the action/typing handlers cancels it and it reaches the point when it's given back to VS for processing.
            Usually the former (ie there's no <see cref="T:JetBrains.Application.UI.ActionSystem.Text.TextControlActions.ActionIds" /> for that VS command in our model), because if the latter you can get the same event by registering a typing/action handler.
            </summary>
            <param name="lifetime">The lifetime while we are inside the VS' execution.</param>
            <param name="commandid">ID of the VS Command.</param>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsCreateTextControlComponentContainerDevTen.VsTextControlIdAllocatorDevTen">
            <summary>
            Front-side allocation of text control IDs.
            Negative values, to keep a different “namespace” from backend.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsHighlighterAdornmentView">
            <summary>
            A rendering engine for a full layer of our highlighter-based adornments.
            Implemented as an UI element which you put into a VS Adornment Layer.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsHighlighterAdornmentView.ExclusiveAdornmentsMask">
            <summary>
            Lists rects for a mask which covers all our adorners which we suppose to be exclusive, eg Roslyn adornments should not be shown in the same locations.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsHighlighterAdornmentView.ArrangeCore(System.Windows.Rect)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsHighlighterAdornmentView.OnRender(System.Windows.Media.DrawingContext)">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsHighlighterAdornmentView.DrawingGroupKey">
            <summary>
            Key for a group of adorns which could be painted as one single geometry. This means same color, same style and same z-order.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsHighlighterAdornmentView.DrawingGroupKey.Color">
            <summary>
            Color for the adornment. Applicable to all paintings.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsHighlighterAdornmentView.DrawingGroupKey.Thickness">
            <summary>
            Thickness for line-based adorns.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsHighlighterAdornmentView.DrawingGroupKey.Style">
            <summary>
            Style for simple line-based adorns.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsHighlighterAdornmentView.DrawingGroupKey.ZOrder">
            <summary>
            Z-order for painting this group in relation to other groups.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlCommandInterceptionProhibitedWhileIncrementalSearch">
            <summary>
            Suppress typing handlers when Incremental Search is in operation in the new text view.
            NOTE: in Visual InterDev's text view, the incremental search is a hook right in C++ code of the text view, and it just does not get into the OLE Command Target processing.
            In the new WPF text view, on the contrary, the incremental search is but another client on the OLE Command Target filters chain of the text view.
            If we do not suppress the typing handlers, our typing assist will break the incremental search by inserting characters from the search string into the text view (as we'd have a higher priority than it)
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlCommandInterceptionProhibitedWhileIncrementalSearch.IsIncrementalSearchActiveVs10">
            <summary>
            VS10 only. In VS11+ this <see cref="T:Microsoft.VisualStudio.Text.IncrementalSearch.IIncrementalSearch"/> implementation is present, but is not active.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlCommands">
            <summary>
            Integrates with commanding subsystem on the DevTen text control: plugs into the OLE Command Target and wires intercepted commands into Action System Action Handlers or Typing Handlers, depending on the command kind.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlCompoundActions" -->
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlErrorStripeDevTen.#ctor(JetBrains.Lifetimes.Lifetime,JetBrains.TextControl.Transport.TransportTextControl,JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlDevTenEnvoy,JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlMargins,JetBrains.Application.UI.Components.IUIApplication,JetBrains.Platform.VisualStudio.Protocol.Frontend.TextControl.IVsHighlighterCustomization,JetBrains.TextControl.ITextControlSchemeManager,JetBrains.Util.ILogger)">
            <summary>
            Wires up together (1) error stripe doc (2) error stripe control (3) text control.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlErrorStripeDevTen.PlantIntoMarginsDelegate">
            <summary>
            Allows derived impl to have different logic for planting views.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlGlobalSyncSources">
            <summary>
            Listens to global/common stuff to trigger the Sync-from-VS event.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlHighlighterAdornmentsAndClassificationsDevTen">
            <summary>
            For those text control markup highlighters which should be represented by an adornment (rather than coloring of text or chainging its font), paints the adornments on the adornment layers.
            For classifications (which apply coloring to the text), gets them from backend and hands out ot the tagger which is to apply them.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlHighlighterAdornmentsAndClassificationsDevTen.OptionMaskOutRoslynSquigglesLayerForOurAdorns">
            <summary>
            Experimental feature.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlHighlighterAdornmentsAndClassificationsDevTen.VsHighlighterClassificationTagger.Microsoft#VisualStudio#Text#Tagging#IViewTaggerProvider#CreateTagger``1(Microsoft.VisualStudio.Text.Editor.ITextView,Microsoft.VisualStudio.Text.ITextBuffer)">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlOleCommandTarget">
             <summary>
             Implements an <see cref="T:Microsoft.VisualStudio.OLE.Interop.IOleCommandTarget" />, gets inserted into the text control as the first-chance command target (gets reinserted from time to time to ensure still first-chance) to intercept editor commands:
             1) When typing happens, invokes the typing handlers chain. As a last-chance typing handler, calls into the previous command target on this text control.
             2) When a non-typing command is intercepted, if it's a text control action, executes the action. As a last chance action handler, calls into the previous command target on this text control.
            
             Wrapped by <see cref="T:JetBrains.Threading.ReentrancyGuard"/> by default.
             </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlOleCommandTarget.myActiveExecDelegateBackToVsStack">
            <summary>
            Handlers currently fired to interceptor from <see cref="M:Microsoft.VisualStudio.OLE.Interop.IOleCommandTarget.Exec(System.Guid@,System.UInt32,System.UInt32,System.IntPtr,System.IntPtr)" /> and ready for delegating back to VS.
            It is yet unclear as of whether they can really be nested (usually, VS won't allow nested commands). TODO: try it out
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlOleCommandTarget.myCommandFilterSequence">
            <summary>
            Lifetime for each sequential insertion of <see cref="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlOleCommandTarget.Promote" />.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlOleCommandTarget.myLocalReentrancyGuardPromote">
            <summary>
            Controls recursion in <see cref="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlOleCommandTarget.Promote" />.
            Note: not sure if it actually happens, but were reported in a couple builds.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlOleCommandTarget.InterceptExecuteCommandHandler">
            <summary>
            Client puts here to sink command execution and possibly intercept.
            Why a live property: to lock-out for the single user.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlOleCommandTarget.YieldingCommandExecToVs">
            <summary>
            While we're yielding command execution to the original VS impl, displays that command ID.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlOleCommandTarget.Microsoft#VisualStudio#OLE#Interop#IOleCommandTarget#Exec(System.Guid@,System.UInt32,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>
            Here we intercept a typing command in the Visual Studio text editor, and give R# the first chance to handle it.
            If R# does not know the command or refuses to handle it, we skip to the next VS Command Filter in the chain.
            If R# takes the command, it has the choice to either handle it fully on its own, or execute before-handlers, then pass execution to VS along the command filters chain, and then execute the after-hanlers.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlOleCommandTarget.Promote">
            <summary>
            Creates or updates the command filter.
            The goal of calling the Promote periodically is to keep ourselves as the very first filter in the filters chain (©dsha).
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlOleCommandTarget.Microsoft#VisualStudio#OLE#Interop#IOleCommandTarget#QueryStatus(System.Guid@,System.UInt32,Microsoft.VisualStudio.OLE.Interop.OLECMD[],System.IntPtr)">
            <summary>
            We do not change the availability of commands, we only intercept execution.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlOleCommandTarget.YieldExecToVs(System.ComponentModel.Design.CommandID,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>
            Called either from our <see cref="M:Microsoft.VisualStudio.OLE.Interop.IOleCommandTarget.Exec(System.Guid@,System.UInt32,System.UInt32,System.IntPtr,System.IntPtr)" /> directly, or when the interceptor wants to delegate back to the original impl (via <see cref="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlOleCommandTarget.ExecDelegateBackToVs" />)./
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlOleCommandTarget.YieldExecToVsCore(System.ComponentModel.Design.CommandID,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>
            Does yielding to VS, via <see cref="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlOleCommandTarget.myOldCommandTarget" />, notifies owner via <see cref="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlOleCommandTarget.YieldingCommandExecToVs" />.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlOleCommandTarget.ExecDelegateBackToVs">
            <summary>
            When you intercept a command, given to you in case you want to yield execution to the regular implementation.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlOptionsDevTen.ShowScrollBarAnnotationsOptionId">
            <summary>
            That's a "forward reference". This option exists since VS12.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlOptionsDevTen.EnableFileHealthIndicatorOptionId">
            <summary>
            Those are "forward references". These options exist since VS16.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlScrollingDevTen.#ctor(JetBrains.Lifetimes.Lifetime,JetBrains.TextControl.Transport.TransportTextControl,JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlDevTenEnvoy,JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlSyncToVs,System.Lazy{Microsoft.VisualStudio.Text.Outlining.IOutliningManagerService},JetBrains.Platform.VisualStudio.SinceVs10.DocumentModel.VsDocumentInSyncMoments,JetBrains.Application.Threading.IThreading,JetBrains.Util.ILogger)">
            A constructor for component container
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlScrollingDevTen.#ctor(JetBrains.Lifetimes.Lifetime,JetBrains.TextControl.Transport.TransportTextControl,JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlDevTenEnvoy,JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlSyncToVs,System.Lazy{Microsoft.VisualStudio.Text.Outlining.IOutliningManagerService},JetBrains.Platform.VisualStudio.SinceVs10.DocumentModel.VsDocumentInSyncMoments,JetBrains.Application.Threading.IThreading,JetBrains.Util.ILogger,JetBrains.Platform.RdFramework.Reflection.RdReflectProperty{System.ValueTuple{JetBrains.TextControl.Transport.ScrollingRequest,System.Guid}})">
            A constructor to provide a seam for fwdScrollTo
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlScrollingDevTen.ScrollTo(Microsoft.VisualStudio.Text.VirtualSnapshotPoint,JetBrains.TextControl.TextControlScrollType,Microsoft.VisualStudio.Text.Editor.IWpfTextView,System.Lazy{Microsoft.VisualStudio.Text.Outlining.IOutliningManagerService},JetBrains.Util.ILogger)">
            <summary>
            Scrolls the view to make the <paramref name="vpt" /> visible in the viewport, placing it based on the <paramref name="scrolltype" />.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlSelectionAndCaret.mySyncFromViewToken">
            <summary>
            Change with this token when setting value by syncing from view rather than user's setting the prop to change the view.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlSelectionAndCaret.#ctor(JetBrains.Lifetimes.Lifetime,JetBrains.TextControl.Transport.TransportTextControl,JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlDevTenEnvoy,JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlSyncToVs,JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlSelectionController)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Object" /> class.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlSyncToVs">
            <summary>
            All stuff on the text control should sync to VS at certain invoke thru this common place.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlSyncToVs.#ctor(JetBrains.Lifetimes.Lifetime,JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlDevTenEnvoy,JetBrains.Application.Threading.IThreading,JetBrains.Platform.VisualStudio.Protocol.Common.DocumentModel.VsDocumentModelSynchronization,JetBrains.Util.ILogger)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlSyncToVs.RequestSyncIfAliveGuarded">
            <summary>
            A friendly guard must be held.
            Makes a sync if still alive.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlSyncToVs.RequestSyncIfAliveUnguarded">
            <summary>
            Called from unguarded context (won't merge). Would take guard and cause a sync if still alive.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlSyncWhenDocChangesArriveIntoTextView">
            <summary>
            When the doc changes, do vs-sync for the important model parts.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlTypingActions">
            <summary>
            Serves typing actions of the text control interface.
            TODO: this is going to be much rewritten when splitting out of process.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlTypingActions.#ctor(JetBrains.Lifetimes.Lifetime,JetBrains.TextControl.Transport.TransportTextControl,JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlDevTenEnvoy,JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlSyncToVs,System.Lazy{Microsoft.VisualStudio.Text.Operations.IEditorOperationsFactoryService})">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlViewportTrackingForTransport">
            <summary>
            helps features which need to tell backend which range is interesting for them, assumes viewport plus a bit around.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlViewportTrackingForTransport.GetRangesToRequestHighlightersFor(Microsoft.VisualStudio.Text.Editor.IWpfTextView,JetBrains.Util.ILogger)">
            <summary>
            We request highlighters from back. Whenever text view layout changes, we might have a new range set to send.
            Basically, we need to get info for what's in the viewport. To improve scrolling, also take some space around.
            // TODO: pass version of the snapshot
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Undo.VsBackendUndoableActionHandler">
            Handles the execution of a special undo record that asynchronously notifies the backend, which does some logic later
            that does not directly modify documents and text controls.
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Undo.VsSelectionUndoableActionHandler">
            Handles execution of undoable caret selection on the frontend
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlComponentAttribute">
            <summary>
            Component classes which wire up a <see cref="T:JetBrains.TextControl.Transport.TransportTextControl" /> to an <see cref="T:Microsoft.VisualStudio.Text.Editor.IWpfTextView" />.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlDevTenEnvoy">
            <summary>
            The data class intended to represent our text control instance on the VS side when the code goes out of process.
            Should contain everything we need to attach to a VS text control.
            </summary>
        </member>
        <member name="P:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlDevTenEnvoy.IsVsAlive">
            <summary>
            Gets whether the VS implementation of the text control is currently alive or not.
            The text control is disposed of under a guard, which is much later than the native VS object ceases to exist.
            </summary>
        </member>
        <member name="P:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlDevTenEnvoy.IsVsDead">
            <summary>
            Gets whether the VS implementation of the text control is already dead or not.
            The text control is disposed of under a guard, which is much later than the native VS object ceases to exist.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlDevTenEnvoy.LegacyVsTextBuffer">
            <summary>
            Caches the legacy text buffer object, which is the legacy API conterpart for <see cref="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlDevTenEnvoy.VsTextView" />'s <see cref="P:Microsoft.VisualStudio.Text.Editor.ITextView.TextBuffer" />.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlDevTenEnvoy.LegacyVsTextView">
            <summary>
            Legacy counterpart for the <see cref="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlDevTenEnvoy.VsTextView" />. Some of the APIs are still only available thru it.
            Worse even, some of the functionality is only implemented on the legacy API wrapping object!
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlDevTenEnvoy.Lifetime">
            <summary>
            Guarded disposal of the text control.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlDevTenEnvoy.LifetimeUnguarded">
            <summary>
            Dropped immediately as the native window gets closed.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlDevTenEnvoy.TextControlId">
            <summary>
            The back/front ID of this text control (and, consequently, of its document).
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlDevTenEnvoy.VsTextView">
            <summary>
            The Visual Studio text editor main object in the modern API.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextViewKeyProcessor">
            <summary>
            Backend for the <see cref="P:JetBrains.TextControl.ITextControlWindow.Keyboard"/> event.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextViewMouseProcessor">
            <summary>
            Backend for the <see cref="P:JetBrains.TextControl.ITextControlWindow.MouseMove" />, <see cref="P:JetBrains.TextControl.ITextControlWindow.MouseDown" />, <see cref="P:JetBrains.TextControl.ITextControlWindow.MouseUp" /> events.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextViewMouseProcessor.Factory">
            <summary>
            Mouse processor factory creates a mouse processor for each VS text view.
            </summary>
            (DK) RSRP-329395 Ctrl+Click does not work.
            The cause of this issue is that our mouse processor did not receive MouseDown/MouseUp events. The root cause is described below.
            Microsoft.VisualStudio.Text.Utilities.WpfMouseProcessor keeps an ordered list of mouse processors and calls them in that order. 
            The code of all its event handlers looks like follows:
            
            public void UIElement_MouseDown(object sender, MouseButtonEventArgs e)
            {
            foreach (IMouseProcessor processor in _mouseProcessors)
            {
            processor.PreprocessMouseDown(e);
            if (e.Handled) break;
            }
            if (!e.Handled)
            this.DefaultMouseDownHandler(sender, e);
            foreach (IMouseProcessor processor in _mouseProcessors)
            processor.PostprocessMouseDown(e);
            }
            
            Furthermore, MSDN says "If you mark MouseLeftButtonDown/MouseRightButtonDown handled, you are essentially marking Mouse.MouseDown handled 
            for all further listeners along the route, and on all related events." 
            
            There are more than 10 mouse processors in VS. The order of the processor depends on [Order(Before|After="Name")] attribute of its factory (IMouseProcessorProvider).
            We cannot ensure that our processor is the first in the list, as we aren't able to know the names of all processors. 
            If at least one of them marks MouseLeftButtonDown as handled we will not receive MouseDown/Up (which we preprocessed before).
            
            The solution is to override POSTprocess of MouseLeft/Right/Down/Up in our VsTextViewMouseProcessor to ensure that we always get mouse events.
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.UI.VsAvalonStatusBarShimDevTen">
            <summary>
            An extension to the <see cref="T:JetBrains.UI.Controls.AvalonStatusBarShim"/> class with DevTen-specific functions.
            </summary>
            <seealso cref="T:JetBrains.UI.Controls.AvalonStatusBarShim"/>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.UI.VsAvalonStatusBarShimDevTen.TrySubclassDevTenBeta2StatusDockPanelInWindow(JetBrains.Lifetimes.Lifetime,System.IntPtr,JetBrains.DataFlow.ICollectionEvents{JetBrains.Application.StdApplicationUI.StatusBars.JetStatusBarIndicator},JetBrains.Application.UI.PopupLayout.IMainWindowPopupWindowContext,JetBrains.Application.UI.Controls.JetPopupMenu.JetPopupMenus,JetBrains.Application.Interop.NativeHook.IWindowsHookManager,JetBrains.Application.UI.Components.Theming.ITheming)">
            <summary>
            Works in DevTen Beta2+ for its status bars, see <see cref="M:JetBrains.UI.Controls.AvalonStatusBarShim.TryFindDevTenBeta2StatusDockPanelInHwnd(System.IntPtr)"/> for comments.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.UI.VsAvalonStatusBarShimDevTen.SubclassDevTenBeta2StatusDockPanel(JetBrains.Lifetimes.Lifetime,System.Windows.Controls.Panel,JetBrains.DataFlow.ICollectionEvents{JetBrains.Application.StdApplicationUI.StatusBars.JetStatusBarIndicator},JetBrains.Application.UI.PopupLayout.IMainWindowPopupWindowContext,JetBrains.Application.UI.Controls.JetPopupMenu.JetPopupMenus,JetBrains.Application.Interop.NativeHook.IWindowsHookManager,JetBrains.Application.UI.Components.Theming.ITheming)">
            <summary>
            Works in DevTen Beta2+ for its status bars, see <see cref="M:JetBrains.UI.Controls.AvalonStatusBarShim.TryFindDevTenBeta2StatusDockPanelInHwnd(System.IntPtr)"/> for comments.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.UI.VsAvalonStatusBarShimDevTen.AddItemsHostToStatusDockPanel(JetBrains.Lifetimes.Lifetime,System.Windows.Controls.Panel,System.Windows.Controls.ItemsControl)">
            <summary>
            Helper for attaching to the status line of a window. Places a panel for our items in between the status bar and resize grip.
            Must be executed on the UI thread.
            </summary>
            <param name="lifetime"></param>
            <param name="statusdock">The dock panel of the window status line.</param>
            <param name="panelToHostOnStatusBar">The Avalon element to put on the status bar as its item.</param>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.UI.VsStatusBarIndicatorsDevTen">
            <summary>
            The status bar support part which inserts indicators into the DevEnv status bar by subclassing it as a WPF status bar and inserting own elements.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Util.IVsServiceProviderEx">
            <summary>
            VS-10-specific extensions to the OLE <see cref="T:Microsoft.VisualStudio.OLE.Interop.IServiceProvider"/> interface.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Util.IVsServiceProviderEx.IComponentModel(Microsoft.VisualStudio.OLE.Interop.IServiceProvider)">
            <summary>
            Gets the MEF component model root in VS 10.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Zones.ISinceVs10FrontEnvZone">
            <summary>
            Visual Studio integrated products, VS 10.0 and above.
            </summary>
        </member>
        <member name="T:XamlGeneratedNamespace.GeneratedInternalTypeHelper">
            <summary>
            GeneratedInternalTypeHelper
            </summary>
        </member>
        <member name="M:XamlGeneratedNamespace.GeneratedInternalTypeHelper.CreateInstance(System.Type,System.Globalization.CultureInfo)">
            <summary>
            CreateInstance
            </summary>
        </member>
        <member name="M:XamlGeneratedNamespace.GeneratedInternalTypeHelper.GetPropertyValue(System.Reflection.PropertyInfo,System.Object,System.Globalization.CultureInfo)">
            <summary>
            GetPropertyValue
            </summary>
        </member>
        <member name="M:XamlGeneratedNamespace.GeneratedInternalTypeHelper.SetPropertyValue(System.Reflection.PropertyInfo,System.Object,System.Object,System.Globalization.CultureInfo)">
            <summary>
            SetPropertyValue
            </summary>
        </member>
        <member name="M:XamlGeneratedNamespace.GeneratedInternalTypeHelper.CreateDelegate(System.Type,System.Object,System.String)">
            <summary>
            CreateDelegate
            </summary>
        </member>
        <member name="M:XamlGeneratedNamespace.GeneratedInternalTypeHelper.AddEventHandler(System.Reflection.EventInfo,System.Object,System.Delegate)">
            <summary>
            AddEventHandler
            </summary>
        </member>
    </members>
</doc>
