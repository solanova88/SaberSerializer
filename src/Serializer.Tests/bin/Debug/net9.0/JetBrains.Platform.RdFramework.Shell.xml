<?xml version="1.0"?>
<doc>
    <assembly>
        <name>JetBrains.Platform.RdFramework.Shell</name>
    </assembly>
    <members>
        <member name="M:JetBrains.Platform.RdFramework.ExternalProcess.ProtocolConnection`1.Queue(System.Action)">
            <summary>
            Queues an action on the external process protocol thread
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.ExternalProcess.ProtocolConnection`1.Execute(System.Action)">
            <summary>
            Executes an action on the external process protocol thread and waits
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.ExternalProcess.ProtocolConnection`1.Execute``1(System.Func{``0})">
            <summary>
            Executes an action on the external process protocol thread and waits for result
            </summary>
        </member>
        <member name="T:JetBrains.Platform.RdFramework.ExternalProcess.ProtocolEndPoint`2">
            <summary>
            Represents an endpoint that allows to communicate by Rd Protocol from the side of external process.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.RdFramework.Impl.ProtocolComponent.OurIsBackend">
             The value of <see cref="P:JetBrains.Platform.RdFramework.Impl.ProtocolComponent.IsBackend"/> from the last created protocol component.
             Usually, there is only one component
            
             Note: you cannot get protocol form most <see cref="T:JetBrains.Rd.Base.IRdDynamic"/> instances, because they point to ext protocol which is created in RdExtBase
        </member>
        <member name="P:JetBrains.Platform.RdFramework.Impl.ProtocolComponent.IsBackend">
            <summary>
            A way to differentiate side in C#-C# communations.
            Expected semantic: true for side without UI, false for UI side
            Null if not applicable. Null may mean either that separation to backend/fronted does not makes sense in current
            scenario or there are no two sides at all (like local protocol)
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Impl.ProtocolComponent.#ctor(JetBrains.Application.Threading.IShellLocks,JetBrains.Rd.ITypesRegistrar,JetBrains.Lifetimes.Lifetime,System.Collections.Generic.IEnumerable{JetBrains.Platform.RdFramework.Impl.IRdStartUpSerializerRegistrar})">
            <summary>
            Stub ctor for local use by Shell container.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Impl.RdDispatcher.RunWhile(System.Func{System.Boolean},System.Boolean)">
            <summary>
            Pumps protocol messages while given condition is satisfied.
            </summary>
            <param name="condition"> A delegate to be executed over and over while it returns true. </param>
            <param name="pumpJetDispatcher">
            Allows to pump unguarded actions on UI thread if flag is true.
            But it might causes messages reordering.
            </param>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Impl.ShellRdDispatcher.AllowScheduler(JetBrains.Lifetimes.Lifetime,JetBrains.Collections.Viewable.IScheduler)">
            <summary>
            This is an api hack to avoid Illegal Scheduler Exception during rd entity bindings when code cannot be executed in the main thread.
            Please DO NOT USE this api if you do not fully understand what you are doing.
            </summary>
            <param name="lifetime"></param>
            <param name="scheduler"></param>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Impl.ShellRdDispatcher.ToString">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Platform.RdFramework.Impl.SimpleInpaceExecutingScheduler">
            <summary>
            Executes the given action just in the current thread in Queue method
            </summary>
        </member>
        <member name="P:JetBrains.Platform.RdFramework.InProcessWire.Pending">
            <summary>
            Gets an incomplete task with which you can await any pending operations.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.RdFramework.RdVerification.IProtocolSide">
            <summary>
            For protocol entities, allows to tell if it's client or server.
            </summary>
        </member>
        <member name="P:JetBrains.Platform.RdFramework.RdVerification.IProtocolSide.IsBackend">
            <summary>
            A way to differentiate side in C#-C# communations.
            Expected semantic: true for side without UI, false for UI side
            Null if not applicable. Null may mean either that separation to backend/fronted does not makes sense in current
            scenario or there are no two sides at all (like local protocol)
            </summary>
        </member>
        <member name="T:JetBrains.Platform.RdFramework.RdVerification.IRdShell">
            <summary>
            A set of components required for using reactive model with Reflection-based serializers. Do not inject this
            component directly, use either RdShell for synchronous execution in in-process mode or pair of IFrontendRdShell and
            IBackendRdShell for asynchronous execution.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.RdFramework.RdVerification.LocalProtocolEmulationWithLocalBridgeSupport">
            <summary>
            Unlike base impl, requires the Rd zone.
            Adds support for local protocol emulation modes.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.RdVerification.LocalProtocolEmulationWithLocalBridgeSupport.#ctor(JetBrains.Platform.RdFramework.Reflection.LocalProtocolEmulation.OperationMode)">
            <summary>
            Ctor for derived implementations. Goes around all the local emulation impl.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.RdVerification.LocalProtocolEmulationWithLocalBridgeSupport.#ctor(JetBrains.Lifetimes.Lifetime,JetBrains.Platform.RdFramework.Impl.RdDispatcher,JetBrains.Application.Settings.ISettingsStore,JetBrains.Application.Components.IImmutableEnumerable{JetBrains.Platform.RdFramework.RdVerification.IRdBlackListProvider},JetBrains.Application.Environment.ShellPartCatalogSet,System.Collections.Generic.IEnumerable{JetBrains.Platform.RdFramework.RdVerification.IRdTypesCatalogProvider},System.Collections.Generic.IEnumerable{JetBrains.Platform.RdFramework.RdVerification.IRdConfigurator},JetBrains.Application.Threading.IShellLocks,JetBrains.Util.ILogger)">
            <summary>
            Ctor for a working local emulation, when this class is created directly as a component.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.RdFramework.RdVerification.RdModelsVerifier">
            <summary>
            RdModel verification for each <see cref="T:JetBrains.Application.ComponentModel.RdTypeAttribute"/>
            </summary>
        </member>
        <member name="T:JetBrains.Platform.RdFramework.RdVerification.RdTypesCatalogWrapper">
            <summary>
            The discovery point for models marked with <see cref="T:JetBrains.Application.ComponentModel.RdTypeAttribute"/>
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.RdVerification.RdTypesCatalogWrapper.Hash(JetBrains.Util.dataStructures.Sources.StringSource@,System.Int64)">
            <summary>
            Reimplementation of <see cref="M:JetBrains.Rd.RdId.Hash(System.String,System.Int64)" />, which can't use <see cref="T:JetBrains.Util.dataStructures.Sources.StringSource" /> type directly
            </summary>
            <param name="ss"></param>
            <param name="initValue"></param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Platform.RdFramework.RdVerification.SidewiseProtocol">
            <summary>
            NOTE: adds server/client telling to the protocol, while all of it is private in the base class. TODO: probably, should make it possible to get from the base protocol, but not sure.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.RdVerification.SidewiseProtocol.#ctor(JetBrains.Lifetimes.Lifetime,System.String,System.Nullable{System.Boolean},JetBrains.Rd.ISerializers,JetBrains.Rd.IIdentities,JetBrains.Collections.Viewable.IScheduler,JetBrains.Rd.IWire,JetBrains.Rd.RdContextBase[])">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.Platform.RdFramework.RdVerification.SidewiseProtocol.JetBrains#Platform#RdFramework#RdVerification#IProtocolSide#IsBackend">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Platform.RdFramework.Reflection.FutureResponse`1">
            <summary>
            Accessor object for <see cref="T:JetBrains.Platform.RdFramework.Reflection.RdReflectRequestResponse`2" />.
            After you fire a request, lets you extract the response.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.FutureResponse`1.DangerousGetRawResponseAsync">
            <summary>
              <para>Gives access to the raw response contents (after it arrives). Beware potentially orphaned <see cref="T:JetBrains.Lifetimes.LifetimeDefinition" />!</para>
              <para>Dangerous because it does not handle result unwrapping or lifetime termination for you, unlike <see cref="M:JetBrains.Platform.RdFramework.Reflection.FutureResponse`1.GetScalarResponseAsync" /> or <see cref="M:JetBrains.Platform.RdFramework.Reflection.FutureResponse`1.WithLiveResponseAsync(System.Func{JetBrains.Lifetimes.Lifetime,`0,System.Threading.Tasks.Task})" />. You are obliged to terminate the lifetime at some point (unless the outer lifetime of the whole request-response session terminates when the session ends), otherwise the session will leak.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.FutureResponse`1.DangerousGetResponseUnderFiringLifetimeAsync">
            <summary>
              <para>Gives access to the raw response contents (after it arrives). Beware potentially orphaned <see cref="T:JetBrains.Lifetimes.LifetimeDefinition" />!</para>
              <para>This method assumes the lifetime you passed to <see cref="M:JetBrains.Platform.RdFramework.Reflection.RdReflectRequestResponse`2.Fire(JetBrains.Lifetimes.OuterLifetime,`0)" /> is actually the lifetime of the session, and it will be closed / live response disconnected when it ends, so terminating the response lifetime manually is not needed.</para>
              <para>Dangerous because it does not handle lifetime termination for you, unlike <see cref="M:JetBrains.Platform.RdFramework.Reflection.FutureResponse`1.GetScalarResponseAsync" /> or <see cref="M:JetBrains.Platform.RdFramework.Reflection.FutureResponse`1.WithLiveResponseAsync(System.Func{JetBrains.Lifetimes.Lifetime,`0,System.Threading.Tasks.Task})" />.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.FutureResponse`1.Detach">
            <summary>
            Lets the request-response complete on its own, closes the session lifetime immediately when it's received.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.FutureResponse`1.GetScalarResponseAsync">
            <summary>
              <para>If your response is a scalar value rather than a live bindable object (i.e. it's been received over the wire and isn't connected to the other side), extracts the response when it's ready.</para>
              <para>If you use this over a live bindable response, there will be no error, but it would be disconnected from the other side by the time you get it. See <see cref="M:JetBrains.Platform.RdFramework.Reflection.FutureResponse`1.WithLiveResponseAsync(System.Func{JetBrains.Lifetimes.Lifetime,`0,System.Threading.Tasks.Task})" /> for a connected version.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.FutureResponse`1.WithLiveResponseAsync(System.Func{JetBrains.Lifetimes.Lifetime,`0,System.Threading.Tasks.Task})">
            <summary>
              <para>For a live bindable response object, calls your handler to interact with it while it's still connected to the other side.</para>
              <para>If you use this on a scalar response, everything works correctly, though <see cref="M:JetBrains.Platform.RdFramework.Reflection.FutureResponse`1.GetScalarResponseAsync" /> is simpler for such a case.</para>
            </summary>
            <param name="F"></param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Platform.RdFramework.Reflection.LocalProtocolEmulation">
            <summary>
            A special helper for testing out-of-process behavior while running strictly in-process — by having two counterparts, backend and frontend, only connected via the protocol, with serialization and delayed execution.
            The main trick is to have it function properly in real out-of-process scenario too.
            Has three modes all in all:
            • In-process, production (<see cref="F:JetBrains.Platform.RdFramework.Reflection.LocalProtocolEmulation.OperationMode.Direct" />): back and front clients get the same physical instance of the transport object; all of the communication happens locally and synchronously on it.
            • In-process, testbed (<see cref="F:JetBrains.Platform.RdFramework.Reflection.LocalProtocolEmulation.OperationMode.LocalInstant" /> or <see cref="F:JetBrains.Platform.RdFramework.Reflection.LocalProtocolEmulation.OperationMode.LocalDelayed" />): two instances of the transport object are created, wired together thru a protocol over a delaying wire, back and front get different instances. Most of the “remote” effects are observed, but for the possibility to by-pass some reference to a runtime object around the protocol.
            • Out-of-process (<see cref="F:JetBrains.Platform.RdFramework.Reflection.LocalProtocolEmulation.OperationMode.SplitToBackEnd" /> or <see cref="F:JetBrains.Platform.RdFramework.Reflection.LocalProtocolEmulation.OperationMode.SplitToFrontEnd" />): one counterpart is offered in one process, and the other in another.
            </summary>
            <remarks>Non-zoned base impl, can into Direct mode only.</remarks>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.LocalProtocolEmulation.#ctor">
            <summary>
            Default init to direct mode.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.RdFramework.Reflection.LocalProtocolEmulation.OperationMode.Direct">
            <summary>
            Production mode. No real protocoling, back and front conterparts use exactly the same instance. All events are fired locally and instantly (under the same guard, if guarded, and same thread).
            </summary>
            <remarks>Single storage. Can be operated by the base impl, without the Rd zone.</remarks>
        </member>
        <member name="F:JetBrains.Platform.RdFramework.Reflection.LocalProtocolEmulation.OperationMode.LocalInstant">
            <summary>
            Single-process protocol testing mode, safer version.
            There're two instances, connected thru protocol. Only protocol-serializable payloads are possible. Events are fired without a delay, but since they take a guard, it would be off-stack if called from under a guard.
            </summary>
            <remarks>Two storages, back then front.</remarks>
        </member>
        <member name="F:JetBrains.Platform.RdFramework.Reflection.LocalProtocolEmulation.OperationMode.LocalDelayed">
            <summary>
            Like <see cref="F:JetBrains.Platform.RdFramework.Reflection.LocalProtocolEmulation.OperationMode.LocalInstant" />, but adds a slight delay before firing the event on the sinking side. Less safe thus. But better tests the consequences of asyncness.
            </summary>
            <remarks>Two storages, back then front.</remarks>
        </member>
        <member name="F:JetBrains.Platform.RdFramework.Reflection.LocalProtocolEmulation.OperationMode.SplitToBackEnd">
            <summary>
            Running out-of-process, on back end. Counterparts are split across processes and only communicate via the protocol.
            </summary>
            <remarks>Single storage, of the respective end.</remarks>
        </member>
        <member name="F:JetBrains.Platform.RdFramework.Reflection.LocalProtocolEmulation.OperationMode.SplitToFrontEnd">
            <summary>
            Like <see cref="F:JetBrains.Platform.RdFramework.Reflection.LocalProtocolEmulation.OperationMode.SplitToBackEnd" />, but on the front end.
            </summary>
            <remarks>Single storage, of the respective end.</remarks>
        </member>
        <member name="T:JetBrains.Platform.RdFramework.Reflection.RdReflectCollectionEvents`1">
            <summary>
            An <see cref="T:JetBrains.DataFlow.ICollectionEvents`1" /> implementation suitable for use in reflection RD models.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectCollectionEvents`1.#ctor(System.String,System.Collections.Generic.IEqualityComparer{`0})">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectCollectionEvents`1.Read(JetBrains.Rd.SerializationCtx,JetBrains.Serialization.UnsafeReader)">
            <summary>
            Used by rd reflection serializers.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectCollectionEvents`1.Write(JetBrains.Rd.SerializationCtx,JetBrains.Serialization.UnsafeWriter,JetBrains.Platform.RdFramework.Reflection.RdReflectCollectionEvents{`0})">
            <summary>
            Used by rd reflection serializers.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectCollectionEvents`1.JetBrains#Rd#Base#IRdBindable#Bind">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectCollectionEvents`1.JetBrains#Rd#Base#IRdBindable#Identify(JetBrains.Rd.IIdentities,JetBrains.Rd.RdId)">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.Platform.RdFramework.Reflection.RdReflectCollectionEvents`1.JetBrains#Rd#Base#IRdDynamic#Location">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectCollectionEvents`1.JetBrains#Rd#Base#IRdBindable#PreBind(JetBrains.Lifetimes.Lifetime,JetBrains.Rd.Base.IRdDynamic,System.String)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectCollectionEvents`1.JetBrains#Rd#Base#IPrintable#Print(JetBrains.Rd.Util.PrettyPrinter)">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.Platform.RdFramework.Reflection.RdReflectCollectionEvents`1.JetBrains#Rd#Base#IRdBindable#RdId">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectCollectionEvents`1.JetBrains#Rd#Base#IRdDynamic#TryGetProto">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectCollectionEvents`1.JetBrains#Rd#Base#IRdDynamic#TryGetSerializationContext(JetBrains.Rd.SerializationCtx@)">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Platform.RdFramework.Reflection.RdReflectDictionaryEvents`2">
            <summary>
            An <see cref="T:JetBrains.DataFlow.IDictionaryEvents`2" /> implementation suitable for use in reflection RD models.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectDictionaryEvents`2.#ctor(System.String,System.Object,System.Object)">
            <summary>
            Don't ask. TODO: Just delete when it stops failing. Supposed to satisfy ReflectionRdActivator::ActivateGenericMember
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectDictionaryEvents`2.#ctor(System.String,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Don't ask. TODO: Just delete when it stops failing. Supposed to satisfy ReflectionRdActivator::ActivateGenericMember
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectDictionaryEvents`2.#ctor(System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Don't ask. TODO: Just delete when it stops failing. Supposed to satisfy ReflectionRdActivator::ActivateGenericMember
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectDictionaryEvents`2.#ctor(System.String)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectDictionaryEvents`2.Read(JetBrains.Rd.SerializationCtx,JetBrains.Serialization.UnsafeReader)">
            <summary>
            Used by rd reflection serializers.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectDictionaryEvents`2.Write(JetBrains.Rd.SerializationCtx,JetBrains.Serialization.UnsafeWriter,JetBrains.Platform.RdFramework.Reflection.RdReflectDictionaryEvents{`0,`1})">
            <summary>
            Used by rd reflection serializers.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectDictionaryEvents`2.JetBrains#Rd#Base#IRdBindable#Bind">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectDictionaryEvents`2.JetBrains#Rd#Base#IRdBindable#Identify(JetBrains.Rd.IIdentities,JetBrains.Rd.RdId)">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.Platform.RdFramework.Reflection.RdReflectDictionaryEvents`2.JetBrains#Rd#Base#IRdDynamic#Location">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectDictionaryEvents`2.JetBrains#Rd#Base#IRdBindable#PreBind(JetBrains.Lifetimes.Lifetime,JetBrains.Rd.Base.IRdDynamic,System.String)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectDictionaryEvents`2.JetBrains#Rd#Base#IPrintable#Print(JetBrains.Rd.Util.PrettyPrinter)">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.Platform.RdFramework.Reflection.RdReflectDictionaryEvents`2.JetBrains#Rd#Base#IRdBindable#RdId">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectDictionaryEvents`2.JetBrains#Rd#Base#IRdDynamic#TryGetProto">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectDictionaryEvents`2.JetBrains#Rd#Base#IRdDynamic#TryGetSerializationContext(JetBrains.Rd.SerializationCtx@)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectEx.WireableNotBoundException.#ctor">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectEx.WireableNotBoundException.#ctor(System.String)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectEx.WireableNotBoundException.#ctor(System.String,System.Exception)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectEx.WireableNotBoundException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Platform.RdFramework.Reflection.RdReflectInProcessBlackBox`1">
            <summary>
            Helps with legacy code transition.
            When we're running protocol inprocess, allows to wire types which are neither bindable nor serializable scalars, by just getting the same instance on the other side.
            </summary>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectInProcessBlackBox`1.Equals(JetBrains.Platform.RdFramework.Reflection.RdReflectInProcessBlackBox{`0})">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectInProcessBlackBox`1.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectInProcessBlackBox`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectInProcessBlackBox`1.Read(JetBrains.Rd.SerializationCtx,JetBrains.Serialization.UnsafeReader)">
            <summary>
            Used by rd reflection serializers.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectInProcessBlackBox`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectInProcessBlackBox`1.Write(JetBrains.Rd.SerializationCtx,JetBrains.Serialization.UnsafeWriter,JetBrains.Platform.RdFramework.Reflection.RdReflectInProcessBlackBox{`0})">
            <summary>
            Used by rd reflection serializers.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.RdFramework.Reflection.RdReflectInProcessBlackBox">
            <summary>
            Nongeneric helper class.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.RdFramework.Reflection.RdReflectInProcessBlackBox.ProcessNonce">
            <summary>
            Unique per-process (or, rather, appdomain).
            When received, a mismatch means we cannot unmarshal.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectInProcessBlackBox.Create``1(``0)">
            <inheritdoc cref="T:JetBrains.Platform.RdFramework.Reflection.RdReflectInProcessBlackBox`1" />
        </member>
        <member name="T:JetBrains.Platform.RdFramework.Reflection.RdReflectProperty`1">
            <summary>
            An <see cref="T:JetBrains.DataFlow.IProperty`1" /> implementation suitable for use in reflection RD models.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.RdFramework.Reflection.RdReflectProperty`1.myIsDrivingEnd">
            <summary>
            <c>True</c> if this is the driving end and should win in case of conflicting simultaneous changes, <c>False</c> if it always submits to remote changes, and <c>NULL</c> if we have not been told any role.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.RdFramework.Reflection.RdReflectProperty`1.myPreValue">
            <summary>
            Facilitates pre-binding, which happens either on main thread or on protocol thread. Multi-thread access. Under lock on this object.
            Version: supports <see cref="F:JetBrains.Platform.RdFramework.Reflection.RdReflectProperty`1.myIsDrivingEnd" /> logic. If opposite roles are defined on two ends, they have the same version after the sync on a value, but it might be different in between the simultaneous change and a full sync.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectProperty`1.#ctor(JetBrains.DataFlow.PropertyId{`0},`0,System.Nullable{System.Boolean},JetBrains.Util.ILogger,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectProperty`1.Read(JetBrains.Rd.SerializationCtx,JetBrains.Serialization.UnsafeReader)">
            <summary>
            Used by rd reflection serializers.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectProperty`1.Write(JetBrains.Rd.SerializationCtx,JetBrains.Serialization.UnsafeWriter,JetBrains.Platform.RdFramework.Reflection.RdReflectProperty{`0})">
            <summary>
            Used by rd reflection serializers.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectProperty`1.JetBrains#Rd#Base#IRdBindable#Bind">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectProperty`1.JetBrains#Rd#Base#IRdBindable#Identify(JetBrains.Rd.IIdentities,JetBrains.Rd.RdId)">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.Platform.RdFramework.Reflection.RdReflectProperty`1.JetBrains#Rd#Base#IRdDynamic#Location">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectProperty`1.JetBrains#Rd#Base#IRdBindable#PreBind(JetBrains.Lifetimes.Lifetime,JetBrains.Rd.Base.IRdDynamic,System.String)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectProperty`1.JetBrains#Rd#Base#IPrintable#Print(JetBrains.Rd.Util.PrettyPrinter)">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.Platform.RdFramework.Reflection.RdReflectProperty`1.JetBrains#Rd#Base#IRdBindable#RdId">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectProperty`1.JetBrains#Rd#Base#IRdDynamic#TryGetProto">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectProperty`1.JetBrains#Rd#Base#IRdDynamic#TryGetSerializationContext(JetBrains.Rd.SerializationCtx@)">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Platform.RdFramework.Reflection.RdReflectPropertyBag">
            <summary>
            An <see cref="T:JetBrains.DataFlow.IPropertyBag" /> implementation suitable for use in reflection RD models.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.RdFramework.Reflection.RdReflectPropertyBag.myTypedReadHandlers">
            <summary>
            Read typed values of props (on an already partly-read reader, which has just the value of the specific property type).
            </summary>
        </member>
        <member name="F:JetBrains.Platform.RdFramework.Reflection.RdReflectPropertyBag.myTypedSendHandlers">
            <summary>
            Initiates sending the prop value, fully by calling the Wire and opening the unsafe writer etc.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectPropertyBag.#ctor">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectPropertyBag.Read(JetBrains.Rd.SerializationCtx,JetBrains.Serialization.UnsafeReader)">
            <summary>
            Used by rd reflection serializers.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectPropertyBag.Write(JetBrains.Rd.SerializationCtx,JetBrains.Serialization.UnsafeWriter)">
            <summary>
            Used by rd reflection serializers.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectPropertyBag.Write(JetBrains.Rd.SerializationCtx,JetBrains.Serialization.UnsafeWriter,JetBrains.Platform.RdFramework.Reflection.RdReflectPropertyBag)">
            <summary>
            Used by rd reflection serializers.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectPropertyBag.JetBrains#Rd#Base#IRdBindable#Bind">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectPropertyBag.JetBrains#Rd#Base#IRdBindable#Identify(JetBrains.Rd.IIdentities,JetBrains.Rd.RdId)">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.Platform.RdFramework.Reflection.RdReflectPropertyBag.JetBrains#Rd#Base#IRdDynamic#Location">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectPropertyBag.JetBrains#Rd#Base#IRdBindable#PreBind(JetBrains.Lifetimes.Lifetime,JetBrains.Rd.Base.IRdDynamic,System.String)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectPropertyBag.JetBrains#Rd#Base#IPrintable#Print(JetBrains.Rd.Util.PrettyPrinter)">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.Platform.RdFramework.Reflection.RdReflectPropertyBag.JetBrains#Rd#Base#IRdBindable#RdId">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectPropertyBag.JetBrains#Rd#Base#IRdDynamic#TryGetProto">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectPropertyBag.JetBrains#Rd#Base#IRdDynamic#TryGetSerializationContext(JetBrains.Rd.SerializationCtx@)">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Platform.RdFramework.Reflection.RdReflectRequestResponse`2">
            <summary>
            A remotable automation model entry which can make asynchronous request-response calls.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectRequestResponse`2.#ctor(JetBrains.DataFlow.PropertyId{System.Tuple{`0,`1}})">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectRequestResponse`2.Advise(JetBrains.Lifetimes.Lifetime,System.Func{JetBrains.Lifetimes.Lifetime,`0,System.Threading.Tasks.Task{`1}})">
            <summary>
            Handle incoming requests.
            </summary>
            <param name="lifetime">The lifetime while request is open. For scalar responses, limits the time you could be calculating it. For live bindable responses, indicates the lifetime until your response gets disconnected from the other side.</param>
            <param name="FHandler"></param>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectRequestResponse`2.Fire(JetBrains.Lifetimes.OuterLifetime,`0)">
            <summary>
            Initiates a request and returns the object which awaits for response.
            You MUST finish the request with either of the response-processing methods, because this defines the async lifetime of the session.
            </summary>
            <param name="lifetime">The limiting lifetime for the session. A nested lifetime will be defined for this request-response session, which only terminates when you complete the returned object with either of the methods.</param>
            <param name="request">The request parameter.</param>
            <returns>The session object on which you should call one of the response-processing methods, allowing the request-response session lifetime to terminate and handling the possible response, either as a scalar deserialized value, or as a live session on the connected response object.</returns>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectRequestResponse`2.Read(JetBrains.Rd.SerializationCtx,JetBrains.Serialization.UnsafeReader)">
            <summary>
            Used by rd reflection serializers.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectRequestResponse`2.Write(JetBrains.Rd.SerializationCtx,JetBrains.Serialization.UnsafeWriter,JetBrains.Platform.RdFramework.Reflection.RdReflectRequestResponse{`0,`1})">
            <summary>
            Used by rd reflection serializers.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectRequestResponse`2.OnBindNested(JetBrains.Lifetimes.Lifetime)">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Platform.RdFramework.Reflection.RdReflectResult`1">
            <summary>
            Like <see cref="T:JetBrains.Core.Result`1" />, but suitable for wiring over protocol, including when the result is a bindable model itself.
            </summary>
            <typeparam name="TResult">A scalar or a bindable model.</typeparam>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectResult`1.#ctor(System.String,`0)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectResult`1.Read(JetBrains.Rd.SerializationCtx,JetBrains.Serialization.UnsafeReader)">
            <summary>
            Used by rd reflection serializers.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectResult`1.Write(JetBrains.Rd.SerializationCtx,JetBrains.Serialization.UnsafeWriter,JetBrains.Platform.RdFramework.Reflection.RdReflectResult{`0})">
            <summary>
            Used by rd reflection serializers.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectResult`1.OnBindNested(JetBrains.Lifetimes.Lifetime)">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Platform.RdFramework.Reflection.RdReflectSignal`1">
            <summary>
            An <see cref="T:JetBrains.DataFlow.ISignal`1" /> implementation suitable for use in reflection RD models.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectSignal`1.#ctor(System.String)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectSignal`1.Read(JetBrains.Rd.SerializationCtx,JetBrains.Serialization.UnsafeReader)">
            <summary>
            Used by rd reflection serializers.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectSignal`1.Write(JetBrains.Rd.SerializationCtx,JetBrains.Serialization.UnsafeWriter,JetBrains.Platform.RdFramework.Reflection.RdReflectSignal{`0})">
            <summary>
            Used by rd reflection serializers.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectSignal`1.JetBrains#Rd#Base#IRdBindable#Bind">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectSignal`1.JetBrains#Rd#Base#IRdBindable#Identify(JetBrains.Rd.IIdentities,JetBrains.Rd.RdId)">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.Platform.RdFramework.Reflection.RdReflectSignal`1.JetBrains#Rd#Base#IRdDynamic#Location">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectSignal`1.JetBrains#Rd#Base#IRdBindable#PreBind(JetBrains.Lifetimes.Lifetime,JetBrains.Rd.Base.IRdDynamic,System.String)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectSignal`1.JetBrains#Rd#Base#IPrintable#Print(JetBrains.Rd.Util.PrettyPrinter)">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.Platform.RdFramework.Reflection.RdReflectSignal`1.JetBrains#Rd#Base#IRdBindable#RdId">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectSignal`1.JetBrains#Rd#Base#IRdDynamic#TryGetProto">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectSignal`1.JetBrains#Rd#Base#IRdDynamic#TryGetSerializationContext(JetBrains.Rd.SerializationCtx@)">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Platform.RdFramework.Reflection.RdReflectSimpleSignal">
            <summary>
            An <see cref="T:JetBrains.DataFlow.ISimpleSignal" /> implementation suitable for use in reflection RD models.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectSimpleSignal.#ctor(System.String)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectSimpleSignal.Read(JetBrains.Rd.SerializationCtx,JetBrains.Serialization.UnsafeReader)">
            <summary>
            Used by rd reflection serializers.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectSimpleSignal.Write(JetBrains.Rd.SerializationCtx,JetBrains.Serialization.UnsafeWriter,JetBrains.Platform.RdFramework.Reflection.RdReflectSimpleSignal)">
            <summary>
            Used by rd reflection serializers.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectSimpleSignal.JetBrains#Rd#Base#IRdBindable#Bind">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectSimpleSignal.JetBrains#Rd#Base#IRdBindable#Identify(JetBrains.Rd.IIdentities,JetBrains.Rd.RdId)">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.Platform.RdFramework.Reflection.RdReflectSimpleSignal.JetBrains#Rd#Base#IRdDynamic#Location">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectSimpleSignal.JetBrains#Rd#Base#IRdBindable#PreBind(JetBrains.Lifetimes.Lifetime,JetBrains.Rd.Base.IRdDynamic,System.String)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectSimpleSignal.JetBrains#Rd#Base#IPrintable#Print(JetBrains.Rd.Util.PrettyPrinter)">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.Platform.RdFramework.Reflection.RdReflectSimpleSignal.JetBrains#Rd#Base#IRdBindable#RdId">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectSimpleSignal.JetBrains#Rd#Base#IRdDynamic#TryGetProto">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectSimpleSignal.JetBrains#Rd#Base#IRdDynamic#TryGetSerializationContext(JetBrains.Rd.SerializationCtx@)">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Platform.RdFramework.Reflection.RdReflectSyncCall`2">
            <summary>
              <para>A sync call which should function correctly in guarded environments (with merging into friendly guards and not interfering with others' guards) in these three scenarios:</para>
              <para>(1) Fully local, as if an In-Out Signal. Just synchronous calls to the sink, guarded state corresponds to the caller side.</para>
              <para>(2) In-process emulation of the protocol wire (immediate or delayed). This is the most complicated case because the requestnig end blocks executing transactions and the responding end cannot just hoped to execute guarded.</para>
              <para>(3) Real cross-process communication.</para>
              <para>All this must support chained calls, like <c>[Side A] ==(signal S1)==> [Side B] ==(signal S2)==> [Side A]</c> (and responses chained back in response), with correct joining on the guard transactions to allow all three scenarios.</para>
            </summary>
            <typeparam name="TRequest"></typeparam>
            <typeparam name="TResponse"></typeparam>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectSyncCall`2.Advise(JetBrains.Lifetimes.Lifetime,JetBrains.Platform.RdFramework.Reflection.RdReflectSyncCallTransactionReuse.TransactionReuseKey,System.Func{`0,`1})">
            <summary>
            On the response side, advises listening for calls.
            Besides explicit parameters, this also defines the <see cref="T:JetBrains.Threading.ReentrancyGuard" /> on which the transaction in <paramref name="transactionReuseKey" /> should be joined, by assuming you make the call on the same thread that guard sits on.
            </summary>
            <param name="lifetime">Lifetime of your subscription.</param>
            <param name="transactionReuseKey">Identifies the transaction which we're allowed to join on an existing reentrancy guard. Someone must be letting us in with the same key.</param>
            <param name="handler">Callback.</param>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectSyncCall`2.OnWireReceived(JetBrains.Rd.IProtocol,JetBrains.Rd.SerializationCtx,JetBrains.Serialization.UnsafeReader,JetBrains.Rd.Base.IRdWireableDispatchHelper)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectSyncCall`2.Read(JetBrains.Rd.SerializationCtx,JetBrains.Serialization.UnsafeReader)">
            <summary>
            Used by rd reflection serializers.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectSyncCall`2.Write(JetBrains.Rd.SerializationCtx,JetBrains.Serialization.UnsafeWriter,JetBrains.Platform.RdFramework.Reflection.RdReflectSyncCall{`0,`1})">
            <summary>
            Used by rd reflection serializers.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectSyncCallTransactionReuse.WithTryJoinTransactionAsync``2(JetBrains.Lifetimes.Lifetime,JetBrains.Platform.RdFramework.Reflection.RdReflectSyncCallTransactionReuse.TransactionReuseKey,``0,System.Func{``0,``1})">
            <summary>
            Call when someone might have shared a transaction key with you, to join that transaction if it's currently running.
            The action would execute sync on-stack in this case. Otherwise, it would execute by the regular transaction queue order.
            </summary>
            <param name="lifetime"></param>
            <param name="transactionReuseKey"></param>
            <param name="in"></param>
            <param name="F"></param>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="T:JetBrains.Platform.RdFramework.Reflection.RdReflectSyncCallTransactionReuse.TransactionReuseKey">
            <summary>
            Members used at list for identity (hashing/equality) and tostringing.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectSyncCallTransactionReuse.TransactionReuseKey.#ctor(System.String,System.String)">
            <summary>
            Members used at list for identity (hashing/equality) and tostringing.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectTransportObjectForRequestResponse`2.#ctor(`0)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectTransportObjectForRequestResponse`2.#ctor(System.Guid,`0,JetBrains.Platform.RdFramework.Reflection.RdReflectProperty{JetBrains.Platform.RdFramework.Reflection.RdReflectResult{`1}})">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectTransportObjectForRequestResponse`2.Read(JetBrains.Rd.SerializationCtx,JetBrains.Serialization.UnsafeReader)">
            <summary>
            Used by rd reflection serializers.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectTransportObjectForRequestResponse`2.Write(JetBrains.Rd.SerializationCtx,JetBrains.Serialization.UnsafeWriter,JetBrains.Platform.RdFramework.Reflection.RdReflectTransportObjectForRequestResponse{`0,`1})">
            <summary>
            Used by rd reflection serializers.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectTransportObjectForRequestResponse`2.OnBindNested(JetBrains.Lifetimes.Lifetime)">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Platform.RdFramework.Reflection.RdReflectTypeRef">
            <summary>
            A typed wrapper with protocol serialization for passing <see cref="T:System.Type" /> instances to the other end.<br />
            The type must be loadable by its AQN on the other end.
            </summary>
            <remarks>Unlike registering a serializer for types centrally, this works autonomously just as a serializable type.</remarks>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectTypeRef.Equals(JetBrains.Platform.RdFramework.Reflection.RdReflectTypeRef)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectTypeRef.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectTypeRef.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectTypeRef.Read(JetBrains.Rd.SerializationCtx,JetBrains.Serialization.UnsafeReader)">
            <summary>
            Used by rd reflection serializers.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectTypeRef.ToString">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectTypeRef.Write(JetBrains.Rd.SerializationCtx,JetBrains.Serialization.UnsafeWriter)">
            <summary>
            Used by rd reflection serializers.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdReflectTypeRef.Write(JetBrains.Rd.SerializationCtx,JetBrains.Serialization.UnsafeWriter,JetBrains.Platform.RdFramework.Reflection.RdReflectTypeRef)">
            <summary>
            Used by rd reflection serializers.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.RdFramework.Reflection.RdWireableBase">
            <summary>
            Adds wiring and basic bind/identify impl to <see cref="T:JetBrains.Rd.Base.RdBindableBase" />.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdWireableBase.#ctor(JetBrains.DataFlow.PropertyId)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdWireableBase.BindNested(JetBrains.Platform.RdFramework.Reflection.RdWireableBase[])">
            <summary>
            When an object with this trait has bindable children, especially if they're coming and going dynamically.
            </summary>
            <param name="lifetime">Child presence.</param>
            <param name="nested">Child as bindable.</param>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdWireableBase.OnWireReceived(JetBrains.Rd.IProtocol,JetBrains.Rd.SerializationCtx,JetBrains.Serialization.UnsafeReader,JetBrains.Rd.Base.IRdWireableDispatchHelper)">
            <summary>
            Override to react on receiving data.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdWireableBase.PreBindNested(JetBrains.Lifetimes.Lifetime,JetBrains.Platform.RdFramework.Reflection.RdWireableBase[])">
            <summary>
            When an object with this trait has bindable children, especially if they're coming and going dynamically.
            </summary>
            <param name="lifetime">Child presence.</param>
            <param name="nested">Child as bindable.</param>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdWireableBase.PreBindNested(JetBrains.Lifetimes.Lifetime,JetBrains.Rd.Base.IRdBindable,System.String,System.Boolean)">
            <summary>
            When an object with this trait has bindable children, especially if they're coming and going dynamically.
            </summary>
            <param name="lifetime">Child presence.</param>
            <param name="bindableNested">Child as bindable.</param>
            <param name="localname">Local name of the child within this object</param>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdWireableBase.Init(JetBrains.Lifetimes.Lifetime,JetBrains.Rd.IProtocol,JetBrains.Rd.SerializationCtx)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdWireableBase.OnBindNested(JetBrains.Lifetimes.Lifetime)">
            <summary>
            Override this if you got nested bindable entities. Will be called for the bracket when our entity is bound. Call <see cref="M:JetBrains.Platform.RdFramework.Reflection.RdWireableBase.BindNested(JetBrains.Platform.RdFramework.Reflection.RdWireableBase[])" /> for any nested bindble, with this lifetime, or with a nested lifetime when a bindable child is present.
            </summary>
            <param name="lifetime"></param>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdWireableBase.OnPreBindNested(JetBrains.Lifetimes.Lifetime)">
            <summary>
            Override this if you got nested bindable entities. Will be called for the bracket when our entity is bound. Call <see cref="!:BindNested(JetBrains.Lifetimes.Lifetime,IRdBindable,string)" /> for any nested bindable, with this lifetime, or with a nested lifetime when a bindable child is present.
            </summary>
            <param name="lifetime"></param>
        </member>
        <member name="P:JetBrains.Platform.RdFramework.Reflection.RdWireableBase.ShortName">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Platform.RdFramework.Reflection.RdWireableTrait">
            <summary>
              <para>When you need to inherit from an existing class, allows to implement <see cref="T:JetBrains.Rd.Base.IRdBindable" /> / <see cref="T:JetBrains.Rd.Base.IRdWireable" /> as an aggregated trait by redirecting all calls to it.</para>
              <para>To impl wire receive, pass the callback to the ctor.</para>
              <para>To impl nested bindables, call <see cref="M:JetBrains.Platform.RdFramework.Reflection.RdWireableBase.BindNested(JetBrains.Platform.RdFramework.Reflection.RdWireableBase[])" /> when you get them, under <see cref="P:JetBrains.Rd.Base.RdBindableBase.BindState" /> being <see cref="F:JetBrains.Rd.Base.BindState.Bound" />.</para>
              <para>That's about all you need to do.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdWireableTrait.#ctor(JetBrains.DataFlow.PropertyId,JetBrains.Platform.RdFramework.Reflection.RdWireableTrait.OnWireReceivedDelegate,JetBrains.Platform.RdFramework.Reflection.RdWireableTrait.OnBindDelegate,JetBrains.Platform.RdFramework.Reflection.RdWireableTrait.OnPreBindDelegate)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Reflection.RdWireableTrait.OnWireReceived(JetBrains.Rd.IProtocol,JetBrains.Rd.SerializationCtx,JetBrains.Serialization.UnsafeReader,JetBrains.Rd.Base.IRdWireableDispatchHelper)">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Platform.RdFramework.Reflection.ReactiveFactory">
            Helper to create reactive entities with polymorphic serialization.
        </member>
        <member name="T:JetBrains.Platform.RdFramework.Serialization.DiagnosticLookupRdIdOfTypeInCurrentAppdomain">
            <summary>
            To be able to tell the name of the type in the "Unknown Type" errors, scans the current appdomain for all the types and checks their IDs.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Serialization.DiagnosticLookupRdIdOfTypeInCurrentAppdomain.ReportKnownType(System.Type)">
            <summary>
            Report a type hint.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Serialization.DiagnosticLookupRdIdOfTypeInCurrentAppdomain.TryFindTypeByRdId(JetBrains.Rd.RdId)">
            <summary>
            Lookup among explicitly hinted types, and all types in the current appdomain.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Serialization.Icons.IconIdWriteHelper.EqualsMarshalledIconId(JetBrains.UI.Icons.IconId,JetBrains.UI.Icons.IconId)">
            <summary>
            Compares IconId for equality based on the ToString() representation.
            Is needed for comparing marshalled icons due to changing their type while marshalling.
            A temporary hack until the moniker-based comparing mechanism is implemented.   
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Serialization.RegisterSerializersForWellKnownTypes.JetBrains#Platform#RdFramework#RdVerification#IRdConfigurator#OnCreated(JetBrains.Rd.Reflection.ReflectionSerializersFacade)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Serialization.SerializersEx.ReadRd``1(JetBrains.Serialization.UnsafeReader,JetBrains.Rd.SerializationCtx)">
            <summary>
            Deserializes a value of type <typeparamref name="TValue" /> or of a derived type (polymorphic serialization) using the set of known serializers registered with the Rd's <see cref="T:JetBrains.Rd.ISerializers" /> of your context.
            </summary>
            <typeparam name="TValue">Base type of the value.</typeparam>
            <param name="this">Reader.</param>
            <param name="ctx">The serialization context in which you are operating. When working in Rd world, you can declare serializer method overloads which take this as a parameter.</param>
            <returns>A value deserialized out of the byte stream.</returns>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Serialization.SerializersEx.WriteRd``1(JetBrains.Serialization.UnsafeWriter,JetBrains.Rd.SerializationCtx,``0)">
            <summary>
            Serializes a value of type <typeparamref name="TValue" /> or of a derived type (polymorphic serialization) using the set of known serializers registered with the Rd's <see cref="T:JetBrains.Rd.ISerializers" /> of your context.
            </summary>
            <typeparam name="TValue">Base type of the value.</typeparam>
            <param name="this">Writer.</param>
            <param name="ctx">The serialization context in which you are operating. When working in Rd world, you can declare serializer method overloads which take this as a parameter.</param>
            <param name="value">Value to be serialized into bytes.</param>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Serialization.SerializersEx.ReadForceInterned``1(JetBrains.Rd.SerializationCtx,JetBrains.Serialization.UnsafeReader)">
            <summary>
            A more deterministic version of <see cref="M:JetBrains.Rd.SerializationCtx.ReadInterned``1(JetBrains.Serialization.UnsafeReader,System.String,JetBrains.Rd.CtxReadDelegate{``0})"/>/<see cref="M:JetBrains.Rd.SerializationCtx.WriteInterned``1(JetBrains.Serialization.UnsafeWriter,``0,System.String,JetBrains.Rd.CtxWriteDelegate{``0})"/>.
            * Would not silently revert to writing full body values in case smth didn't match,
              eg an intern root is not registered at that level. Make this an assertion for now, as we need intern to work reliably.
              Also, bind to the protocol-global instance, which avoids registering it manually. Cons: uses the default poly serializer.
            * Does not skip interning transparently on "invalid id", also an assertion.
            * Does not take manual serializers which would only be used in part of the scenarios.
              This one only uses default serializers registered with the global protocol root (polymorphic).
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Serialization.SerializersEx.WriteForceInterned``1(JetBrains.Rd.SerializationCtx,JetBrains.Serialization.UnsafeWriter,``0)">
            <inheritdoc cref="M:JetBrains.Platform.RdFramework.Serialization.SerializersEx.ReadForceInterned``1(JetBrains.Rd.SerializationCtx,JetBrains.Serialization.UnsafeReader)"/>
        </member>
        <member name="F:JetBrains.Platform.RdFramework.Serialization.SerializersEx.ProtocolGlobalInternRootKey">
            <summary>
            Magic value to attach to the global ever-existing intern root. Hardcoded in Rd/Protocol as private const.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Util.RdCallEx.StartOrLocal``2(JetBrains.Rd.Tasks.RdCall{``0,``1},``0,JetBrains.Collections.Viewable.IScheduler)">
            <summary>
            Start RdCall or run it locally on local protocols (on the same RdCall instance)
            
            Temporary until Rd updated with support for short-circuit RdCalls on local protocol 
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Util.RdCallEx.SyncNested``2(JetBrains.Rd.Tasks.RdCall{``0,``1},``0)">
            <summary>
            Sync call which allow nested call execution with help of <see cref="T:JetBrains.Rd.Reflection.SwitchingScheduler"/>
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Util.RdCallEx.SyncNested``2(JetBrains.Rd.Tasks.RdCall{``0,``1},JetBrains.Lifetimes.Lifetime,``0)">
            <summary>
            Sync call which allow nested call execution with help of <see cref="T:JetBrains.Rd.Reflection.SwitchingScheduler"/>
            Provided lifetime is used to defined bind lifetime of returned Bindable entity
            </summary>
        </member>
        <member name="T:JetBrains.Platform.RdFramework.Util.UInOutSignal`2">
            <summary>
            A wrapper around <see cref="T:JetBrains.Rd.Tasks.RdCall`2"/> to support two-sides calls, exposing a signal interface.
            The value for out signal can be provided only by the protocol counterpart, not the local side.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Util.UInOutSignal`2.#ctor(JetBrains.Rd.CtxReadDelegate{`0},JetBrains.Rd.CtxWriteDelegate{`0},JetBrains.Rd.CtxReadDelegate{`1},JetBrains.Rd.CtxWriteDelegate{`1})">
            <summary> 
            It is discouraged to use this constructor directly (as well as for others Rd-entities in reflection-based Rd), use
            <see cref="T:JetBrains.Rd.Reflection.ReflectionRdActivator"/> or similar runtime factory. It is incredible important to have synchronized
            serializers on the both sides. If you provide serializers manually, the runtime activator used by proxy generator
            will be unable to guess proper serializer at the counterpart side which will lead to undefined behaviour.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Util.UInOutSignal`2.FireAsync(`0)">
            <summary>
            Ask the counterpart to provide value asynchronously
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Util.UInOutSignal`2.Fire(JetBrains.DataFlow.InOutEventArgs{`0,`1})">
            <summary>
            Ask the counterpart to provide value
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Util.UInOutSignal`2.Advise(JetBrains.Lifetimes.Lifetime,System.Action{JetBrains.DataFlow.InOutEventArgs{`0,`1}})">
            <summary>
            Subscribe to values requests from the other side
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Util.UListEvents`1.OnAcknowledgeSinkAddRemove_Add(System.Action{JetBrains.DataFlow.AddRemoveIndexEventArgs{`0}})">
            <summary>
            Ackhowledges the handler.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Util.UListEvents`1.OnAcknowledgeSinkAddRemove_Remove(System.Action{JetBrains.DataFlow.AddRemoveIndexEventArgs{`0}})">
            <summary>
            Ackhowledges the handler.
            Cannot be merged with <see cref="M:JetBrains.Platform.RdFramework.Util.UListEvents`1.OnAcknowledgeSinkAddRemove_Add(System.Action{JetBrains.DataFlow.AddRemoveIndexEventArgs{`0}})"/> because the iteration should go in the reverse order.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Util.UListEvents`1.OnAcknowledgeSinkAddRemove(System.Action{JetBrains.DataFlow.AddRemoveEventArgs{`0}},JetBrains.Collections.Viewable.AddRemove)">
            <summary>
            Ackhowledges the handler.
            </summary>
        </member>
        <member name="P:JetBrains.Platform.RdFramework.Util.UProperty`1.Change">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.Platform.RdFramework.Util.UProperty`1.Id">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.Platform.RdFramework.Util.UProperty`1.IsNullValueAllowed">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.Platform.RdFramework.Util.UProperty`1.Maybe">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.Platform.RdFramework.Util.UProperty`1.Value">
            <inheritdoc cref="P:JetBrains.Platform.RdFramework.Util.UProperty`1.Value" />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Util.UProperty`1.JetBrains#Collections#Viewable#ISource{TValue}#Advise(JetBrains.Lifetimes.Lifetime,System.Action{`0})">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.Platform.RdFramework.Util.UProperty`1.JetBrains#DataFlow#IHaveUntypedProperty#AsUntyped">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.Platform.RdFramework.Util.UProperty`1.JetBrains#DataFlow#IProperty{TValue}#BeforeChange">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Util.UProperty`1.JetBrains#Rd#Base#IRdBindable#PreBind(JetBrains.Lifetimes.Lifetime,JetBrains.Rd.Base.IRdDynamic,System.String)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Util.UProperty`1.JetBrains#Rd#Base#IRdBindable#Bind">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.Platform.RdFramework.Util.UProperty`1.JetBrains#Collections#Viewable#IReadonlyProperty{TValue}#Change">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Util.UProperty`1.System#IDisposable#Dispose">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Util.UProperty`1.JetBrains#DataFlow#IProperty{TValue}#GetValue">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Util.UProperty`1.JetBrains#DataFlow#IProperty{TValue}#GetValue(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Util.UProperty`1.JetBrains#Rd#Base#IRdBindable#Identify(JetBrains.Rd.IIdentities,JetBrains.Rd.RdId)">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.Platform.RdFramework.Util.UProperty`1.JetBrains#Rd#Base#IRdDynamic#Location">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Util.UProperty`1.JetBrains#Rd#Base#IPrintable#Print(JetBrains.Rd.Util.PrettyPrinter)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Util.UProperty`1.JetBrains#Rd#Base#IRdDynamic#TryGetProto">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.Platform.RdFramework.Util.UProperty`1.JetBrains#Rd#Base#IRdBindable#RdId">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Util.UProperty`1.JetBrains#Rd#Base#IRdDynamic#TryGetSerializationContext(JetBrains.Rd.SerializationCtx@)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Util.UProperty`1.JetBrains#DataFlow#IProperty{TValue}#SetValue(`0)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.RdFramework.Util.UProperty`1.SetValue(`0,System.Object)">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Rd.ClientId">
            <summary>
            ClientId is a global context class that is used to distinguish the originator of an action in multi-client systems
            In such systems, each client has their own ClientId.
            
            The context is automatically propagated across async/await calls using AsyncLocal. The application should take care to preserve and propagate the current value across other kinds of asynchronous calls. 
            </summary>
        </member>
        <member name="M:JetBrains.Rd.ClientIdEx.IsLocal(JetBrains.Rd.ClientId)">
            <summary>
            Returns true if <paramref name="clientId"/> represents local IDE user, and false if a <paramref name="clientId"/> is a guest user
            </summary>
            <param name="clientId"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Utils.ClientIdUtils.ClientIdUtil.AssertClientIdConsistency(JetBrains.Rd.ClientId,System.String)">
            <summary>
            Asserts that given client id equals to the ClientId.Current
            </summary>
            <param name="clientId"></param>
            <param name="message"></param>
        </member>
        <member name="M:JetBrains.Util.Utils.ClientIdUtils.ClientIdUtil.BindToClientId(JetBrains.Lifetimes.Lifetime,JetBrains.Rd.ClientId)">
            <summary>
            Returns a lifetime which parent is given <paramref name="lifetime"/> but termination handlers are executed under specified <paramref name="clientId"/>
            </summary>
        </member>
    </members>
</doc>
